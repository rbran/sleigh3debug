pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    r2,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    sp,
    lr,
    pc,
    NG,
    ZR,
    CY,
    OV,
    tmpNG,
    tmpZR,
    tmpCY,
    tmpOV,
    shift_carry,
    TB,
    Q,
    GE1,
    GE2,
    GE3,
    GE4,
    cpsr,
    spsr,
    mult_addr,
    r14_svc,
    r13_svc,
    spsr_svc,
    mult_dat8,
    mult_dat16,
    fpsr,
    ISAModeSwitch,
    fp0,
    fp1,
    fp2,
    fp3,
    fp4,
    fp5,
    fp6,
    fp7,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    cr11,
    cr12,
    cr13,
    cr14,
    cr15,
    contextreg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::r0 => "r0",
            Self::r1 => "r1",
            Self::r2 => "r2",
            Self::r3 => "r3",
            Self::r4 => "r4",
            Self::r5 => "r5",
            Self::r6 => "r6",
            Self::r7 => "r7",
            Self::r8 => "r8",
            Self::r9 => "r9",
            Self::r10 => "r10",
            Self::r11 => "r11",
            Self::r12 => "r12",
            Self::sp => "sp",
            Self::lr => "lr",
            Self::pc => "pc",
            Self::NG => "NG",
            Self::ZR => "ZR",
            Self::CY => "CY",
            Self::OV => "OV",
            Self::tmpNG => "tmpNG",
            Self::tmpZR => "tmpZR",
            Self::tmpCY => "tmpCY",
            Self::tmpOV => "tmpOV",
            Self::shift_carry => "shift_carry",
            Self::TB => "TB",
            Self::Q => "Q",
            Self::GE1 => "GE1",
            Self::GE2 => "GE2",
            Self::GE3 => "GE3",
            Self::GE4 => "GE4",
            Self::cpsr => "cpsr",
            Self::spsr => "spsr",
            Self::mult_addr => "mult_addr",
            Self::r14_svc => "r14_svc",
            Self::r13_svc => "r13_svc",
            Self::spsr_svc => "spsr_svc",
            Self::mult_dat8 => "mult_dat8",
            Self::mult_dat16 => "mult_dat16",
            Self::fpsr => "fpsr",
            Self::ISAModeSwitch => "ISAModeSwitch",
            Self::fp0 => "fp0",
            Self::fp1 => "fp1",
            Self::fp2 => "fp2",
            Self::fp3 => "fp3",
            Self::fp4 => "fp4",
            Self::fp5 => "fp5",
            Self::fp6 => "fp6",
            Self::fp7 => "fp7",
            Self::cr0 => "cr0",
            Self::cr1 => "cr1",
            Self::cr2 => "cr2",
            Self::cr3 => "cr3",
            Self::cr4 => "cr4",
            Self::cr5 => "cr5",
            Self::cr6 => "cr6",
            Self::cr7 => "cr7",
            Self::cr8 => "cr8",
            Self::cr9 => "cr9",
            Self::cr10 => "cr10",
            Self::cr11 => "cr11",
            Self::cr12 => "cr12",
            Self::cr13 => "cr13",
            Self::cr14 => "cr14",
            Self::cr15 => "cr15",
            Self::contextreg => "contextreg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r1,
        2 => Register::r3,
        4 => Register::r5,
        6 => Register::r7,
        8 => Register::r9,
        10 => Register::r11,
        12 => Register::sp,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::cr11,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::cr11,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r8,
        1 => Register::r9,
        2 => Register::r10,
        3 => Register::r11,
        4 => Register::r12,
        5 => Register::sp,
        6 => Register::lr,
        7 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("p0"),
        1 => <DisplayElement>::Literal("p1"),
        2 => <DisplayElement>::Literal("p2"),
        3 => <DisplayElement>::Literal("p3"),
        4 => <DisplayElement>::Literal("p4"),
        5 => <DisplayElement>::Literal("p5"),
        6 => <DisplayElement>::Literal("p6"),
        7 => <DisplayElement>::Literal("p7"),
        8 => <DisplayElement>::Literal("p8"),
        9 => <DisplayElement>::Literal("p9"),
        10 => <DisplayElement>::Literal("p10"),
        11 => <DisplayElement>::Literal("p11"),
        12 => <DisplayElement>::Literal("p12"),
        13 => <DisplayElement>::Literal("p13"),
        14 => <DisplayElement>::Literal("p14"),
        15 => <DisplayElement>::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("opt0"),
        1 => <DisplayElement>::Literal("opt1"),
        2 => <DisplayElement>::Literal("opt2"),
        3 => <DisplayElement>::Literal("opt3"),
        4 => <DisplayElement>::Literal("opt4"),
        5 => <DisplayElement>::Literal("opt5"),
        6 => <DisplayElement>::Literal("opt6"),
        7 => <DisplayElement>::Literal("opt7"),
        8 => <DisplayElement>::Literal("opt8"),
        9 => <DisplayElement>::Literal("opt9"),
        10 => <DisplayElement>::Literal("opt10"),
        11 => <DisplayElement>::Literal("opt11"),
        12 => <DisplayElement>::Literal("opt12"),
        13 => <DisplayElement>::Literal("opt13"),
        14 => <DisplayElement>::Literal("opt14"),
        15 => <DisplayElement>::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("opt0"),
        1 => <DisplayElement>::Literal("opt1"),
        2 => <DisplayElement>::Literal("OSHST"),
        3 => <DisplayElement>::Literal("OSH"),
        4 => <DisplayElement>::Literal("opt4"),
        5 => <DisplayElement>::Literal("opt5"),
        6 => <DisplayElement>::Literal("NSHST"),
        7 => <DisplayElement>::Literal("NSH"),
        8 => <DisplayElement>::Literal("opt8"),
        9 => <DisplayElement>::Literal("opt9"),
        10 => <DisplayElement>::Literal("ISHST"),
        11 => <DisplayElement>::Literal("ISH"),
        12 => <DisplayElement>::Literal("opt12"),
        13 => <DisplayElement>::Literal("opt13"),
        14 => <DisplayElement>::Literal("ST"),
        15 => <DisplayElement>::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("p0"),
        1 => <DisplayElement>::Literal("p1"),
        2 => <DisplayElement>::Literal("p2"),
        3 => <DisplayElement>::Literal("p3"),
        4 => <DisplayElement>::Literal("p4"),
        5 => <DisplayElement>::Literal("p5"),
        6 => <DisplayElement>::Literal("p6"),
        7 => <DisplayElement>::Literal("p7"),
        8 => <DisplayElement>::Literal("p8"),
        9 => <DisplayElement>::Literal("p9"),
        10 => <DisplayElement>::Literal("p10"),
        11 => <DisplayElement>::Literal("p11"),
        12 => <DisplayElement>::Literal("p12"),
        13 => <DisplayElement>::Literal("p13"),
        14 => <DisplayElement>::Literal("p14"),
        15 => <DisplayElement>::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: c2327 thv_c2327"]
fn token_39(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 31) as u8)
}
#[doc = "Create token_fields: c0405 thv_c0405"]
fn token_96(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: opcode3 c0407 thv_c0407"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: lsb sftimm c0711 thv_c0711"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 31) as u8)
}
#[doc = "Create token_fields: c1415 thv_c1415"]
fn token_64(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: part2J2 l11 thc1111"]
fn token_121(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: bit28 thv_bit28 thv_c2828"]
fn token_33(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 28) & 1) as u8)
}
#[doc = "Create token_fields: part2c0707 thU7 l07 h1 thc0707"]
fn token_135(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: sop0407 thopcode1 fcond thc0407"]
fn token_144(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: sop0507 thopcode2 thc0507"]
fn token_145(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: c0809 thv_c0809"]
fn token_79(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 3) as u8)
}
#[doc = "Create token_fields: c1818 thv_c1818"]
fn token_52(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 1) as u8)
}
#[doc = "Create token_fields: part2Rt op12 Ra1215 Rt1215 thCRd thc1215"]
fn token_131(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: W21 c2121 thv_bit21 thv_c2121"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 1) as u8)
}
#[doc = "Create token_fields: c0006 thv_c0006"]
fn token_111(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: pref c0031 thv_c0031"]
fn token_1(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 4294967295) as u32)
}
#[doc = "Create token_fields: sop0608 Rm0608 immed3"]
fn token_147(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 7) as u8)
}
#[doc = "Create token_fields: Rm0306 rm0306"]
fn token_154(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 15) as u8)
}
#[doc = "Create token_fields: thc0101"]
fn token_172(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: thc0405"]
fn token_165(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: thc1315"]
fn token_180(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: I25 c2525 thv_c2525"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 1) as u8)
}
#[doc = "Create token_fields: shft c0506 thv_c0506"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 3) as u8)
}
#[doc = "Create token_fields: Rd0811 Rt0811 thcond thcpn th_psrmask thc0811"]
fn token_152(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 15) as u8)
}
#[doc = "Create token_fields: c0815"]
fn token_78(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 255) as u8)
}
#[doc = "Create token_fields: thc1414"]
fn token_169(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: c1821 thv_c1821"]
fn token_50(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 15) as u8)
}
#[doc = "Create token_fields: c2531 thv_c2531"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 127) as u8)
}
#[doc = "Create token_fields: thc0215"]
fn token_175(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 2) & 16383) as u16)
}
#[doc = "Create token_fields: part2c1212 thc1212"]
fn token_129(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: thv_c0104"]
fn token_117(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 15) as u8)
}
#[doc = "Create token_fields: thc0409"]
fn token_166(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 63) as u8)
}
#[doc = "Create token_fields: c1919 thv_c1919"]
fn token_49(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 1) as u8)
}
#[doc = "Create token_fields: op9 thc0915"]
fn token_142(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 127) as u8)
}
#[doc = "Create token_fields: U23 c2323 thv_bit23 thv_c2323"]
fn token_5(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 1) as u8)
}
#[doc = "Create token_fields: cond c2831 thv_c2831"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 28) & 15) as u8)
}
#[doc = "Create token_fields: offset_12 c0011 thv_c0011"]
fn token_24(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 4095) as u16)
}
#[doc = "Create token_fields: immed24 addr24"]
fn token_23(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 16777215) as u32)
}
#[doc = "Create token_fields: c2027 thv_c2027"]
fn token_44(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 255) as u8)
}
#[doc = "Create token_fields: c1721 thv_c1721"]
fn token_53(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 31) as u8)
}
#[doc = "Create token_fields: c1719 thv_c1719"]
fn token_54(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 7) as u8)
}
#[doc = "Create token_fields: c2331 thv_c2331"]
fn token_38(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 511) as u16)
}
#[doc = "Create token_fields: c1618 thv_c1618"]
fn token_60(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 7) as u8)
}
#[doc = "Create token_fields: c1617 thv_c1617"]
fn token_61(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 3) as u8)
}
#[doc = "Create token_fields: part2c1415 thc1415"]
fn token_128(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: srsMode c0004 thv_c0004"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: part2c0505 thW5 thwbit thc0505"]
fn token_136(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: op7 thc0715"]
fn token_140(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 7) & 511) as u16)
}
#[doc = "Create token_fields: c1819 thv_c1819"]
fn token_51(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 3) as u8)
}
#[doc = "Create token_fields: c0911 thv_c0911"]
fn token_76(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 7) as u8)
}
#[doc = "Create token_fields: imm5 sysm37 thc0307"]
fn token_161(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 31) as u8)
}
#[doc = "Create token_fields: immed c0007 thv_immed thv_c0007"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: c2527 thv_c2527"]
fn token_36(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 7) as u8)
}
#[doc = "Create token_fields: c0611 thv_c0611"]
fn token_85(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 63) as u8)
}
#[doc = "Create token_fields: opc1 c2123 thv_c2123"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 7) as u8)
}
#[doc = "Create token_fields: c2022 thv_c2022"]
fn token_46(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 7) as u8)
}
#[doc = "Create token_fields: c1921 thv_c1921"]
fn token_48(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 7) as u8)
}
#[doc = "Create token_fields: c1718 thv_c1718"]
fn token_55(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 3) as u8)
}
#[doc = "Create token_fields: c1015"]
fn token_71(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: c0101 thv_c0101"]
fn token_103(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: part2c0615 op6 thc0615"]
fn token_130(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: sop0610 immed5"]
fn token_148(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 31) as u8)
}
#[doc = "Create token_fields: immed12_imm3 imm3_12 imm3_shft thc1214"]
fn token_157(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 7) as u8)
}
#[doc = "Create token_fields: c0408"]
fn token_94(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 31) as u8)
}
#[doc = "Create token_fields: part2c0909 thI9 addr_ubit thc0909"]
fn token_133(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 1) as u8)
}
#[doc = "Create token_fields: thB6 thN6 thS6 h2 thc0606"]
fn token_155(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: imm2_shft thc0607"]
fn token_160(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: thc0107"]
fn token_163(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 127) as u8)
}
#[doc = "Create token_fields: thc0910"]
fn token_168(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 3) as u8)
}
#[doc = "Create token_fields: c0027 thv_c0027"]
fn token_104(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 268435455) as u32)
}
#[doc = "Create token_fields: thc0000"]
fn token_173(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: bit29 thv_bit29"]
fn token_32(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 29) & 1) as u8)
}
#[doc = "Create token_fields: Rn satimm4 mask CRn RdHi smRd Qn0 Qn1 Dn0 Dn1 Sn0 Sn1 c1619 thv_Qn0 thv_Qn1 thv_Dn0 thv_Dn1 thv_Sn0 thv_Sn1 thv_Rn thv_c1619"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 15) as u8)
}
#[doc = "Create token_fields: c1111 thv_c1111"]
fn token_70(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: c2127 thv_c2127"]
fn token_42(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 127) as u8)
}
#[doc = "Create token_fields: c0916"]
fn token_74(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 255) as u8)
}
#[doc = "Create token_fields: opcode1"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 15) as u8)
}
#[doc = "Create token_fields: c1414 thv_c1414"]
fn token_65(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: c0012"]
fn token_107(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 8191) as u16)
}
#[doc = "Create token_fields: thv_c0015"]
fn token_118(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: thc0515"]
fn token_177(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 2047) as u16)
}
#[doc = "Create token_fields: c1313 thv_c1313"]
fn token_67(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: c1621 thv_c1621"]
fn token_59(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 63) as u8)
}
#[doc = "Create token_fields: thc1015"]
fn token_178(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: sopit immed8 immed12_imm8 soffset8 sysm thc0007"]
fn token_149(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: thc0115"]
fn token_174(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 32767) as u16)
}
#[doc = "Create token_fields: c0411 thv_c0411"]
fn token_92(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 255) as u8)
}
#[doc = "Create token_fields: thc0315"]
fn token_176(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 8191) as u16)
}
#[doc = "Create token_fields: c0215 thv_c0215"]
fn token_100(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 16383) as u16)
}
#[doc = "Create token_fields: thc0303"]
fn token_170(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: thv_c2931"]
fn token_115(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 29) & 7) as u8)
}
#[doc = "Create token_fields: c2021 thv_c2021"]
fn token_47(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 3) as u8)
}
#[doc = "Create token_fields: part2imm10 offset10"]
fn token_126(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: part2S immed12_i offset10S addr_pbit thc1010"]
fn token_124(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: throt"]
fn token_159(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: c0013"]
fn token_106(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 16383) as u16)
}
#[doc = "Create token_fields: c0708 thv_c0708"]
fn token_83(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 3) as u8)
}
#[doc = "Create token_fields: c0303 thv_c0303"]
fn token_99(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: immed7 thc0006"]
fn token_156(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: c1115"]
fn token_69(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: sh y Q6 c0606 thv_Q6 thv_bit06 thv_c0606"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: c2427 thv_c2427"]
fn token_37(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 15) as u8)
}
#[doc = "Create token_fields: msb satimm5 c1620 thv_c1620"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 31) as u8)
}
#[doc = "Create token_fields: op8 thc0815"]
fn token_141(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 255) as u8)
}
#[doc = "Create token_fields: c0005"]
fn token_112(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: c0915"]
fn token_75(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 127) as u8)
}
#[doc = "Create token_fields: c0010 thv_c0010"]
fn token_108(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: c0202 thv_c0202"]
fn token_101(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: c0909 thv_c0909"]
fn token_77(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 1) as u8)
}
#[doc = "Create token_fields: c1010 thv_c1010"]
fn token_73(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: part2cond"]
fn token_122(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 15) as u8)
}
#[doc = "Create token_fields: part2c0011 offset12 thc0011"]
fn token_132(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 4095) as u16)
}
#[doc = "Create token_fields: part2Rd0003 sop0003 Rd0003 Rn0003 Rm0003 thCRn thCRm thc0003"]
fn token_138(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: c1627 thv_c1627"]
fn token_58(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 4095) as u16)
}
#[doc = "Create token_fields: c1315"]
fn token_66(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: opc2 opcode2 c0507 thv_c0507"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: c0615"]
fn token_84(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: P24 H24 L24 c2424 thv_c2424"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 1) as u8)
}
#[doc = "Create token_fields: c0404 thv_c0404"]
fn token_97(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: c1616 thv_c1616"]
fn token_62(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1) as u8)
}
#[doc = "Create token_fields: c0009"]
fn token_109(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: c1717 thv_c1717"]
fn token_56(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 1) as u8)
}
#[doc = "Create token_fields: part2off_10"]
fn token_127(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 1023) as u16)
}
#[doc = "Create token_fields: c0001 thv_c0001"]
fn token_113(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: part2c0808 thP8 thH8 thL8 R addr_wbit thc0808"]
fn token_134(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 1) as u8)
}
#[doc = "Create token_fields: S20 L20 c2020 thv_bit20 thv_c2020"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 1) as u8)
}
#[doc = "Create token_fields: op c2124 thv_c2124"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 15) as u8)
}
#[doc = "Create token_fields: c0431 thv_c0431"]
fn token_89(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 268435455) as u32)
}
#[doc = "Create token_fields: c0515"]
fn token_87(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 2047) as u16)
}
#[doc = "Create token_fields: bit31 thv_bit31"]
fn token_30(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 31) & 1) as u8)
}
#[doc = "Create token_fields: c0008 thv_c0008"]
fn token_110(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 511) as u16)
}
#[doc = "Create token_fields: bit30 thv_bit30"]
fn token_31(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 30) & 1) as u8)
}
#[doc = "Create token_fields: Dm_3 Sm0_3 Sm1_3 c0002 thv_Dm_3 thv_Sm0_3 thv_Sm1_3"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: c0315"]
fn token_98(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 8191) as u16)
}
#[doc = "Create token_fields: part2J1 thc1313"]
fn token_120(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: part2imm11 part2off offset11 soffset11"]
fn token_125(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: c0607 thv_c0607"]
fn token_86(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: c2627 thv_c2627"]
fn token_34(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 26) & 3) as u8)
}
#[doc = "Create token_fields: c0715"]
fn token_81(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 511) as u16)
}
#[doc = "Create token_fields: c0415"]
fn token_91(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 4095) as u16)
}
#[doc = "Create token_fields: part2op op11 thc1115"]
fn token_119(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: c1011 thv_c1011"]
fn token_72(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 3) as u8)
}
#[doc = "Create token_fields: part2c0404 thL4 thc0404"]
fn token_137(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: immed12"]
fn token_15(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 4095) as u16)
}
#[doc = "Create token_fields: op4 thc0415"]
fn token_139(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 4095) as u16)
}
#[doc = "Create token_fields: Rn0305 Rm0305 Rs0305 hrm0305"]
fn token_153(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 7) as u8)
}
#[doc = "Create token_fields: c2024 thv_c2024"]
fn token_45(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 31) as u8)
}
#[doc = "Create token_fields: c2131 thv_c2131"]
fn token_41(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 2047) as u16)
}
#[doc = "Create token_fields: part2imm6 immed6 thc0005"]
fn token_123(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: c1212 thv_c1212"]
fn token_68(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: smRm Rs rotate immedH cpn RmHi cmode c0811 thv_cmode thv_Rt2 thv_c0811"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 15) as u8)
}
#[doc = "Create token_fields: c2122 thv_c2122"]
fn token_43(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 3) as u8)
}
#[doc = "Create token_fields: c0427 thv_c0427"]
fn token_90(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 16777215) as u32)
}
#[doc = "Create token_fields: op0"]
fn token_143(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: thc0202"]
fn token_171(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: c1631 thv_c1631"]
fn token_57(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 65535) as u16)
}
#[doc = "Create token_fields: thc0207"]
fn token_164(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 2) & 63) as u8)
}
#[doc = "Create token_fields: c0409 thv_c0409"]
fn token_93(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 63) as u8)
}
#[doc = "Create token_fields: thc0506"]
fn token_167(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 3) as u8)
}
#[doc = "Create token_fields: c2324 thv_c2324"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 3) as u8)
}
#[doc = "Create token_fields: c0014"]
fn token_105(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 32767) as u16)
}
#[doc = "Create token_fields: RnLo CRm smRn immedL immed4 dbOption ibOption Rm Rm2 Qm0 Qm1 Dm0 Dm1 Dm_4 Sm0 Sm0next Sm1 Sm1next c0003 thv_Qm0 thv_Qm1 thv_Dm0 thv_Dm1 thv_Dm_4 thv_Sm0 thv_Sm0next thv_Sm1 thv_Sm1next thv_Rm thv_c0003 thv_option"]
fn token_11(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: c0115"]
fn token_102(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 32767) as u16)
}
#[doc = "Create token_fields: Rd0810 Rn0810 addr_puw thc0810"]
fn token_151(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 7) as u8)
}
#[doc = "Create token_fields: thc0001"]
fn token_162(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: thc1515"]
fn token_181(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 15) & 1) as u8)
}
#[doc = "Create token_fields: B22 N22 S22 D22 c2222 thv_D22 thv_c2222"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 1) as u8)
}
#[doc = "Create token_fields: c0000 thv_bit00 thv_c0000"]
fn token_114(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: thv_c2031"]
fn token_116(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 4095) as u16)
}
#[doc = "Create token_fields: N7 L7 c0707 thv_N7 thv_L7 thv_bit07 thv_c0707"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: thsrsMode thc0004"]
fn token_158(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: c0406 thv_c0406"]
fn token_95(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: c0709 thv_c0709"]
fn token_82(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 7) as u8)
}
#[doc = "Create token_fields: thc1112"]
fn token_179(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 3) as u8)
}
#[doc = "Create token_fields: c0508 thv_c0508"]
fn token_88(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 15) as u8)
}
#[doc = "Create token_fields: Rd Rd2 CRd RdLo smRa Qd0 Qd1 Dd0 Dd_1 Dd_2 Dd_3 Dd_4 Dd_5 Dd_6 Dd_7 Dd_8 Dd_9 Dd_10 Dd_11 Dd_12 Dd_13 Dd_14 Dd_15 Dd_16 Dd1 Sd0 Sd1 c1215 thv_Qd0 thv_Qd1 thv_Dd0 thv_Dd_1 thv_Dd_2 thv_Dd_3 thv_Dd_4 thv_Dd_5 thv_Dd_6 thv_Dd_7 thv_Dd_8 thv_Dd_9 thv_Dd_10 thv_Dd_11 thv_Dd_12 thv_Dd_13 thv_Dd_14 thv_Dd_15 thv_Dd_16 thv_Dd1 thv_Sd0 thv_Sd1 thv_Rd thv_Rt thv_c1215"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: Rd0002 Rn0002 hrn0002 hrd0002 sbz sysm02 thc0002"]
fn token_150(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: c0808 thv_c0808"]
fn token_80(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 1) as u8)
}
#[doc = "Create token_fields: sop0508 addr_puw1"]
fn token_146(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 15) as u8)
}
#[doc = "Create token_fields: x r M5 c0505 thv_M5 thv_c0505"]
fn token_27(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: c1515 thv_c1515"]
fn token_63(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 15) & 1) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u32);
impl ContextMemory {
    pub fn read_TMode(&self) -> u8 {
        (((self.0.reverse_bits() >> 31) & 1) as u8)
    }
    pub fn write_TMode(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 31)) | ((value as u32 & 1) << 31)).reverse_bits();
    }
    pub fn read_T(&self) -> u8 {
        (((self.0.reverse_bits() >> 31) & 1) as u8)
    }
    pub fn write_T(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 31)) | ((value as u32 & 1) << 31)).reverse_bits();
    }
    pub fn read_LowBitCodeMode(&self) -> u8 {
        (((self.0.reverse_bits() >> 31) & 1) as u8)
    }
    pub fn write_LowBitCodeMode(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 31)) | ((value as u32 & 1) << 31)).reverse_bits();
    }
    pub fn read_ISA_MODE(&self) -> u8 {
        (((self.0.reverse_bits() >> 31) & 1) as u8)
    }
    pub fn write_ISA_MODE(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 31)) | ((value as u32 & 1) << 31)).reverse_bits();
    }
    pub fn read_LRset(&self) -> u8 {
        (((self.0.reverse_bits() >> 30) & 1) as u8)
    }
    pub fn write_LRset(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 30)) | ((value as u32 & 1) << 30)).reverse_bits();
    }
    pub fn read_REToverride(&self) -> u8 {
        (((self.0.reverse_bits() >> 29) & 1) as u8)
    }
    pub fn write_REToverride(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 29)) | ((value as u32 & 1) << 29)).reverse_bits();
    }
    pub fn read_CALLoverride(&self) -> u8 {
        (((self.0.reverse_bits() >> 28) & 1) as u8)
    }
    pub fn write_CALLoverride(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 28)) | ((value as u32 & 1) << 28)).reverse_bits();
    }
    pub fn read_counter(&self) -> u8 {
        (((self.0.reverse_bits() >> 23) & 31) as u8)
    }
    pub fn write_counter(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 23)) | ((value as u32 & 31) << 23)).reverse_bits();
    }
    pub fn read_regNum(&self) -> u8 {
        (((self.0.reverse_bits() >> 18) & 31) as u8)
    }
    pub fn write_regNum(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 18)) | ((value as u32 & 31) << 18)).reverse_bits();
    }
    pub fn read_counter2(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 7) as u8)
    }
    pub fn write_counter2(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 15)) | ((value as u32 & 7) << 15)).reverse_bits();
    }
    pub fn read_reg2Num(&self) -> u8 {
        (((self.0.reverse_bits() >> 10) & 31) as u8)
    }
    pub fn write_reg2Num(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 10)) | ((value as u32 & 31) << 10)).reverse_bits();
    }
    pub fn read_regInc(&self) -> u8 {
        (((self.0.reverse_bits() >> 8) & 3) as u8)
    }
    pub fn write_regInc(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 8)) | ((value as u32 & 3) << 8)).reverse_bits();
    }
    pub fn read_ARMcond(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 1) as u8)
    }
    pub fn write_ARMcond(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 7)) | ((value as u32 & 1) << 7)).reverse_bits();
    }
    pub fn read_ARMcondCk(&self) -> u8 {
        (((self.0.reverse_bits() >> 6) & 1) as u8)
    }
    pub fn write_ARMcondCk(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 6)) | ((value as u32 & 1) << 6)).reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3494:1, end:3494:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar0 {}
impl mov_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mov"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3563:1, end:3563:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar1 {
    rm: Tablerm,
}
impl mov_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mov"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(1i128 & 1).unwrap());
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2269:1, end:2269:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar2 {
    Addr24: TableAddr24,
}
impl bl_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3030:1, end:3030:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar3 {
    ItCond: TableItCond,
}
impl nop_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(".w")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3262:1, end:3262:2))"]
#[derive(Clone, Debug)]
struct qadd_instructionVar4 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl qadd_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qadd"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rm0003 = token_138(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3330:1, end:3330:2))"]
#[derive(Clone, Debug)]
struct qdadd_instructionVar5 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl qdadd_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qdadd"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3342:1, end:3342:2))"]
#[derive(Clone, Debug)]
struct qdsub_instructionVar6 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl qdsub_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qdsub"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3377:1, end:3377:2))"]
#[derive(Clone, Debug)]
struct qsub_instructionVar7 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl qsub_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qsub"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3993:1, end:3993:2))"]
#[derive(Clone, Debug)]
struct smmul_instructionVar8 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smmul_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smmul"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4000:1, end:4000:2))"]
#[derive(Clone, Debug)]
struct smmulr_instructionVar9 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smmulr_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smmulr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rm0003 = token_138(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4020:1, end:4020:2))"]
#[derive(Clone, Debug)]
struct smulbb_instructionVar10 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smulbb_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smulbb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rm0003 = token_138(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4030:1, end:4030:2))"]
#[derive(Clone, Debug)]
struct smulbt_instructionVar11 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smulbt_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smulbt"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4040:1, end:4040:2))"]
#[derive(Clone, Debug)]
struct smultb_instructionVar12 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smultb_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smultb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4050:1, end:4050:2))"]
#[derive(Clone, Debug)]
struct smultt_instructionVar13 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smultt_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smultt"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1572:1, end:1572:2))"]
#[derive(Clone, Debug)]
struct hlt_instructionVar14 {
    immed12_4: Tableimmed12_4,
}
impl hlt_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("hlt"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let immed12_4 = if let Some((len, table)) =
            Tableimmed12_4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1577:1, end:1577:2))"]
#[derive(Clone, Debug)]
struct bkpt_instructionVar15 {
    immed12_4: Tableimmed12_4,
}
impl bkpt_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bkpt"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let immed12_4 = if let Some((len, table)) =
            Tableimmed12_4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1582:1, end:1582:2))"]
#[derive(Clone, Debug)]
struct hvc_instructionVar16 {
    immed12_4: Tableimmed12_4,
}
impl hvc_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("hvc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let immed12_4 = if let Some((len, table)) =
            Tableimmed12_4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1635:1, end:1635:2))"]
#[derive(Clone, Debug)]
struct udf_instructionVar17 {
    immed12_4: Tableimmed12_4,
}
impl udf_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("udf"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.immed12_4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let immed12_4 = if let Some((len, table)) =
            Tableimmed12_4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2369:1, end:2369:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar18 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bx"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2276:1, end:2276:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar19 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2355:1, end:2355:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar20 {
    rm: Tablerm,
    COND: TableCOND,
}
impl blx_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2377:1, end:2377:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar21 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bx"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2386:1, end:2386:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar22 {
    COND: TableCOND,
    rm: Tablerm,
}
impl bx_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bx"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2394:1, end:2394:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar23 {
    rm: Tablerm,
    COND: TableCOND,
}
impl bx_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bx"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3569:1, end:3569:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar24 {
    COND: TableCOND,
}
impl mov_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2345:1, end:2345:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar25 {
    COND: TableCOND,
    rm: Tablerm,
}
impl blx_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2936:1, end:2936:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar26 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2945:1, end:2945:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar27 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2954:1, end:2954:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar28 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2963:1, end:2963:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar29 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2972:1, end:2972:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar30 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2981:1, end:2981:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar31 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2990:1, end:2990:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar32 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2999:1, end:2999:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar33 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3008:1, end:3008:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar34 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3017:1, end:3017:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar35 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3026:1, end:3026:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar36 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3035:1, end:3035:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar37 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3044:1, end:3044:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar38 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3053:1, end:3053:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar39 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3062:1, end:3062:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar40 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3071:1, end:3071:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar41 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3080:1, end:3080:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar42 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3089:1, end:3089:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar43 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3098:1, end:3098:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar44 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3107:1, end:3107:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar45 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3116:1, end:3116:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar46 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3125:1, end:3125:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar47 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3134:1, end:3134:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar48 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3143:1, end:3143:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar49 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3152:1, end:3152:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar50 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3161:1, end:3161:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar51 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3170:1, end:3170:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar52 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3179:1, end:3179:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar53 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3188:1, end:3188:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar54 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3197:1, end:3197:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar55 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3206:1, end:3206:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar56 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3215:1, end:3215:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar57 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3224:1, end:3224:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar58 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3233:1, end:3233:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar59 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3242:1, end:3242:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar60 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3251:1, end:3251:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar61 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3260:1, end:3260:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar62 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3269:1, end:3269:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar63 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3278:1, end:3278:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar64 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3287:1, end:3287:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar65 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3296:1, end:3296:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar66 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3607:1, end:3607:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar67 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3617:1, end:3617:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar68 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3627:1, end:3627:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar69 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3637:1, end:3637:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar70 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3647:1, end:3647:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar71 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3657:1, end:3657:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar72 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3667:1, end:3667:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar73 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3677:1, end:3677:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar74 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3687:1, end:3687:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar75 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3697:1, end:3697:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar76 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3707:1, end:3707:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar77 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3717:1, end:3717:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar78 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3727:1, end:3727:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar79 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3737:1, end:3737:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar80 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3747:1, end:3747:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar81 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3757:1, end:3757:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar82 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3767:1, end:3767:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar83 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3777:1, end:3777:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar84 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3787:1, end:3787:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar85 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3797:1, end:3797:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar86 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3807:1, end:3807:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar87 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3817:1, end:3817:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar88 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3827:1, end:3827:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar89 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3837:1, end:3837:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar90 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3847:1, end:3847:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar91 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3857:1, end:3857:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar92 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3867:1, end:3867:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar93 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3877:1, end:3877:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar94 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3887:1, end:3887:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar95 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3897:1, end:3897:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar96 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3907:1, end:3907:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar97 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3917:1, end:3917:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar98 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3927:1, end:3927:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar99 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3937:1, end:3937:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar100 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3947:1, end:3947:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar101 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3957:1, end:3957:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar102 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3967:1, end:3967:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar103 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3977:1, end:3977:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar104 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3987:1, end:3987:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar105 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3997:1, end:3997:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar106 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4007:1, end:4007:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar107 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4139:1, end:4139:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar108 {
    Rd: u8,
    COND: TableCOND,
}
impl mrs_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrs"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::cpsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4146:1, end:4146:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar109 {
    Rd: u8,
    COND: TableCOND,
}
impl mrs_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrs"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::spsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2483:1, end:2483:2))"]
#[derive(Clone, Debug)]
struct clz_instructionVar110 {
    Rd: u8,
    COND: TableCOND,
    rm: Tablerm,
}
impl clz_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clz"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rm, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4160:1, end:4160:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar111 {
    rm: Tablerm,
    COND: TableCOND,
    cpsrmask: Tablecpsrmask,
}
impl msr_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) =
            Tablecpsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, COND, cpsrmask }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4182:1, end:4182:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar112 {
    spsrmask: Tablespsrmask,
    COND: TableCOND,
    rm: Tablerm,
}
impl msr_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) =
            Tablespsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { spsrmask, COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4363:1, end:4363:2))"]
#[derive(Clone, Debug)]
struct qadd_instructionVar113 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl qadd_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qadd"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4431:1, end:4431:2))"]
#[derive(Clone, Debug)]
struct qdadd_instructionVar114 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl qdadd_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qdadd"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4443:1, end:4443:2))"]
#[derive(Clone, Debug)]
struct qdsub_instructionVar115 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl qdsub_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qdsub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4478:1, end:4478:2))"]
#[derive(Clone, Debug)]
struct qsub_instructionVar116 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl qsub_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("qsub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5687:1, end:5687:2))"]
#[derive(Clone, Debug)]
struct swp_instructionVar117 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl swp_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5695:1, end:5695:2))"]
#[derive(Clone, Debug)]
struct swpb_instructionVar118 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl swpb_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swpb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rn = token_10(tokens_current);
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3901:1, end:3901:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar119 {
    Rt1215: u8,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smlal_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlal"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rt1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rt1215,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3958:1, end:3958:2))"]
#[derive(Clone, Debug)]
struct smmla_instructionVar120 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
}
impl smmla_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smmla"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3967:1, end:3967:2))"]
#[derive(Clone, Debug)]
struct smmlar_instructionVar121 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
}
impl smmlar_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smmlar"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rm0003 = token_138(tokens_current);
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3976:1, end:3976:2))"]
#[derive(Clone, Debug)]
struct smmls_instructionVar122 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
}
impl smmls_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smmls"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rm0003 = token_138(tokens_current);
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3984:1, end:3984:2))"]
#[derive(Clone, Debug)]
struct smmlsr_instructionVar123 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
}
impl smmlsr_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smmlsr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rm0003 = token_138(tokens_current);
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4060:1, end:4060:2))"]
#[derive(Clone, Debug)]
struct smull_instructionVar124 {
    Ra1215: u8,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
}
impl smull_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smull"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Ra1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Ra1215,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct smc_instructionVar125 {
    immed4: u8,
    COND: TableCOND,
}
impl smc_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed4 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed4 = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, immed4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4087:1, end:4087:2))"]
#[derive(Clone, Debug)]
struct srsdb_instructionVar126 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsdb_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srsdb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal("!,"),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thSRSMode = if let Some((len, table)) =
            TablethSRSMode::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4098:1, end:4098:2))"]
#[derive(Clone, Debug)]
struct srsdb_instructionVar127 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsdb_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srsdb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thSRSMode = if let Some((len, table)) =
            TablethSRSMode::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4108:1, end:4108:2))"]
#[derive(Clone, Debug)]
struct srsib_instructionVar128 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsib_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srsib"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal("!,"),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thSRSMode = if let Some((len, table)) =
            TablethSRSMode::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4119:1, end:4119:2))"]
#[derive(Clone, Debug)]
struct srsia_instructionVar129 {
    ItCond: TableItCond,
    thSRSMode: TablethSRSMode,
}
impl srsia_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srsia"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thSRSMode
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thSRSMode = if let Some((len, table)) =
            TablethSRSMode::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thSRSMode }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1682:1, end:1682:2))"]
#[derive(Clone, Debug)]
struct pld_instructionVar130 {
    addrmode2: Tableaddrmode2,
}
impl pld_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pld"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let mut sub_pattern_c104 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c104 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c104(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c104(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4008:1, end:4008:2))"]
#[derive(Clone, Debug)]
struct smuad_instructionVar131 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
    thdXtop: TablethdXtop,
    thdXbot: TablethdXbot,
}
impl smuad_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smuad"));
        self.thdXbot
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thdXbot = if let Some((len, table)) =
            TablethdXbot::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) =
            TablethdXtop::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXtop,
                thdXbot,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4068:1, end:4068:2))"]
#[derive(Clone, Debug)]
struct smusd_instructionVar132 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
    thdXtop: TablethdXtop,
    thdXbot: TablethdXbot,
}
impl smusd_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smusd"));
        self.thdXbot
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thdXbot = if let Some((len, table)) =
            TablethdXbot::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) =
            TablethdXtop::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0003 = token_138(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXtop,
                thdXbot,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4080:1, end:4080:2))"]
#[derive(Clone, Debug)]
struct smulw_instructionVar133 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
    thYBIT: TablethYBIT,
}
impl smulw_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smulw"));
        self.thYBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thYBIT = if let Some((len, table)) =
            TablethYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0003 = token_138(tokens_current);
        let Rd0811 = token_152(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thYBIT,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1404:1, end:1404:2))"]
#[derive(Clone, Debug)]
struct hvc_instructionVar134 {
    thc0003: u8,
    thc0011: u16,
}
impl hvc_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (u32::try_from(12i128)
            .ok()
            .and_then(|shl| i128::try_from(self.thc0003).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.thc0011).unwrap());
        display.push(DisplayElement::Literal("hvc"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 2;
        let thc0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_tmp = (u32::try_from(12i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_138(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_132(tokens_current)).unwrap());
        let thc0011 = token_132(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thc0003, thc0011 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1410:1, end:1410:2))"]
#[derive(Clone, Debug)]
struct smc_instructionVar135 {
    thc0003: u8,
    ItCond: TableItCond,
}
impl smc_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smc"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.thc0003 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thc0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thc0003 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1426:1, end:1426:2))"]
#[derive(Clone, Debug)]
struct udf_instructionVar136 {
    thc0003: u8,
    thc0011: u16,
    ItCond: TableItCond,
}
impl udf_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (u32::try_from(12i128)
            .ok()
            .and_then(|shl| i128::try_from(self.thc0003).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.thc0011).unwrap());
        display.push(DisplayElement::Literal("udf"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thc0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_tmp = (u32::try_from(12i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_138(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_132(tokens_current)).unwrap());
        let thc0011 = token_132(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thc0003,
                thc0011,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1676:1, end:1676:2))"]
#[derive(Clone, Debug)]
struct pld_instructionVar137 {
    addrmode2: Tableaddrmode2,
}
impl pld_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pld"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let mut sub_pattern_c92 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c92 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c92(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c92(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1875:1, end:1875:2))"]
#[derive(Clone, Debug)]
struct stc2_instructionVar138 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
}
impl stc2_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1881:1, end:1881:2))"]
#[derive(Clone, Debug)]
struct stc2l_instructionVar139 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
}
impl stc2l_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stc2l"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2006:1, end:2006:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar140 {
    COND: TableCOND,
    ArmPCRelImmed12: TableArmPCRelImmed12,
}
impl adr_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c74 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_45(tokens_param) == 8 {
                    return Some(((), (), 4));
                }
                if token_45(tokens_param) == 4 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c74(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                ArmPCRelImmed12,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5308:1, end:5308:2))"]
#[derive(Clone, Debug)]
struct smulw_instructionVar141 {
    smRd: u8,
    smRn: u8,
    smRm: u8,
    YBIT: TableYBIT,
    COND: TableCOND,
}
impl smulw_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smulw"));
        self.YBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.smRd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRm = token_14(tokens_current);
        let smRd = token_10(tokens_current);
        let smRn = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                YBIT,
                COND,
                smRd,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5285:1, end:5285:2))"]
#[derive(Clone, Debug)]
struct smul_instructionVar142 {
    smRd: u8,
    smRn: u8,
    smRm: u8,
    XBIT: TableXBIT,
    COND: TableCOND,
    YBIT: TableYBIT,
}
impl smul_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smul"));
        self.XBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.YBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.smRd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let XBIT = if let Some((len, table)) =
            TableXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRm = token_14(tokens_current);
        let smRd = token_10(tokens_current);
        let smRn = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                XBIT,
                COND,
                YBIT,
                smRd,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4152:1, end:4152:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar143 {
    COND: TableCOND,
    cpsrmask: Tablecpsrmask,
    shift1: Tableshift1,
}
impl msr_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) =
            Tablecpsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4174:1, end:4174:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar144 {
    shift1: Tableshift1,
    COND: TableCOND,
    spsrmask: Tablespsrmask,
}
impl msr_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) =
            Tablespsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                COND,
                spsrmask,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2492:1, end:2492:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar145 {
    rn: Tablern,
    shift1: Tableshift1,
    COND: TableCOND,
}
impl cmn_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift1, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2503:1, end:2503:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar146 {
    rn: Tablern,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl cmn_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, COND, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2514:1, end:2514:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar147 {
    shift3: Tableshift3,
    rn: Tablern,
    COND: TableCOND,
}
impl cmn_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift3, rn, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2525:1, end:2525:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar148 {
    rn: Tablern,
    shift1: Tableshift1,
    COND: TableCOND,
}
impl cmp_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift1, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2536:1, end:2536:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar149 {
    COND: TableCOND,
    shift2: Tableshift2,
    rn: Tablern,
}
impl cmp_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift2, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2547:1, end:2547:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar150 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl cmp_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3537:1, end:3537:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar151 {
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl mov_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5624:1, end:5624:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar152 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl sub_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                shift1,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3512:1, end:3512:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar153 {
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mov_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3525:1, end:3525:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar154 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl mov_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3550:1, end:3550:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar155 {
    shift3: Tableshift3,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mov_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4189:1, end:4189:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar156 {
    SBIT_ZN: TableSBIT_ZN,
    rm: Tablerm,
    rs: Tablers,
    COND: TableCOND,
    rn: Tablern,
}
impl mul_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                rm,
                rs,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4229:1, end:4229:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar157 {
    SBIT_ZN: TableSBIT_ZN,
    shift1: Tableshift1,
    COND: TableCOND,
}
impl mvn_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                shift1,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4240:1, end:4240:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar158 {
    COND: TableCOND,
    shift2: Tableshift2,
    SBIT_ZN: TableSBIT_ZN,
}
impl mvn_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift2,
                SBIT_ZN,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4251:1, end:4251:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar159 {
    COND: TableCOND,
    shift3: Tableshift3,
    SBIT_ZN: TableSBIT_ZN,
}
impl mvn_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift3,
                SBIT_ZN,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5758:1, end:5758:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar160 {
    rn: Tablern,
    COND: TableCOND,
    shift1: Tableshift1,
}
impl teq_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, COND, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5769:1, end:5769:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar161 {
    rn: Tablern,
    shift2: Tableshift2,
    COND: TableCOND,
}
impl teq_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5780:1, end:5780:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar162 {
    COND: TableCOND,
    shift3: Tableshift3,
    rn: Tablern,
}
impl teq_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift3, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5791:1, end:5791:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar163 {
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
}
impl teq_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("p"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift1, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5802:1, end:5802:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar164 {
    rn: Tablern,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl teq_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("p"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, COND, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5813:1, end:5813:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar165 {
    COND: TableCOND,
    shift3: Tableshift3,
    rn: Tablern,
}
impl teq_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("p"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift3, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5825:1, end:5825:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar166 {
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl tst_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5836:1, end:5836:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar167 {
    rn: Tablern,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl tst_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, COND, shift2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5847:1, end:5847:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar168 {
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
}
impl tst_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift3, COND, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1945:1, end:1945:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar169 {
    rn: Tablern,
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl adc_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift1,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1958:1, end:1958:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar170 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl adc_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar171 {
    COND: TableCOND,
    shift3: Tableshift3,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl adc_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift3,
                rn,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3305:1, end:3305:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar172 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3315:1, end:3315:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar173 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3325:1, end:3325:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar174 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar175 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3345:1, end:3345:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar176 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3355:1, end:3355:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar177 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3365:1, end:3365:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar178 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3375:1, end:3375:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar179 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4017:1, end:4017:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar180 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4028:1, end:4028:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar181 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4039:1, end:4039:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar182 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4050:1, end:4050:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar183 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4061:1, end:4061:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar184 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4072:1, end:4072:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar185 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4083:1, end:4083:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar186 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4094:1, end:4094:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar187 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3385:1, end:3385:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar188 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRm = token_11(tokens_current);
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4105:1, end:4105:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar189 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        let CRm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2000:1, end:2000:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar190 {
    Rd: u8,
    ArmPCRelImmed12: TableArmPCRelImmed12,
    COND: TableCOND,
}
impl adr_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c73 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_45(tokens_param) == 8 {
                    return Some(((), (), 4));
                }
                if token_45(tokens_param) == 4 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c73(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ArmPCRelImmed12,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2048:1, end:2048:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar191 {
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
    shift1: Tableshift1,
}
impl add_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2061:1, end:2061:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar192 {
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl add_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                SBIT_CZNO,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2074:1, end:2074:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar193 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
    rn: Tablern,
    COND: TableCOND,
}
impl add_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift3,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2120:1, end:2120:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar194 {
    COND: TableCOND,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl and_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift1,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2133:1, end:2133:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar195 {
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl and_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2146:1, end:2146:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar196 {
    shift3: Tableshift3,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl and_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                rn,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2229:1, end:2229:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar197 {
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
    shift1: Tableshift1,
}
impl bic_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2242:1, end:2242:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar198 {
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl bic_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2255:1, end:2255:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar199 {
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
}
impl bic_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                SBIT_CZNO,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2644:1, end:2644:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar200 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    COND: TableCOND,
    rn: Tablern,
}
impl eor_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2657:1, end:2657:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar201 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl eor_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar202 {
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
    COND: TableCOND,
}
impl eor_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                SBIT_CZNO,
                shift3,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5134:1, end:5134:2))"]
#[derive(Clone, Debug)]
struct smlaw_instructionVar203 {
    smRd: u8,
    smRn: u8,
    smRm: u8,
    smRa: u8,
    COND: TableCOND,
    YBIT: TableYBIT,
}
impl smlaw_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlaw"));
        self.YBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.smRd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRa),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRm = token_14(tokens_current);
        let smRd = token_10(tokens_current);
        let smRa = token_13(tokens_current);
        let smRn = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                YBIT,
                smRd,
                smRn,
                smRm,
                smRa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5027:1, end:5027:2))"]
#[derive(Clone, Debug)]
struct smla_instructionVar204 {
    smRd: u8,
    smRn: u8,
    smRm: u8,
    smRa: u8,
    COND: TableCOND,
    XBIT: TableXBIT,
    YBIT: TableYBIT,
}
impl smla_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smla"));
        self.XBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.YBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.smRd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRa),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let XBIT = if let Some((len, table)) =
            TableXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRn = token_11(tokens_current);
        let smRm = token_14(tokens_current);
        let smRa = token_13(tokens_current);
        let smRd = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                XBIT,
                YBIT,
                smRd,
                smRn,
                smRm,
                smRa,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5088:1, end:5088:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar205 {
    RdLo: u8,
    RdHi: u8,
    smRn: u8,
    smRm: u8,
    XBIT: TableXBIT,
    COND: TableCOND,
    YBIT: TableYBIT,
}
impl smlal_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlal"));
        self.XBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.YBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.RdLo),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.RdHi),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let XBIT = if let Some((len, table)) =
            TableXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let YBIT = if let Some((len, table)) =
            TableYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRm = token_14(tokens_current);
        let RdLo = token_13(tokens_current);
        let smRn = token_11(tokens_current);
        let RdHi = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                XBIT,
                COND,
                YBIT,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3438:1, end:3438:2))"]
#[derive(Clone, Debug)]
struct mcrr_instructionVar206 {
    cpn: u8,
    opcode3: u8,
    Rd: u8,
    Rn: u8,
    CRm: u8,
    COND: TableCOND,
}
impl mcrr_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcrr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode3 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opcode3 = token_19(tokens_current);
        let Rd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        let CRm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opcode3,
                Rd,
                Rn,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3446:1, end:3446:2))"]
#[derive(Clone, Debug)]
struct mrrc_instructionVar207 {
    cpn: u8,
    opcode3: u8,
    Rd: u8,
    Rn: u8,
    CRm: u8,
    COND: TableCOND,
}
impl mrrc_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode3 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opcode3 = token_19(tokens_current);
        let cpn = token_14(tokens_current);
        let Rd = token_13(tokens_current);
        let Rn = token_10(tokens_current);
        let CRm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opcode3,
                Rd,
                Rn,
                CRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3457:1, end:3457:2))"]
#[derive(Clone, Debug)]
struct mla_instructionVar208 {
    Rn: u8,
    Rm: u8,
    Rs: u8,
    Rd: u8,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl mla_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mla"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rs),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rs = token_14(tokens_current);
        let Rm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                Rn,
                Rm,
                Rs,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3474:1, end:3474:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar209 {
    Rd: u8,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl mov_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3484:1, end:3484:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar210 {
    Rd: u8,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl mov_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3502:1, end:3502:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar211 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mov_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4199:1, end:4199:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar212 {
    Rd: u8,
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mvn_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4209:1, end:4209:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar213 {
    Rd: u8,
    shift2: Tableshift2,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mvn_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4219:1, end:4219:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar214 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl mvn_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4302:1, end:4302:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar215 {
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl orr_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4315:1, end:4315:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar216 {
    shift2: Tableshift2,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl orr_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                rn,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4328:1, end:4328:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar217 {
    rn: Tablern,
    shift3: Tableshift3,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl orr_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift3,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4644:1, end:4644:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar218 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsb_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4657:1, end:4657:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar219 {
    shift2: Tableshift2,
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsb_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                COND,
                rn,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4670:1, end:4670:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar220 {
    rn: Tablern,
    COND: TableCOND,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsb_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                shift3,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4716:1, end:4716:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar221 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsc_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4729:1, end:4729:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar222 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
    rn: Tablern,
    COND: TableCOND,
}
impl rsc_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift2,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4742:1, end:4742:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar223 {
    rn: Tablern,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl rsc_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift3,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4848:1, end:4848:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar224 {
    rn: Tablern,
    COND: TableCOND,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl sbc_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                shift1,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4861:1, end:4861:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar225 {
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl sbc_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4874:1, end:4874:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar226 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
}
impl sbc_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift3,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5073:1, end:5073:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar227 {
    RdLo: u8,
    RdHi: u8,
    smRn: u8,
    smRm: u8,
    SBIT_ZN: TableSBIT_ZN,
    COND: TableCOND,
}
impl smlal_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlal"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.RdLo),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.RdHi),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRn = token_11(tokens_current);
        let RdHi = token_10(tokens_current);
        let RdLo = token_13(tokens_current);
        let smRm = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                COND,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5294:1, end:5294:2))"]
#[derive(Clone, Debug)]
struct smull_instructionVar228 {
    RdLo: u8,
    RdHi: u8,
    smRn: u8,
    smRm: u8,
    SBIT_ZN: TableSBIT_ZN,
    COND: TableCOND,
}
impl smull_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smull"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.RdLo),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.RdHi),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RdLo = token_13(tokens_current);
        let smRm = token_14(tokens_current);
        let RdHi = token_10(tokens_current);
        let smRn = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                COND,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5609:1, end:5609:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar229 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    COND: TableCOND,
    rn: Tablern,
}
impl sub_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5638:1, end:5638:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar230 {
    shift2: Tableshift2,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl sub_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                COND,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5653:1, end:5653:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar231 {
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
}
impl sub_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                SBIT_CZNO,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6080:1, end:6080:2))"]
#[derive(Clone, Debug)]
struct umlal_instructionVar232 {
    Rd: u8,
    Rn: u8,
    COND: TableCOND,
    rs: Tablers,
    rm: Tablerm,
    SBIT_ZN: TableSBIT_ZN,
}
impl umlal_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("umlal"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rs,
                rm,
                SBIT_ZN,
                Rd,
                Rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6095:1, end:6095:2))"]
#[derive(Clone, Debug)]
struct umull_instructionVar233 {
    Rd: u8,
    Rn: u8,
    rm: Tablerm,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    rs: Tablers,
}
impl umull_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("umull"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rm,
                COND,
                SBIT_ZN,
                rs,
                Rd,
                Rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1912:1, end:1912:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar234 {
    Rd: u8,
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl adc_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift1,
                rn,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1923:1, end:1923:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar235 {
    Rd: u8,
    rn: Tablern,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl adc_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift2,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1934:1, end:1934:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar236 {
    Rd: u8,
    rn: Tablern,
    shift3: Tableshift3,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl adc_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift3,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2015:1, end:2015:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar237 {
    Rd: u8,
    COND: TableCOND,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl add_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift1,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2026:1, end:2026:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar238 {
    Rd: u8,
    shift2: Tableshift2,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl add_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                rn,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2037:1, end:2037:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar239 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
}
impl add_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift3,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2087:1, end:2087:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar240 {
    Rd: u8,
    rn: Tablern,
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl and_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift1,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2098:1, end:2098:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar241 {
    Rd: u8,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
}
impl and_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2109:1, end:2109:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar242 {
    Rd: u8,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
    COND: TableCOND,
}
impl and_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                SBIT_CZNO,
                shift3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2310:1, end:2310:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar243 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let HAddr24 = if let Some((len, table)) =
            TableHAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2318:1, end:2318:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar244 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let HAddr24 = if let Some((len, table)) =
            TableHAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2326:1, end:2326:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar245 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let HAddr24 = if let Some((len, table)) =
            TableHAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2334:1, end:2334:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar246 {
    HAddr24: TableHAddr24,
}
impl blx_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.HAddr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let HAddr24 = if let Some((len, table)) =
            TableHAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { HAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2923:1, end:2923:2))"]
#[derive(Clone, Debug)]
struct mcr2_instructionVar247 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
}
impl mcr2_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr2"));
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rd = token_13(tokens_current);
        let opc1 = token_16(tokens_current);
        let cpn = token_14(tokens_current);
        let opc2 = token_18(tokens_current);
        let CRn = token_10(tokens_current);
        let CRm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3595:1, end:3595:2))"]
#[derive(Clone, Debug)]
struct mrc2_instructionVar248 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
}
impl mrc2_instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc2"));
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cpn = token_14(tokens_current);
        let CRm = token_11(tokens_current);
        let opc2 = token_18(tokens_current);
        let CRn = token_10(tokens_current);
        let opc1 = token_16(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2454:1, end:2454:2))"]
#[derive(Clone, Debug)]
struct cdp2_instructionVar249 {
    cpn: u8,
    opcode1: u8,
    CRd: u8,
    CRn: u8,
    CRm: u8,
    opcode2: u8,
}
impl cdp2_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cdp2"));
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode1 as u64),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cpn = token_14(tokens_current);
        let opcode2 = token_18(tokens_current);
        let CRn = token_10(tokens_current);
        let CRm = token_11(tokens_current);
        let CRd = token_13(tokens_current);
        let opcode1 = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                cpn,
                opcode1,
                CRd,
                CRn,
                CRm,
                opcode2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3169:1, end:3169:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar250 {
    ItCond: TableItCond,
    thldrlist_inc: Tablethldrlist_inc,
}
impl pop_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pop"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.thldrlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thldrlist_inc = if let Some((len, table)) =
            Tablethldrlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thldrlist_inc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1461:1, end:1461:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar251 {
    ItCond: TableItCond,
}
impl bl_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1479:1, end:1479:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar252 {
    ItCond: TableItCond,
}
impl blx_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2610:1, end:2610:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar253 {
    Hrm0305: TableHrm0305,
    ItCond: TableItCond,
    Hrd0002: TableHrd0002,
}
impl mov_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) =
            TableHrd0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Hrm0305,
                ItCond,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3026:1, end:3026:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar254 {
    ItCond: TableItCond,
}
impl nop_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3160:1, end:3160:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar255 {
    ItCond: TableItCond,
    thldrlist_inc: Tablethldrlist_inc,
}
impl pop_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pop"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.thldrlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thldrlist_inc = if let Some((len, table)) =
            Tablethldrlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thldrlist_inc,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3251:1, end:3251:2))"]
#[derive(Clone, Debug)]
struct push_instructionVar256 {
    ItCond: TableItCond,
    thstrlist_dec: Tablethstrlist_dec,
}
impl push_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("push"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.thstrlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thstrlist_dec = if let Some((len, table)) =
            Tablethstrlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thstrlist_dec,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1539:1, end:1539:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar257 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl bx_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bx"));
        self.bxns
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3873:1, end:3873:2))"]
#[derive(Clone, Debug)]
struct smlad_instructionVar258 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
    thdXtop: TablethdXtop,
    thdXbot: TablethdXbot,
}
impl smlad_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlad"));
        self.thdXbot
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thdXbot = if let Some((len, table)) =
            TablethdXbot::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) =
            TablethdXtop::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXtop,
                thdXbot,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3886:1, end:3886:2))"]
#[derive(Clone, Debug)]
struct smlald_instructionVar259 {
    Rt1215: u8,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
    thdXtop: TablethdXtop,
    thdXbot: TablethdXbot,
}
impl smlald_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlald"));
        self.thdXbot
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thdXbot = if let Some((len, table)) =
            TablethdXbot::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) =
            TablethdXtop::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0003 = token_138(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rt1215 = token_131(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXtop,
                thdXbot,
                Rt1215,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3920:1, end:3920:2))"]
#[derive(Clone, Debug)]
struct smlaw_instructionVar260 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
    thYBIT: TablethYBIT,
}
impl smlaw_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlaw"));
        self.thYBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thYBIT = if let Some((len, table)) =
            TablethYBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thYBIT,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3930:1, end:3930:2))"]
#[derive(Clone, Debug)]
struct smlsd_instructionVar261 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Ra1215: u8,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smlsd_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlsd"));
        self.thdXbot
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Ra1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thdXbot = if let Some((len, table)) =
            TablethdXbot::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) =
            TablethdXtop::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Ra1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rd0811,
                Rn0003,
                Rm0003,
                Ra1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3943:1, end:3943:2))"]
#[derive(Clone, Debug)]
struct smlsld_instructionVar262 {
    Rt1215: u8,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
    thdXbot: TablethdXbot,
    thdXtop: TablethdXtop,
}
impl smlsld_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlsld"));
        self.thdXbot
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thdXbot = if let Some((len, table)) =
            TablethdXbot::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thdXtop = if let Some((len, table)) =
            TablethdXtop::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rt1215 = token_131(tokens_current);
        let Rd0811 = token_152(tokens_current);
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thdXbot,
                thdXtop,
                Rt1215,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3859:1, end:3859:2))"]
#[derive(Clone, Debug)]
struct smla_instructionVar263 {
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    Rt1215: u8,
    thYBIT: TablethYBIT,
    thXBIT: TablethXBIT,
    ItCond: TableItCond,
}
impl smla_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smla"));
        self.thXBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.thYBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rt1215),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c81 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_139(tokens) != 4017 {
                return None;
            }
            let Rn0003 = token_138(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_160(tokens) != 0 {
                return None;
            }
            let thYBIT = if let Some((len, table)) =
                TablethYBIT::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            let Rd0811 = token_152(tokens);
            let Rm0003 = token_138(tokens);
            let Rt1215 = token_131(tokens);
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((thYBIT), (Rn0003, Rd0811, Rm0003, Rt1215), pattern_len))
        };
        let ((mut thYBIT), (Rn0003, Rd0811, Rm0003, Rt1215), sub_len) =
            sub_pattern_c81(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let thXBIT = if let Some((len, table)) =
            TablethXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                thYBIT,
                thXBIT,
                ItCond,
                Rd0811,
                Rn0003,
                Rm0003,
                Rt1215,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3910:1, end:3910:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar264 {
    Rt1215: u8,
    Rd0811: u8,
    Rn0003: u8,
    Rm0003: u8,
    ItCond: TableItCond,
    thXBIT: TablethXBIT,
    thYBIT: TablethYBIT,
}
impl smlal_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlal"));
        self.thXBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.thYBIT
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rd0811),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rm0003),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c82 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_139(tokens) != 4028 {
                return None;
            }
            let Rn0003 = token_138(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_160(tokens) != 2 {
                return None;
            }
            let thYBIT = if let Some((len, table)) =
                TablethYBIT::parse(tokens, &mut context_instance, inst_start)
            {
                block_1_len = block_1_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            let Rd0811 = token_152(tokens);
            let Rt1215 = token_131(tokens);
            let Rm0003 = token_138(tokens);
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((thYBIT), (Rn0003, Rd0811, Rt1215, Rm0003), pattern_len))
        };
        let ((mut thYBIT), (Rn0003, Rd0811, Rt1215, Rm0003), sub_len) =
            sub_pattern_c82(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let thXBIT = if let Some((len, table)) =
            TablethXBIT::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thXBIT,
                thYBIT,
                Rt1215,
                Rd0811,
                Rn0003,
                Rm0003,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2563:1, end:2563:2))"]
#[derive(Clone, Debug)]
struct mcrr_instructionVar265 {
    thcpn: u8,
    thopcode1: u8,
    Rt1215: u8,
    Rn0003: u8,
    thCRm: u8,
    ItCond: TableItCond,
}
impl mcrr_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcrr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_11_display(self.thcpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.thopcode1 as u64),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.thCRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thcpn = token_152(tokens_current);
        let thCRm = token_138(tokens_current);
        let Rt1215 = token_131(tokens_current);
        let thopcode1 = token_144(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thcpn,
                thopcode1,
                Rt1215,
                Rn0003,
                thCRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2571:1, end:2571:2))"]
#[derive(Clone, Debug)]
struct mcrr_instructionVar266 {
    thcpn: u8,
    thopcode1: u8,
    Rt1215: u8,
    Rn0003: u8,
    thCRm: u8,
    ItCond: TableItCond,
}
impl mcrr_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcrr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_11_display(self.thcpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.thopcode1 as u64),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rn0003),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.thCRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let Rt1215 = token_131(tokens_current);
        let thcpn = token_152(tokens_current);
        let thopcode1 = token_144(tokens_current);
        let thCRm = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thcpn,
                thopcode1,
                Rt1215,
                Rn0003,
                thCRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1030:1, end:1030:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar267 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl adc_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZNO,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2618:1, end:2618:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar268 {
    Hrm0305: TableHrm0305,
    Hrd0002: TableHrd0002,
    ItCond: TableItCond,
}
impl mov_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_TMode(
                u8::try_from(i128::try_from(context.read_TMode()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mov"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_LRset(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_TMode(u8::try_from(1i128 & 1).unwrap());
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) =
            TableHrd0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Hrm0305,
                Hrd0002,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1158:1, end:1158:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar269 {
    ItCond: TableItCond,
    Hrd0002: TableHrd0002,
    Hrm0305: TableHrm0305,
}
impl add_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) =
            TableHrd0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrd0002,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1214:1, end:1214:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar270 {
    Rd0002: u8,
    Rm0305: u8,
    CheckInIT_ZN: TableCheckInIT_ZN,
    ItCond: TableItCond,
}
impl and_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1249:1, end:1249:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar271 {
    Rd0002: u8,
    Rm0305: u8,
    CheckInIT_CZN: TableCheckInIT_CZN,
    ItCond: TableItCond,
    Immed5: TableImmed5,
}
impl asr_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
            <DisplayElement>::Literal(",#0x20"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) =
            TableImmed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_CZN,
                ItCond,
                Immed5,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1267:1, end:1267:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar272 {
    Rd0002: u8,
    Rs0305: u8,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl asr_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rs0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rs0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1357:1, end:1357:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar273 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl bic_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1392:1, end:1392:2))"]
#[derive(Clone, Debug)]
struct hlt_instructionVar274 {
    immed6: u8,
}
impl hlt_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("hlt"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed6 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let immed6 = token_123(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1553:1, end:1553:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar275 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl bx_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        global_set.set(Some(inst_next), |context| {
            context.write_TMode(
                u8::try_from(i128::try_from(context.read_TMode()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bx"));
        self.bxns
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_LRset(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_TMode(u8::try_from(1i128 & 1).unwrap());
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1654:1, end:1654:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar276 {
    Rn0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
}
impl cmn_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rn0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1694:1, end:1694:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar277 {
    Rn0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
}
impl cmp_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rn0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rn0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1848:1, end:1848:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar278 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl eor_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2457:1, end:2457:2))"]
#[derive(Clone, Debug)]
struct lsl_instructionVar279 {
    Rd0002: u8,
    Rs0305: u8,
    CheckInIT_CZN: TableCheckInIT_CZN,
    ItCond: TableItCond,
}
impl lsl_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsl"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rs0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rs0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_CZN,
                ItCond,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2473:1, end:2473:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar280 {
    Rd0002: u8,
    Rm0305: u8,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
    ItCond: TableItCond,
}
impl lsr_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
            <DisplayElement>::Literal(",#0x20"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) =
            TableImmed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Immed5,
                CheckInIT_CZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2492:1, end:2492:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar281 {
    Rd0002: u8,
    Rs0305: u8,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsr_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rs0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rs0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2588:1, end:2588:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar282 {
    Rd0002: u8,
    Rn0305: u8,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl mov_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rn0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rn0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2602:1, end:2602:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar283 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    Hrd0002: TableHrd0002,
}
impl mov_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) =
            TableHrd0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                Hrd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2988:1, end:2988:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar284 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl mul_instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3018:1, end:3018:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar285 {
    Rd0002: u8,
    Rm0305: u8,
    CheckInIT_ZN: TableCheckInIT_ZN,
    ItCond: TableItCond,
}
impl mvn_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_ZN,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3038:1, end:3038:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar286 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
}
impl orr_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3444:1, end:3444:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar287 {
    Rd0002: u8,
    Rm0305: u8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
    ItCond: TableItCond,
}
impl rsb_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_CZNO,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3631:1, end:3631:2))"]
#[derive(Clone, Debug)]
struct ror_instructionVar288 {
    Rd0002: u8,
    Rs0305: u8,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl ror_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ror"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rs0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rs0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Rd0002,
                Rs0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3731:1, end:3731:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar289 {
    Rd0002: u8,
    Rm0305: u8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
    ItCond: TableItCond,
}
impl sbc_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_CZNO,
                ItCond,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4831:1, end:4831:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar290 {
    Rn0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
}
impl tst_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rn0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Rn0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1172:1, end:1172:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar291 {
    Immed7_4: TableImmed7_4,
    ItCond: TableItCond,
}
impl add_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed7_4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed7_4 = if let Some((len, table)) =
            TableImmed7_4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Immed7_4, ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1528:1, end:1528:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar292 {
    bxns: Tablebxns,
    Hrm0305: TableHrm0305,
    ItCond: TableItCond,
}
impl blx_instructionVar292 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blx"));
        self.bxns
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bxns,
                Hrm0305,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1546:1, end:1546:2))"]
#[derive(Clone, Debug)]
struct bx_instructionVar293 {
    ItCond: TableItCond,
    Hrm0305: TableHrm0305,
    bxns: Tablebxns,
}
impl bx_instructionVar293 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bx"));
        self.bxns
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let bxns = if let Some((len, table)) =
            Tablebxns::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrm0305,
                bxns,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2545:1, end:2545:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar294 {
    thcpn: u8,
    thc0507: u8,
    Rt1215: u8,
    thCRn: u8,
    thCRm: u8,
    thopcode2: u8,
    ItCond: TableItCond,
}
impl mcr_instructionVar294 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_11_display(self.thcpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.thc0507 as u64),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.thCRn),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.thCRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.thopcode2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thc0507 = token_145(tokens_current);
        let thCRn = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thopcode2 = token_145(tokens_current);
        let Rt1215 = token_131(tokens_current);
        let thcpn = token_152(tokens_current);
        let thCRm = token_138(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thcpn,
                thc0507,
                Rt1215,
                thCRn,
                thCRm,
                thopcode2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2554:1, end:2554:2))"]
#[derive(Clone, Debug)]
struct mcr2_instructionVar295 {
    thcpn: u8,
    thc0507: u8,
    Rt1215: u8,
    thCRn: u8,
    thCRm: u8,
    thopcode2: u8,
    ItCond: TableItCond,
}
impl mcr2_instructionVar295 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr2"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_11_display(self.thcpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.thc0507 as u64),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.Rt1215),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.thCRn),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.thCRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.thopcode2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thc0507 = token_145(tokens_current);
        let thCRn = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let thcpn = token_152(tokens_current);
        let thCRm = token_138(tokens_current);
        let Rt1215 = token_131(tokens_current);
        let thopcode2 = token_145(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thcpn,
                thc0507,
                Rt1215,
                thCRn,
                thCRm,
                thopcode2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4565:1, end:4565:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar296 {
    ItCond: TableItCond,
    Immed7_4: TableImmed7_4,
}
impl sub_instructionVar296 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed7_4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed7_4 = if let Some((len, table)) =
            TableImmed7_4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, Immed7_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar297 {
    Addr24: TableAddr24,
}
impl b_instructionVar297 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2284:1, end:2284:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar298 {
    Addr24: TableAddr24,
}
impl bl_instructionVar298 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2290:1, end:2290:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar299 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar299 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2298:1, end:2298:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar300 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar300 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3395:1, end:3395:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar301 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar301 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        let opc1 = token_16(tokens_current);
        let CRm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4116:1, end:4116:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar302 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar302 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        let opc1 = token_16(tokens_current);
        let CRm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3407:1, end:3407:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar303 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
    COND: TableCOND,
}
impl mcr_instructionVar303 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let CRm = token_11(tokens_current);
        let cpn = token_14(tokens_current);
        let CRn = token_10(tokens_current);
        let opc1 = token_16(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4129:1, end:4129:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar304 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
    COND: TableCOND,
}
impl mrc_instructionVar304 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRm = token_11(tokens_current);
        let CRn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        let opc1 = token_16(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2464:1, end:2464:2))"]
#[derive(Clone, Debug)]
struct cdp_instructionVar305 {
    cpn: u8,
    opcode1: u8,
    CRd: u8,
    CRn: u8,
    CRm: u8,
    opcode2: u8,
    COND: TableCOND,
}
impl cdp_instructionVar305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cdp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode1 as u64),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opcode1 = token_17(tokens_current);
        let CRd = token_13(tokens_current);
        let opcode2 = token_18(tokens_current);
        let CRm = token_11(tokens_current);
        let cpn = token_14(tokens_current);
        let CRn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opcode1,
                CRd,
                CRn,
                CRm,
                opcode2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2771:1, end:2771:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar306 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar306 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(0i128 & 1).unwrap());
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c124 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c124 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c124(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c124(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2759:1, end:2759:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar307 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar307 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(0i128 & 1).unwrap());
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c116(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c116(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2793:1, end:2793:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar308 {
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldr_instructionVar308 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c114 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c114 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c114(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c114(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2784:1, end:2784:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar309 {
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldr_instructionVar309 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2809:1, end:2809:2))"]
#[derive(Clone, Debug)]
struct ldrbt_instructionVar310 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrbt_instructionVar310 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrbt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2913:1, end:2913:2))"]
#[derive(Clone, Debug)]
struct ldrt_instructionVar311 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrt_instructionVar311 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5469:1, end:5469:2))"]
#[derive(Clone, Debug)]
struct strbt_instructionVar312 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strbt_instructionVar312 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strbt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5569:1, end:5569:2))"]
#[derive(Clone, Debug)]
struct strt_instructionVar313 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl strt_instructionVar313 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5668:1, end:5668:2))"]
#[derive(Clone, Debug)]
struct swi_instructionVar314 {
    immed24: u32,
    COND: TableCOND,
}
impl swi_instructionVar314 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swi"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed24 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed24 = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, immed24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1152:1, end:1152:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar315 {
    Hrd0002: TableHrd0002,
    Hrm0305: TableHrm0305,
    ItCond: TableItCond,
}
impl add_instructionVar315 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) =
            TableHrd0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Hrd0002,
                Hrm0305,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1397:1, end:1397:2))"]
#[derive(Clone, Debug)]
struct bkpt_instructionVar316 {
    immed8: u8,
    ItCond: TableItCond,
}
impl bkpt_instructionVar316 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bkpt"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed8 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, immed8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1417:1, end:1417:2))"]
#[derive(Clone, Debug)]
struct udf_instructionVar317 {
    thc0007: u8,
    ItCond: TableItCond,
}
impl udf_instructionVar317 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("udf"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.thc0007 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thc0007 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, thc0007 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1703:1, end:1703:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar318 {
    Hrm0305: TableHrm0305,
    Hrn0002: TableHrn0002,
    ItCond: TableItCond,
}
impl cmp_instructionVar318 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrn0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrn0002 = if let Some((len, table)) =
            TableHrn0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Hrm0305,
                Hrn0002,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2596:1, end:2596:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar319 {
    ItCond: TableItCond,
    Hrd0002: TableHrd0002,
    Hrm0305: TableHrm0305,
}
impl mov_instructionVar319 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Hrd0002
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Hrm0305
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrm0305 = if let Some((len, table)) =
            TableHrm0305::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Hrd0002 = if let Some((len, table)) =
            TableHrd0002::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Hrd0002,
                Hrm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3140:1, end:3140:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar320 {
    ItCond: TableItCond,
    ldbrace: Tableldbrace,
}
impl pop_instructionVar320 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pop"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ldbrace
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldbrace = if let Some((len, table)) =
            Tableldbrace::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, ldbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3149:1, end:3149:2))"]
#[derive(Clone, Debug)]
struct pop_instructionVar321 {
    pclbrace: Tablepclbrace,
    ItCond: TableItCond,
}
impl pop_instructionVar321 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pop"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.pclbrace
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let pclbrace = if let Some((len, table)) =
            Tablepclbrace::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { pclbrace, ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3233:1, end:3233:2))"]
#[derive(Clone, Debug)]
struct push_instructionVar322 {
    ItCond: TableItCond,
    psbrace: Tablepsbrace,
}
impl push_instructionVar322 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("push"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.psbrace
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let psbrace = if let Some((len, table)) =
            Tablepsbrace::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, psbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3242:1, end:3242:2))"]
#[derive(Clone, Debug)]
struct push_instructionVar323 {
    ItCond: TableItCond,
    pcpbrace: Tablepcpbrace,
}
impl push_instructionVar323 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("push"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.pcpbrace
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let pcpbrace = if let Some((len, table)) =
            Tablepcpbrace::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, pcpbrace }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4646:1, end:4646:2))"]
#[derive(Clone, Debug)]
struct svc_instructionVar324 {
    immed8: u8,
    ItCond: TableItCond,
}
impl svc_instructionVar324 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("svc"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed8 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, immed8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2166:1, end:2166:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar325 {
    Addr24: TableAddr24,
    cc: Tablecc,
}
impl b_instructionVar325 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2196:1, end:2196:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar326 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl bic_instructionVar326 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2207:1, end:2207:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar327 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift2: Tableshift2,
    rn: Tablern,
}
impl bic_instructionVar327 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift2,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2218:1, end:2218:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar328 {
    Rd: u8,
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl bic_instructionVar328 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2611:1, end:2611:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar329 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    COND: TableCOND,
    rn: Tablern,
}
impl eor_instructionVar329 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2622:1, end:2622:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar330 {
    Rd: u8,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
}
impl eor_instructionVar330 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                rn,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2633:1, end:2633:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar331 {
    Rd: u8,
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl eor_instructionVar331 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2695:1, end:2695:2))"]
#[derive(Clone, Debug)]
struct ldc2_instructionVar332 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
}
impl ldc2_instructionVar332 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2701:1, end:2701:2))"]
#[derive(Clone, Debug)]
struct ldc2l_instructionVar333 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
}
impl ldc2l_instructionVar333 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc2l"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2710:1, end:2710:2))"]
#[derive(Clone, Debug)]
struct ldc_instructionVar334 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
    COND: TableCOND,
}
impl ldc_instructionVar334 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                COND,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2718:1, end:2718:2))"]
#[derive(Clone, Debug)]
struct ldcl_instructionVar335 {
    cpn: u8,
    CRd: u8,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldcl_instructionVar335 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldcl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2726:1, end:2726:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar336 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl ldm_instructionVar336 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldm"));
        self.mdir
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) =
            Tablereglist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2732:1, end:2732:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar337 {
    mdir: Tablemdir,
    COND: TableCOND,
    reglist: Tablereglist,
}
impl ldm_instructionVar337 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldm"));
        self.mdir
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) =
            Tablereglist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                mdir,
                COND,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2751:1, end:2751:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar338 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldr_instructionVar338 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2802:1, end:2802:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar339 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldrb_instructionVar339 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2818:1, end:2818:2))"]
#[derive(Clone, Debug)]
struct ldrd_instructionVar340 {
    Rd: u8,
    Rd2: u8,
    addrmode3: Tableaddrmode3,
    COND: TableCOND,
}
impl ldrd_instructionVar340 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrd"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_1_display(self.Rd2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd2 = token_13(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode3,
                COND,
                Rd,
                Rd2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2861:1, end:2861:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar341 {
    Rd: u8,
    addrmode3: Tableaddrmode3,
    COND: TableCOND,
}
impl ldrh_instructionVar341 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrh"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2878:1, end:2878:2))"]
#[derive(Clone, Debug)]
struct ldrsb_instructionVar342 {
    Rd: u8,
    addrmode3: Tableaddrmode3,
    COND: TableCOND,
}
impl ldrsb_instructionVar342 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2895:1, end:2895:2))"]
#[derive(Clone, Debug)]
struct ldrsh_instructionVar343 {
    Rd: u8,
    addrmode3: Tableaddrmode3,
    COND: TableCOND,
}
impl ldrsh_instructionVar343 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrsh"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4269:1, end:4269:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar344 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    rn: Tablern,
}
impl orr_instructionVar344 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4280:1, end:4280:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar345 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl orr_instructionVar345 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4291:1, end:4291:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar346 {
    Rd: u8,
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl orr_instructionVar346 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4611:1, end:4611:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar347 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl rsb_instructionVar347 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4622:1, end:4622:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar348 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl rsb_instructionVar348 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4633:1, end:4633:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar349 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsb_instructionVar349 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4683:1, end:4683:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar350 {
    Rd: u8,
    shift1: Tableshift1,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl rsc_instructionVar350 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                rn,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4694:1, end:4694:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar351 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
    COND: TableCOND,
}
impl rsc_instructionVar351 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                shift2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4705:1, end:4705:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar352 {
    Rd: u8,
    shift3: Tableshift3,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl rsc_instructionVar352 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4815:1, end:4815:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar353 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sbc_instructionVar353 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4826:1, end:4826:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar354 {
    Rd: u8,
    shift2: Tableshift2,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl sbc_instructionVar354 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                rn,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4837:1, end:4837:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar355 {
    Rd: u8,
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl sbc_instructionVar355 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                COND,
                rn,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5423:1, end:5423:2))"]
#[derive(Clone, Debug)]
struct stc_instructionVar356 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
    COND: TableCOND,
}
impl stc_instructionVar356 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                COND,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5431:1, end:5431:2))"]
#[derive(Clone, Debug)]
struct stcl_instructionVar357 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
    COND: TableCOND,
}
impl stcl_instructionVar357 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stcl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                COND,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5454:1, end:5454:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar358 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl str_instructionVar358 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("str"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5461:1, end:5461:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar359 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl strb_instructionVar359 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5477:1, end:5477:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar360 {
    Rd: u8,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl strh_instructionVar360 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strh"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5487:1, end:5487:2))"]
#[derive(Clone, Debug)]
struct strd_instructionVar361 {
    Rd: u8,
    Rd2: u8,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl strd_instructionVar361 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strd"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_1_display(self.Rd2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let Rd2 = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
                Rd2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5439:1, end:5439:2))"]
#[derive(Clone, Debug)]
struct stm_instructionVar362 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl stm_instructionVar362 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stm"));
        self.mdir
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) =
            Tablereglist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5576:1, end:5576:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar363 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl sub_instructionVar363 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5587:1, end:5587:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar364 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sub_instructionVar364 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5598:1, end:5598:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar365 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sub_instructionVar365 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1063:1, end:1063:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar366 {
    Rd0002: u8,
    Rn0305: u8,
    ItCond: TableItCond,
    Immed3: TableImmed3,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl add_instructionVar366 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed3 = if let Some((len, table)) =
            TableImmed3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed3,
                CheckInIT_CZNO,
                Rd0002,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1143:1, end:1143:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar367 {
    Rd0002: u8,
    Rn0305: u8,
    Rm0608: u8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
    ItCond: TableItCond,
}
impl add_instructionVar367 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0608),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0608 = token_147(tokens_current);
        let Rn0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_CZNO,
                ItCond,
                Rd0002,
                Rn0305,
                Rm0608,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1512:1, end:1512:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar368 {
    ThArmAddr23: TableThArmAddr23,
    ItCond: TableItCond,
}
impl blx_instructionVar368 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(None, |context| {
            context.write_TMode(
                u8::try_from(i128::try_from(context.read_TMode()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("blx"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThArmAddr23
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_TMode(u8::try_from(0i128 & 1).unwrap());
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c68 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_119(tokens) != 30 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_119(tokens) != 29 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c68(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThArmAddr23 = if let Some((len, table)) =
            TableThArmAddr23::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        context_instance.write_TMode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ThArmAddr23,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1490:1, end:1490:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar369 {
    ItCond: TableItCond,
    ThAddr24: TableThAddr24,
}
impl bl_instructionVar369 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThAddr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c64 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_119(tokens) != 30 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_128(tokens) != 3 {
                return None;
            }
            if token_129(tokens) != 1 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c64(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThAddr24 = if let Some((len, table)) =
            TableThAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, ThAddr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1503:1, end:1503:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar370 {
    ThArmAddr23: TableThArmAddr23,
    ItCond: TableItCond,
}
impl blx_instructionVar370 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(None, |context| {
            context.write_TMode(
                u8::try_from(i128::try_from(context.read_TMode()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("blx"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThArmAddr23
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_TMode(u8::try_from(0i128 & 1).unwrap());
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_119(tokens) != 30 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_119(tokens) != 29 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThArmAddr23 = if let Some((len, table)) =
            TableThArmAddr23::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        context_instance.write_TMode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ThArmAddr23,
                ItCond,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1436:1, end:1436:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar371 {
    ThAddr24: TableThAddr24,
    ItCond: TableItCond,
}
impl bl_instructionVar371 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThAddr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_119(tokens) != 30 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_128(tokens) != 3 {
                return None;
            }
            if token_129(tokens) != 1 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThAddr24 = if let Some((len, table)) =
            TableThAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ThAddr24, ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1470:1, end:1470:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar372 {
    offset11: u16,
    ItCond: TableItCond,
}
impl blx_instructionVar372 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = u32::try_from(1i128)
            .ok()
            .and_then(|shl| i128::try_from(self.offset11).unwrap().checked_shl(shl))
            .unwrap_or(0);
        display.push(DisplayElement::Literal("blx"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_off.is_negative(), calc_off.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 2;
        calc_off = u32::try_from(1i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_125(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset11 = token_125(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, offset11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1520:1, end:1520:2))"]
#[derive(Clone, Debug)]
struct blx_instructionVar373 {
    ItCond: TableItCond,
    ThArmAddr23: TableThArmAddr23,
}
impl blx_instructionVar373 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(None, |context| {
            context.write_TMode(
                u8::try_from(i128::try_from(context.read_TMode()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("blx"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ThArmAddr23
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_TMode(u8::try_from(0i128 & 1).unwrap());
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_119(tokens) != 30 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 2;
            if token_128(tokens) != 3 {
                return None;
            }
            if token_129(tokens) != 0 {
                return None;
            }
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ThArmAddr23 = if let Some((len, table)) =
            TableThArmAddr23::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        context_instance.write_TMode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                ThArmAddr23,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1576:1, end:1576:2))"]
#[derive(Clone, Debug)]
struct cbnz_instructionVar374 {
    Rn0002: u8,
    ItCond: TableItCond,
    Addr5: TableAddr5,
}
impl cbnz_instructionVar374 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cbnz"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rn0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Addr5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr5 = if let Some((len, table)) =
            TableAddr5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Addr5,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1583:1, end:1583:2))"]
#[derive(Clone, Debug)]
struct cbz_instructionVar375 {
    Rn0002: u8,
    ItCond: TableItCond,
    Addr5: TableAddr5,
}
impl cbz_instructionVar375 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cbz"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rn0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Addr5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr5 = if let Some((len, table)) =
            TableAddr5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Addr5,
                Rn0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2027:1, end:2027:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar376 {
    Rd0002: u8,
    RnRmIndirect: TableRnRmIndirect,
    ItCond: TableItCond,
}
impl ldr_instructionVar376 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2056:1, end:2056:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar377 {
    Rd0002: u8,
    RnRmIndirect: TableRnRmIndirect,
    ItCond: TableItCond,
}
impl ldrb_instructionVar377 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2070:1, end:2070:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar378 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrh_instructionVar378 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrh"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2077:1, end:2077:2))"]
#[derive(Clone, Debug)]
struct ldrsb_instructionVar379 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrsb_instructionVar379 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrsb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2084:1, end:2084:2))"]
#[derive(Clone, Debug)]
struct ldrsh_instructionVar380 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl ldrsh_instructionVar380 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrsh"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4341:1, end:4341:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar381 {
    Rd0002: u8,
    RnRmIndirect: TableRnRmIndirect,
    ItCond: TableItCond,
}
impl str_instructionVar381 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("str"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4361:1, end:4361:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar382 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnRmIndirect: TableRnRmIndirect,
}
impl strb_instructionVar382 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnRmIndirect,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4375:1, end:4375:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar383 {
    Rd0002: u8,
    RnRmIndirect: TableRnRmIndirect,
    ItCond: TableItCond,
}
impl strh_instructionVar383 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strh"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnRmIndirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnRmIndirect = if let Some((len, table)) =
            TableRnRmIndirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnRmIndirect,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4538:1, end:4538:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar384 {
    Rd0002: u8,
    Rn0305: u8,
    Immed3: TableImmed3,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl sub_instructionVar384 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed3 = if let Some((len, table)) =
            TableImmed3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rn0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Immed3,
                ItCond,
                CheckInIT_CZNO,
                Rd0002,
                Rn0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4556:1, end:4556:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar385 {
    Rd0002: u8,
    Rn0305: u8,
    Rm0608: u8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
    ItCond: TableItCond,
}
impl sub_instructionVar385 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0608),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0608 = token_147(tokens_current);
        let Rn0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CheckInIT_CZNO,
                ItCond,
                Rd0002,
                Rn0305,
                Rm0608,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1072:1, end:1072:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar386 {
    Rd0810: u8,
    Immed8: TableImmed8,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
    ItCond: TableItCond,
}
impl add_instructionVar386 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) =
            TableImmed8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Immed8,
                CheckInIT_CZNO,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1166:1, end:1166:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar387 {
    Rd0810: u8,
    Sprel8: TableSprel8,
    ItCond: TableItCond,
}
impl add_instructionVar387 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Sprel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Sprel8 = if let Some((len, table)) =
            TableSprel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Sprel8,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1178:1, end:1178:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar388 {
    Rd0810: u8,
    Pcrel8: TablePcrel8,
    ItCond: TableItCond,
}
impl adr_instructionVar388 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Pcrel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Pcrel8 = if let Some((len, table)) =
            TablePcrel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Pcrel8,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1258:1, end:1258:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar389 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
    Immed5: TableImmed5,
}
impl asr_instructionVar389 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) =
            TableImmed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_CZN,
                Immed5,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1317:1, end:1317:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar390 {
    Addr11: TableAddr11,
    ItCond: TableItCond,
}
impl b_instructionVar390 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr11 = if let Some((len, table)) =
            TableAddr11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr11, ItCond }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1446:1, end:1446:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar391 {
    soffset11: u16,
    ItCond: TableItCond,
}
impl bl_instructionVar391 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                u32::try_from(12i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(
                            (if self.soffset11 & 1024 != 0 {
                                -1 & !1023
                            } else {
                                0
                            } | self.soffset11 as i16),
                        )
                        .unwrap()
                        .checked_shl(shl)
                    })
                    .unwrap_or(0),
            );
        display.push(DisplayElement::Literal("bl"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_off.is_negative(), calc_off.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 2;
        calc_off = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                u32::try_from(12i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_125(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0),
            );
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let soffset11 = token_125(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, soffset11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1452:1, end:1452:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar392 {
    offset11: u16,
    ItCond: TableItCond,
}
impl bl_instructionVar392 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off: i128 = 0;
        calc_off = u32::try_from(1i128)
            .ok()
            .and_then(|shl| i128::try_from(self.offset11).unwrap().checked_shl(shl))
            .unwrap_or(0);
        display.push(DisplayElement::Literal("bl"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_off.is_negative(), calc_off.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off: i128 = 0;
        let mut block_0_len = 2;
        calc_off = u32::try_from(1i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_125(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset11 = token_125(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ItCond, offset11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1663:1, end:1663:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar393 {
    Rn0810: u8,
    ItCond: TableItCond,
    Immed8: TableImmed8,
}
impl cmp_instructionVar393 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rn0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) =
            TableImmed8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed8,
                Rn0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1939:1, end:1939:2))"]
#[derive(Clone, Debug)]
struct ldmia_instructionVar394 {
    Rn_exclaim: TableRn_exclaim,
    ItCond: TableItCond,
    ldbrace: Tableldbrace,
    Rn_exclaim_WB: TableRn_exclaim_WB,
}
impl ldmia_instructionVar394 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldmia"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rn_exclaim
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldbrace
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn_exclaim = if let Some((len, table)) =
            TableRn_exclaim::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldbrace = if let Some((len, table)) =
            Tableldbrace::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn_exclaim_WB = if let Some((len, table)) =
            TableRn_exclaim_WB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rn_exclaim,
                ItCond,
                ldbrace,
                Rn_exclaim_WB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2020:1, end:2020:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar395 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnIndirect4: TableRnIndirect4,
}
impl ldr_instructionVar395 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnIndirect4 = if let Some((len, table)) =
            TableRnIndirect4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect4,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2034:1, end:2034:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar396 {
    Rd0810: u8,
    Pcrel8Indirect: TablePcrel8Indirect,
    ItCond: TableItCond,
}
impl ldr_instructionVar396 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Pcrel8Indirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Pcrel8Indirect = if let Some((len, table)) =
            TablePcrel8Indirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Pcrel8Indirect,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2042:1, end:2042:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar397 {
    Rd0810: u8,
    Sprel8Indirect: TableSprel8Indirect,
    ItCond: TableItCond,
}
impl ldr_instructionVar397 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Sprel8Indirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Sprel8Indirect = if let Some((len, table)) =
            TableSprel8Indirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Sprel8Indirect,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2049:1, end:2049:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar398 {
    Rd0002: u8,
    RnIndirect1: TableRnIndirect1,
    ItCond: TableItCond,
}
impl ldrb_instructionVar398 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnIndirect1 = if let Some((len, table)) =
            TableRnIndirect1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnIndirect1,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2063:1, end:2063:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar399 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnIndirect2: TableRnIndirect2,
}
impl ldrh_instructionVar399 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrh"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnIndirect2 = if let Some((len, table)) =
            TableRnIndirect2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect2,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2448:1, end:2448:2))"]
#[derive(Clone, Debug)]
struct lsl_instructionVar400 {
    Rd0002: u8,
    Rm0305: u8,
    ItCond: TableItCond,
    Immed5: TableImmed5,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsl_instructionVar400 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsl"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) =
            TableImmed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rm0305 = token_153(tokens_current);
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                Immed5,
                CheckInIT_CZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2482:1, end:2482:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar401 {
    Rd0002: u8,
    Rm0305: u8,
    Immed5: TableImmed5,
    ItCond: TableItCond,
    CheckInIT_CZN: TableCheckInIT_CZN,
}
impl lsr_instructionVar401 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr"));
        self.CheckInIT_CZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0305),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed5 = if let Some((len, table)) =
            TableImmed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZN = if let Some((len, table)) =
            TableCheckInIT_CZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Immed5,
                ItCond,
                CheckInIT_CZN,
                Rd0002,
                Rm0305,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:2580:1, end:2580:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar402 {
    Rd0810: u8,
    ItCond: TableItCond,
    CheckInIT_ZN: TableCheckInIT_ZN,
    Immed8: TableImmed8,
}
impl mov_instructionVar402 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.CheckInIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) =
            TableImmed8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_ZN = if let Some((len, table)) =
            TableCheckInIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                CheckInIT_ZN,
                Immed8,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4327:1, end:4327:2))"]
#[derive(Clone, Debug)]
struct stmia_instructionVar403 {
    Rn_exclaim: TableRn_exclaim,
    Rn_exclaim_WB: TableRn_exclaim_WB,
    ItCond: TableItCond,
    stbrace: Tablestbrace,
}
impl stmia_instructionVar403 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stmia"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Rn_exclaim
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stbrace
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn_exclaim = if let Some((len, table)) =
            TableRn_exclaim::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stbrace = if let Some((len, table)) =
            Tablestbrace::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn_exclaim_WB = if let Some((len, table)) =
            TableRn_exclaim_WB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Rn_exclaim,
                Rn_exclaim_WB,
                ItCond,
                stbrace,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4335:1, end:4335:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar404 {
    Rd0002: u8,
    ItCond: TableItCond,
    RnIndirect4: TableRnIndirect4,
}
impl str_instructionVar404 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("str"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnIndirect4 = if let Some((len, table)) =
            TableRnIndirect4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                RnIndirect4,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4347:1, end:4347:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar405 {
    Rd0810: u8,
    Sprel8Indirect: TableSprel8Indirect,
    ItCond: TableItCond,
}
impl str_instructionVar405 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("str"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Sprel8Indirect
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Sprel8Indirect = if let Some((len, table)) =
            TableSprel8Indirect::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Sprel8Indirect,
                ItCond,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4354:1, end:4354:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar406 {
    Rd0002: u8,
    RnIndirect1: TableRnIndirect1,
    ItCond: TableItCond,
}
impl strb_instructionVar406 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strb"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnIndirect1 = if let Some((len, table)) =
            TableRnIndirect1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnIndirect1,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4368:1, end:4368:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar407 {
    Rd0002: u8,
    RnIndirect2: TableRnIndirect2,
    ItCond: TableItCond,
}
impl strh_instructionVar407 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strh"));
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0002),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RnIndirect2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RnIndirect2 = if let Some((len, table)) =
            TableRnIndirect2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RnIndirect2,
                ItCond,
                Rd0002,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:4547:1, end:4547:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar408 {
    Rd0810: u8,
    Immed8: TableImmed8,
    ItCond: TableItCond,
    CheckInIT_CZNO: TableCheckInIT_CZNO,
}
impl sub_instructionVar408 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.CheckInIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.ItCond
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.Rd0810),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.Immed8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Immed8 = if let Some((len, table)) =
            TableImmed8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CheckInIT_CZNO = if let Some((len, table)) =
            TableCheckInIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                Immed8,
                ItCond,
                CheckInIT_CZNO,
                Rd0810,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1312:1, end:1312:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar409 {
    ItCond: TableItCond,
    thcc: Tablethcc,
    Addr8: TableAddr8,
}
impl b_instructionVar409 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.thcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ItCond = if let Some((len, table)) =
            TableItCond::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let thcc = if let Some((len, table)) =
            Tablethcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c8 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_181(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_169(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_120(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c8(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let Addr8 = if let Some((len, table)) =
            TableAddr8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ItCond,
                thcc,
                Addr8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1526:1, end:1526:2))"]
#[derive(Clone, Debug)]
struct instructionVar410 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar410 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_ARMcondCk(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_ARMcond(u8::try_from(1i128 & 1).unwrap());
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_30(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_32(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_33(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3034:1, end:3034:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar411 {}
impl nop_instructionVar411 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct instructionVar412 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar412 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_ARMcondCk(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_ARMcond(u8::try_from(0i128 & 1).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(mov_instructionVar0),
    Var1(mov_instructionVar1),
    Var2(bl_instructionVar2),
    Var3(nop_instructionVar3),
    Var4(qadd_instructionVar4),
    Var5(qdadd_instructionVar5),
    Var6(qdsub_instructionVar6),
    Var7(qsub_instructionVar7),
    Var8(smmul_instructionVar8),
    Var9(smmulr_instructionVar9),
    Var10(smulbb_instructionVar10),
    Var11(smulbt_instructionVar11),
    Var12(smultb_instructionVar12),
    Var13(smultt_instructionVar13),
    Var14(hlt_instructionVar14),
    Var15(bkpt_instructionVar15),
    Var16(hvc_instructionVar16),
    Var17(udf_instructionVar17),
    Var18(bx_instructionVar18),
    Var19(bl_instructionVar19),
    Var20(blx_instructionVar20),
    Var21(bx_instructionVar21),
    Var22(bx_instructionVar22),
    Var23(bx_instructionVar23),
    Var24(mov_instructionVar24),
    Var25(blx_instructionVar25),
    Var26(mcr_instructionVar26),
    Var27(mcr_instructionVar27),
    Var28(mcr_instructionVar28),
    Var29(mcr_instructionVar29),
    Var30(mcr_instructionVar30),
    Var31(mcr_instructionVar31),
    Var32(mcr_instructionVar32),
    Var33(mcr_instructionVar33),
    Var34(mcr_instructionVar34),
    Var35(mcr_instructionVar35),
    Var36(mcr_instructionVar36),
    Var37(mcr_instructionVar37),
    Var38(mcr_instructionVar38),
    Var39(mcr_instructionVar39),
    Var40(mcr_instructionVar40),
    Var41(mcr_instructionVar41),
    Var42(mcr_instructionVar42),
    Var43(mcr_instructionVar43),
    Var44(mcr_instructionVar44),
    Var45(mcr_instructionVar45),
    Var46(mcr_instructionVar46),
    Var47(mcr_instructionVar47),
    Var48(mcr_instructionVar48),
    Var49(mcr_instructionVar49),
    Var50(mcr_instructionVar50),
    Var51(mcr_instructionVar51),
    Var52(mcr_instructionVar52),
    Var53(mcr_instructionVar53),
    Var54(mcr_instructionVar54),
    Var55(mcr_instructionVar55),
    Var56(mcr_instructionVar56),
    Var57(mcr_instructionVar57),
    Var58(mcr_instructionVar58),
    Var59(mcr_instructionVar59),
    Var60(mcr_instructionVar60),
    Var61(mcr_instructionVar61),
    Var62(mcr_instructionVar62),
    Var63(mcr_instructionVar63),
    Var64(mcr_instructionVar64),
    Var65(mcr_instructionVar65),
    Var66(mcr_instructionVar66),
    Var67(mrc_instructionVar67),
    Var68(mrc_instructionVar68),
    Var69(mrc_instructionVar69),
    Var70(mrc_instructionVar70),
    Var71(mrc_instructionVar71),
    Var72(mrc_instructionVar72),
    Var73(mrc_instructionVar73),
    Var74(mrc_instructionVar74),
    Var75(mrc_instructionVar75),
    Var76(mrc_instructionVar76),
    Var77(mrc_instructionVar77),
    Var78(mrc_instructionVar78),
    Var79(mrc_instructionVar79),
    Var80(mrc_instructionVar80),
    Var81(mrc_instructionVar81),
    Var82(mrc_instructionVar82),
    Var83(mrc_instructionVar83),
    Var84(mrc_instructionVar84),
    Var85(mrc_instructionVar85),
    Var86(mrc_instructionVar86),
    Var87(mrc_instructionVar87),
    Var88(mrc_instructionVar88),
    Var89(mrc_instructionVar89),
    Var90(mrc_instructionVar90),
    Var91(mrc_instructionVar91),
    Var92(mrc_instructionVar92),
    Var93(mrc_instructionVar93),
    Var94(mrc_instructionVar94),
    Var95(mrc_instructionVar95),
    Var96(mrc_instructionVar96),
    Var97(mrc_instructionVar97),
    Var98(mrc_instructionVar98),
    Var99(mrc_instructionVar99),
    Var100(mrc_instructionVar100),
    Var101(mrc_instructionVar101),
    Var102(mrc_instructionVar102),
    Var103(mrc_instructionVar103),
    Var104(mrc_instructionVar104),
    Var105(mrc_instructionVar105),
    Var106(mrc_instructionVar106),
    Var107(mrc_instructionVar107),
    Var108(mrs_instructionVar108),
    Var109(mrs_instructionVar109),
    Var110(clz_instructionVar110),
    Var111(msr_instructionVar111),
    Var112(msr_instructionVar112),
    Var113(qadd_instructionVar113),
    Var114(qdadd_instructionVar114),
    Var115(qdsub_instructionVar115),
    Var116(qsub_instructionVar116),
    Var117(swp_instructionVar117),
    Var118(swpb_instructionVar118),
    Var119(smlal_instructionVar119),
    Var120(smmla_instructionVar120),
    Var121(smmlar_instructionVar121),
    Var122(smmls_instructionVar122),
    Var123(smmlsr_instructionVar123),
    Var124(smull_instructionVar124),
    Var125(smc_instructionVar125),
    Var126(srsdb_instructionVar126),
    Var127(srsdb_instructionVar127),
    Var128(srsib_instructionVar128),
    Var129(srsia_instructionVar129),
    Var130(pld_instructionVar130),
    Var131(smuad_instructionVar131),
    Var132(smusd_instructionVar132),
    Var133(smulw_instructionVar133),
    Var134(hvc_instructionVar134),
    Var135(smc_instructionVar135),
    Var136(udf_instructionVar136),
    Var137(pld_instructionVar137),
    Var138(stc2_instructionVar138),
    Var139(stc2l_instructionVar139),
    Var140(adr_instructionVar140),
    Var141(smulw_instructionVar141),
    Var142(smul_instructionVar142),
    Var143(msr_instructionVar143),
    Var144(msr_instructionVar144),
    Var145(cmn_instructionVar145),
    Var146(cmn_instructionVar146),
    Var147(cmn_instructionVar147),
    Var148(cmp_instructionVar148),
    Var149(cmp_instructionVar149),
    Var150(cmp_instructionVar150),
    Var151(mov_instructionVar151),
    Var152(sub_instructionVar152),
    Var153(mov_instructionVar153),
    Var154(mov_instructionVar154),
    Var155(mov_instructionVar155),
    Var156(mul_instructionVar156),
    Var157(mvn_instructionVar157),
    Var158(mvn_instructionVar158),
    Var159(mvn_instructionVar159),
    Var160(teq_instructionVar160),
    Var161(teq_instructionVar161),
    Var162(teq_instructionVar162),
    Var163(teq_instructionVar163),
    Var164(teq_instructionVar164),
    Var165(teq_instructionVar165),
    Var166(tst_instructionVar166),
    Var167(tst_instructionVar167),
    Var168(tst_instructionVar168),
    Var169(adc_instructionVar169),
    Var170(adc_instructionVar170),
    Var171(adc_instructionVar171),
    Var172(mcr_instructionVar172),
    Var173(mcr_instructionVar173),
    Var174(mcr_instructionVar174),
    Var175(mcr_instructionVar175),
    Var176(mcr_instructionVar176),
    Var177(mcr_instructionVar177),
    Var178(mcr_instructionVar178),
    Var179(mcr_instructionVar179),
    Var180(mrc_instructionVar180),
    Var181(mrc_instructionVar181),
    Var182(mrc_instructionVar182),
    Var183(mrc_instructionVar183),
    Var184(mrc_instructionVar184),
    Var185(mrc_instructionVar185),
    Var186(mrc_instructionVar186),
    Var187(mrc_instructionVar187),
    Var188(mcr_instructionVar188),
    Var189(mrc_instructionVar189),
    Var190(adr_instructionVar190),
    Var191(add_instructionVar191),
    Var192(add_instructionVar192),
    Var193(add_instructionVar193),
    Var194(and_instructionVar194),
    Var195(and_instructionVar195),
    Var196(and_instructionVar196),
    Var197(bic_instructionVar197),
    Var198(bic_instructionVar198),
    Var199(bic_instructionVar199),
    Var200(eor_instructionVar200),
    Var201(eor_instructionVar201),
    Var202(eor_instructionVar202),
    Var203(smlaw_instructionVar203),
    Var204(smla_instructionVar204),
    Var205(smlal_instructionVar205),
    Var206(mcrr_instructionVar206),
    Var207(mrrc_instructionVar207),
    Var208(mla_instructionVar208),
    Var209(mov_instructionVar209),
    Var210(mov_instructionVar210),
    Var211(mov_instructionVar211),
    Var212(mvn_instructionVar212),
    Var213(mvn_instructionVar213),
    Var214(mvn_instructionVar214),
    Var215(orr_instructionVar215),
    Var216(orr_instructionVar216),
    Var217(orr_instructionVar217),
    Var218(rsb_instructionVar218),
    Var219(rsb_instructionVar219),
    Var220(rsb_instructionVar220),
    Var221(rsc_instructionVar221),
    Var222(rsc_instructionVar222),
    Var223(rsc_instructionVar223),
    Var224(sbc_instructionVar224),
    Var225(sbc_instructionVar225),
    Var226(sbc_instructionVar226),
    Var227(smlal_instructionVar227),
    Var228(smull_instructionVar228),
    Var229(sub_instructionVar229),
    Var230(sub_instructionVar230),
    Var231(sub_instructionVar231),
    Var232(umlal_instructionVar232),
    Var233(umull_instructionVar233),
    Var234(adc_instructionVar234),
    Var235(adc_instructionVar235),
    Var236(adc_instructionVar236),
    Var237(add_instructionVar237),
    Var238(add_instructionVar238),
    Var239(add_instructionVar239),
    Var240(and_instructionVar240),
    Var241(and_instructionVar241),
    Var242(and_instructionVar242),
    Var243(blx_instructionVar243),
    Var244(blx_instructionVar244),
    Var245(blx_instructionVar245),
    Var246(blx_instructionVar246),
    Var247(mcr2_instructionVar247),
    Var248(mrc2_instructionVar248),
    Var249(cdp2_instructionVar249),
    Var250(pop_instructionVar250),
    Var251(bl_instructionVar251),
    Var252(blx_instructionVar252),
    Var253(mov_instructionVar253),
    Var254(nop_instructionVar254),
    Var255(pop_instructionVar255),
    Var256(push_instructionVar256),
    Var257(bx_instructionVar257),
    Var258(smlad_instructionVar258),
    Var259(smlald_instructionVar259),
    Var260(smlaw_instructionVar260),
    Var261(smlsd_instructionVar261),
    Var262(smlsld_instructionVar262),
    Var263(smla_instructionVar263),
    Var264(smlal_instructionVar264),
    Var265(mcrr_instructionVar265),
    Var266(mcrr_instructionVar266),
    Var267(adc_instructionVar267),
    Var268(mov_instructionVar268),
    Var269(add_instructionVar269),
    Var270(and_instructionVar270),
    Var271(asr_instructionVar271),
    Var272(asr_instructionVar272),
    Var273(bic_instructionVar273),
    Var274(hlt_instructionVar274),
    Var275(bx_instructionVar275),
    Var276(cmn_instructionVar276),
    Var277(cmp_instructionVar277),
    Var278(eor_instructionVar278),
    Var279(lsl_instructionVar279),
    Var280(lsr_instructionVar280),
    Var281(lsr_instructionVar281),
    Var282(mov_instructionVar282),
    Var283(mov_instructionVar283),
    Var284(mul_instructionVar284),
    Var285(mvn_instructionVar285),
    Var286(orr_instructionVar286),
    Var287(rsb_instructionVar287),
    Var288(ror_instructionVar288),
    Var289(sbc_instructionVar289),
    Var290(tst_instructionVar290),
    Var291(add_instructionVar291),
    Var292(blx_instructionVar292),
    Var293(bx_instructionVar293),
    Var294(mcr_instructionVar294),
    Var295(mcr2_instructionVar295),
    Var296(sub_instructionVar296),
    Var297(b_instructionVar297),
    Var298(bl_instructionVar298),
    Var299(bl_instructionVar299),
    Var300(bl_instructionVar300),
    Var301(mcr_instructionVar301),
    Var302(mrc_instructionVar302),
    Var303(mcr_instructionVar303),
    Var304(mrc_instructionVar304),
    Var305(cdp_instructionVar305),
    Var306(ldr_instructionVar306),
    Var307(ldr_instructionVar307),
    Var308(ldr_instructionVar308),
    Var309(ldr_instructionVar309),
    Var310(ldrbt_instructionVar310),
    Var311(ldrt_instructionVar311),
    Var312(strbt_instructionVar312),
    Var313(strt_instructionVar313),
    Var314(swi_instructionVar314),
    Var315(add_instructionVar315),
    Var316(bkpt_instructionVar316),
    Var317(udf_instructionVar317),
    Var318(cmp_instructionVar318),
    Var319(mov_instructionVar319),
    Var320(pop_instructionVar320),
    Var321(pop_instructionVar321),
    Var322(push_instructionVar322),
    Var323(push_instructionVar323),
    Var324(svc_instructionVar324),
    Var325(b_instructionVar325),
    Var326(bic_instructionVar326),
    Var327(bic_instructionVar327),
    Var328(bic_instructionVar328),
    Var329(eor_instructionVar329),
    Var330(eor_instructionVar330),
    Var331(eor_instructionVar331),
    Var332(ldc2_instructionVar332),
    Var333(ldc2l_instructionVar333),
    Var334(ldc_instructionVar334),
    Var335(ldcl_instructionVar335),
    Var336(ldm_instructionVar336),
    Var337(ldm_instructionVar337),
    Var338(ldr_instructionVar338),
    Var339(ldrb_instructionVar339),
    Var340(ldrd_instructionVar340),
    Var341(ldrh_instructionVar341),
    Var342(ldrsb_instructionVar342),
    Var343(ldrsh_instructionVar343),
    Var344(orr_instructionVar344),
    Var345(orr_instructionVar345),
    Var346(orr_instructionVar346),
    Var347(rsb_instructionVar347),
    Var348(rsb_instructionVar348),
    Var349(rsb_instructionVar349),
    Var350(rsc_instructionVar350),
    Var351(rsc_instructionVar351),
    Var352(rsc_instructionVar352),
    Var353(sbc_instructionVar353),
    Var354(sbc_instructionVar354),
    Var355(sbc_instructionVar355),
    Var356(stc_instructionVar356),
    Var357(stcl_instructionVar357),
    Var358(str_instructionVar358),
    Var359(strb_instructionVar359),
    Var360(strh_instructionVar360),
    Var361(strd_instructionVar361),
    Var362(stm_instructionVar362),
    Var363(sub_instructionVar363),
    Var364(sub_instructionVar364),
    Var365(sub_instructionVar365),
    Var366(add_instructionVar366),
    Var367(add_instructionVar367),
    Var368(blx_instructionVar368),
    Var369(bl_instructionVar369),
    Var370(blx_instructionVar370),
    Var371(bl_instructionVar371),
    Var372(blx_instructionVar372),
    Var373(blx_instructionVar373),
    Var374(cbnz_instructionVar374),
    Var375(cbz_instructionVar375),
    Var376(ldr_instructionVar376),
    Var377(ldrb_instructionVar377),
    Var378(ldrh_instructionVar378),
    Var379(ldrsb_instructionVar379),
    Var380(ldrsh_instructionVar380),
    Var381(str_instructionVar381),
    Var382(strb_instructionVar382),
    Var383(strh_instructionVar383),
    Var384(sub_instructionVar384),
    Var385(sub_instructionVar385),
    Var386(add_instructionVar386),
    Var387(add_instructionVar387),
    Var388(adr_instructionVar388),
    Var389(asr_instructionVar389),
    Var390(b_instructionVar390),
    Var391(bl_instructionVar391),
    Var392(bl_instructionVar392),
    Var393(cmp_instructionVar393),
    Var394(ldmia_instructionVar394),
    Var395(ldr_instructionVar395),
    Var396(ldr_instructionVar396),
    Var397(ldr_instructionVar397),
    Var398(ldrb_instructionVar398),
    Var399(ldrh_instructionVar399),
    Var400(lsl_instructionVar400),
    Var401(lsr_instructionVar401),
    Var402(mov_instructionVar402),
    Var403(stmia_instructionVar403),
    Var404(str_instructionVar404),
    Var405(str_instructionVar405),
    Var406(strb_instructionVar406),
    Var407(strh_instructionVar407),
    Var408(sub_instructionVar408),
    Var409(b_instructionVar409),
    Var410(instructionVar410),
    Var411(nop_instructionVar411),
    Var412(instructionVar412),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var292(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var293(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var294(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var295(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var296(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var297(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var298(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var299(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var300(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var301(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var302(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var303(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var304(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var305(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var306(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var307(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var308(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var309(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var310(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var311(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var312(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var313(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var314(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var315(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var316(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var317(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var318(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var319(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var320(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var321(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var322(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var323(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var324(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var325(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var326(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var327(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var328(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var329(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var330(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var331(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var332(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var333(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var334(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var335(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var336(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var337(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var338(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var339(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var340(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var341(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var342(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var343(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var344(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var345(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var346(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var347(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var348(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var349(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var350(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var351(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var352(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var353(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var354(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var355(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var356(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var357(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var358(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var359(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var360(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var361(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var362(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var363(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var364(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var365(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var366(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var367(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var368(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var369(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var370(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var371(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var372(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var373(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var374(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var375(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var376(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var377(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var378(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var379(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var380(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var381(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var382(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var383(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var384(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var385(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var386(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var387(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var388(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var389(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var390(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var391(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var392(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var393(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var394(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var395(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var396(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var397(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var398(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var399(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var400(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var401(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var402(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var403(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var404(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var405(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var406(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var407(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var408(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var409(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var410(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var411(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var412(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 255) == 225
            && (tokens_param[1] & 255) == 160
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 255) == 241
            && (tokens_param[1] & 255) == 160
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 235
            && (tokens_param[1] & 255) == 255
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 243
            && (tokens_param[1] & 255) == 175
            && (tokens_param[2] & 255) == 128
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 250
            && (tokens_param[1] & 240) == 128
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                qadd_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 250
            && (tokens_param[1] & 240) == 128
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                qdadd_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 250
            && (tokens_param[1] & 240) == 128
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 176
        {
            if let Some((inst_len, parsed)) =
                qdsub_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 250
            && (tokens_param[1] & 240) == 128
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 160
        {
            if let Some((inst_len, parsed)) =
                qsub_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                smmul_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                smmulr_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                smulbb_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                smulbt_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 32
        {
            if let Some((inst_len, parsed)) =
                smultb_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 240) == 48
        {
            if let Some((inst_len, parsed)) =
                smultt_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 225
            && (tokens_param[1] & 240) == 0
            && (tokens_param[3] & 240) == 112
        {
            if let Some((inst_len, parsed)) =
                hlt_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 225
            && (tokens_param[1] & 240) == 32
            && (tokens_param[3] & 240) == 112
        {
            if let Some((inst_len, parsed)) =
                bkpt_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 225
            && (tokens_param[1] & 240) == 64
            && (tokens_param[3] & 240) == 112
        {
            if let Some((inst_len, parsed)) =
                hvc_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 231
            && (tokens_param[1] & 240) == 240
            && (tokens_param[3] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                udf_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331655 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 47
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 255) == 30
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 11
            && (tokens_param[1] & 255) == 255
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331657 == 50331656
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 47
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 240) == 48
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331655 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 47
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331655 == 50331650
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 47
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331653 == 50331652
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 47
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 160
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 255) == 14
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 47
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 240) == 48
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 17
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 49
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 81
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 3
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 5
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 5
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 21
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 53
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 149
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 22
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 54
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 86
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 26
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 58
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 90
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 154
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 186
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 30
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 62
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 23
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 55
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 87
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 15
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 146
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 17
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 49
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 81
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 19
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 21
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 21
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 22
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 22
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 21
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 53
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 149
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 22
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 54
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 86
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 26
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 58
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 90
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 154
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 186
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 30
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 62
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 24
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 23
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 24
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 55
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 24
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 87
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 31
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 146
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 15
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mrs_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 79
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mrs_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 111
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                clz_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 96
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 80
        {
            if let Some((inst_len, parsed)) =
                qadd_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 64
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 80
        {
            if let Some((inst_len, parsed)) =
                qdadd_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 96
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 80
        {
            if let Some((inst_len, parsed)) =
                qdsub_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 80
        {
            if let Some((inst_len, parsed)) =
                qsub_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swp_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 64
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swpb_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 192
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                smlal_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 80
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                smmla_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 80
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                smmlar_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 96
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                smmls_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 96
            && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                smmlsr_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 128
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                smull_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 96
            && (tokens_param[3] & 240) == 112
        {
            if let Some((inst_len, parsed)) =
                smc_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 255) == 45
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                srsdb_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                srsdb_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 233
            && (tokens_param[1] & 255) == 173
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                srsib_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 233
            && (tokens_param[1] & 255) == 141
            && (tokens_param[2] & 255) == 192
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                srsia_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 253) == 245
            && (tokens_param[1] & 127) == 95
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                pld_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                smuad_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 64
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                smusd_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                smulw_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 247
            && (tokens_param[1] & 240) == 224
            && (tokens_param[2] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                hvc_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 247
            && (tokens_param[1] & 240) == 240
            && (tokens_param[2] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                smc_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 247
            && (tokens_param[1] & 240) == 240
            && (tokens_param[2] & 240) == 160
        {
            if let Some((inst_len, parsed)) =
                udf_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 253) == 245
            && (tokens_param[1] & 112) == 80
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                pld_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 254) == 252
            && (tokens_param[1] & 80) == 0
        {
            if let Some((inst_len, parsed)) =
                stc2_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 254) == 252
            && (tokens_param[1] & 80) == 64
        {
            if let Some((inst_len, parsed)) =
                stc2l_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 2
            && (tokens_param[1] & 63) == 15
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adr_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 240) == 0
            && (tokens_param[3] & 176) == 160
        {
            if let Some((inst_len, parsed)) =
                smulw_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 96
            && (tokens_param[2] & 240) == 0
            && (tokens_param[3] & 144) == 128
        {
            if let Some((inst_len, parsed)) =
                smul_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 3
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 3
            && (tokens_param[1] & 240) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 112
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 112
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 112
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331651 == 50331650
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 2
            && (tokens_param[1] & 239) == 78
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 0
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 18
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 64
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 20
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 21
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 26
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 18
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 80
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 20
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 21
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 26
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 2
            && (tokens_param[1] & 63) == 15
        {
            if let Some((inst_len, parsed)) =
                adr_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 32
            && (tokens_param[3] & 176) == 128
        {
            if let Some((inst_len, parsed)) =
                smlaw_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 0
            && (tokens_param[3] & 144) == 128
        {
            if let Some((inst_len, parsed)) =
                smla_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 64
            && (tokens_param[3] & 144) == 128
        {
            if let Some((inst_len, parsed)) =
                smlal_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 12
            && (tokens_param[1] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                mcrr_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 12
            && (tokens_param[1] & 240) == 80
        {
            if let Some((inst_len, parsed)) =
                mrrc_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                mla_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                smlal_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                smull_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                umlal_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                umull_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331657 == 33554432
            && (tokens_param[0] & 255) == 250
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331657 == 33554440
            && (tokens_param[0] & 255) == 250
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331657 == 33554432
            && (tokens_param[0] & 255) == 251
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331657 == 33554440
            && (tokens_param[0] & 255) == 251
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 255) == 254
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr2_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 255) == 254
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc2_instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 255) == 254
            && (tokens_param[3] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                cdp2_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 255) == 189
            && (tokens_param[2] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                pop_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 255) == 247
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 191
            && (tokens_param[1] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 255) == 189
        {
            if let Some((inst_len, parsed)) =
                pop_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 233
            && (tokens_param[1] & 255) == 45
        {
            if let Some((inst_len, parsed)) =
                push_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 32
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                smlad_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 192
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                smlald_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 48
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                smlaw_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 64
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                smlsd_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 208
            && (tokens_param[3] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                smlsld_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 16
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                smla_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 251
            && (tokens_param[1] & 240) == 192
            && (tokens_param[3] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                smlal_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                mcrr_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 252
            && (tokens_param[1] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                mcrr_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 191) == 190
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 135) == 135
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                asr_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                asr_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 67
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 186
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                hlt_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554435 == 33554435
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                lsl_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                lsr_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                lsr_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 135) == 135
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 67
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 67
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 67
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                ror_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar292::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var292(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                bx_instructionVar293::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var293(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar294::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var294(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 254
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr2_instructionVar295::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var295(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 176
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar296::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var296(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 234
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar297::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var297(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 255) == 235
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar298::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var298(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554441 == 33554432
            && (tokens_param[0] & 15) == 11
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar299::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var299(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554441 == 33554440
            && (tokens_param[0] & 15) == 11
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar300::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var300(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 31) == 15
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar301::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var301(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 31) == 31
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar302::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var302(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar303::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var303(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar304::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var304(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 14
            && (tokens_param[3] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                cdp_instructionVar305::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var305(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331651 == 50331650
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar306::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var306(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331651 == 50331650
            && (tokens_param[0] & 13) == 5
            && (tokens_param[1] & 80) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar307::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var307(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar308::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var308(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 5
            && (tokens_param[1] & 80) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar309::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var309(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 112
        {
            if let Some((inst_len, parsed)) =
                ldrbt_instructionVar310::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var310(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 48
        {
            if let Some((inst_len, parsed)) =
                ldrt_instructionVar311::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var311(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 96
        {
            if let Some((inst_len, parsed)) =
                strbt_instructionVar312::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var312(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 32
        {
            if let Some((inst_len, parsed)) =
                strt_instructionVar313::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var313(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 15) == 15
        {
            if let Some((inst_len, parsed)) =
                swi_instructionVar314::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var314(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar315::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var315(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 190
        {
            if let Some((inst_len, parsed)) =
                bkpt_instructionVar316::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var316(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 222
        {
            if let Some((inst_len, parsed)) =
                udf_instructionVar317::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var317(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 69
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar318::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var318(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 70
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar319::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var319(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 188
        {
            if let Some((inst_len, parsed)) =
                pop_instructionVar320::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var320(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 189
        {
            if let Some((inst_len, parsed)) =
                pop_instructionVar321::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var321(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 180
        {
            if let Some((inst_len, parsed)) =
                push_instructionVar322::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var322(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 181
        {
            if let Some((inst_len, parsed)) =
                push_instructionVar323::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var323(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 255) == 223
        {
            if let Some((inst_len, parsed)) =
                svc_instructionVar324::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var324(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554432
            && (tokens_param[0] & 15) == 10
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar325::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var325(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar326::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var326(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar327::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var327(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar328::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var328(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar329::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var329(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar330::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var330(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar331::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var331(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 254) == 252
            && (tokens_param[1] & 80) == 16
        {
            if let Some((inst_len, parsed)) =
                ldc2_instructionVar332::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var332(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 33554432
            && (tokens_param[0] & 254) == 252
            && (tokens_param[1] & 80) == 80
        {
            if let Some((inst_len, parsed)) =
                ldc2l_instructionVar333::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var333(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 16
        {
            if let Some((inst_len, parsed)) =
                ldc_instructionVar334::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var334(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 80
        {
            if let Some((inst_len, parsed)) =
                ldcl_instructionVar335::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var335(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 8
            && (tokens_param[1] & 16) == 16
            && (tokens_param[2] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                ldm_instructionVar336::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var336(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 8
            && (tokens_param[1] & 16) == 16
            && (tokens_param[2] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                ldm_instructionVar337::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var337(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 16
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar338::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var338(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 80
        {
            if let Some((inst_len, parsed)) =
                ldrb_instructionVar339::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var339(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 0
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 240) == 208
        {
            if let Some((inst_len, parsed)) =
                ldrd_instructionVar340::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var340(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 240) == 176
        {
            if let Some((inst_len, parsed)) =
                ldrh_instructionVar341::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var341(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 240) == 208
        {
            if let Some((inst_len, parsed)) =
                ldrsb_instructionVar342::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var342(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldrsh_instructionVar343::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var343(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar344::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var344(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar345::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var345(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar346::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var346(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar347::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var347(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar348::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var348(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar349::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var349(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar350::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var350(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar351::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var351(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar352::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var352(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar353::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var353(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar354::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var354(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar355::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var355(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 0
        {
            if let Some((inst_len, parsed)) =
                stc_instructionVar356::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var356(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 64
        {
            if let Some((inst_len, parsed)) =
                stcl_instructionVar357::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var357(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 0
        {
            if let Some((inst_len, parsed)) =
                str_instructionVar358::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var358(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 64
        {
            if let Some((inst_len, parsed)) =
                strb_instructionVar359::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var359(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 240) == 176
        {
            if let Some((inst_len, parsed)) =
                strh_instructionVar360::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var360(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                strd_instructionVar361::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var361(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 14) == 8
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                stm_instructionVar362::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var362(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar363::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var363(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar364::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var364(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 50331649 == 50331648
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar365::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var365(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 28
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar366::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var366(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 24
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar367::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var367(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554441 == 33554441
            && (tokens_param[0] & 248) == 240
            && (tokens_param[2] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar368::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var368(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554441 == 33554441
            && (tokens_param[0] & 248) == 240
            && (tokens_param[2] & 208) == 208
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar369::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var369(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 240
            && (tokens_param[2] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar370::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var370(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 240
            && (tokens_param[2] & 208) == 208
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar371::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var371(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 232
            && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar372::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var372(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 240
            && (tokens_param[2] & 208) == 192
        {
            if let Some((inst_len, parsed)) =
                blx_instructionVar373::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var373(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 253) == 185
        {
            if let Some((inst_len, parsed)) =
                cbnz_instructionVar374::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var374(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 253) == 177
        {
            if let Some((inst_len, parsed)) =
                cbz_instructionVar375::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var375(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 88
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar376::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var376(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 92
        {
            if let Some((inst_len, parsed)) =
                ldrb_instructionVar377::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var377(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 90
        {
            if let Some((inst_len, parsed)) =
                ldrh_instructionVar378::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var378(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 86
        {
            if let Some((inst_len, parsed)) =
                ldrsb_instructionVar379::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var379(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 94
        {
            if let Some((inst_len, parsed)) =
                ldrsh_instructionVar380::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var380(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 80
        {
            if let Some((inst_len, parsed)) =
                str_instructionVar381::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var381(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 84
        {
            if let Some((inst_len, parsed)) =
                strb_instructionVar382::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var382(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 82
        {
            if let Some((inst_len, parsed)) =
                strh_instructionVar383::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var383(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 30
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar384::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var384(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 254) == 26
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar385::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var385(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 48
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar386::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var386(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar387::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var387(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                adr_instructionVar388::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var388(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 16
        {
            if let Some((inst_len, parsed)) =
                asr_instructionVar389::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var389(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar390::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var390(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar391::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var391(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 248
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar392::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var392(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar393::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var393(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                ldmia_instructionVar394::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var394(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar395::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var395(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar396::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var396(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar397::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var397(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 120
        {
            if let Some((inst_len, parsed)) =
                ldrb_instructionVar398::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var398(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                ldrh_instructionVar399::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var399(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                lsl_instructionVar400::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var400(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                lsr_instructionVar401::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var401(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 32
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar402::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var402(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                stmia_instructionVar403::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var403(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 96
        {
            if let Some((inst_len, parsed)) =
                str_instructionVar404::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var404(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                str_instructionVar405::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var405(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 112
        {
            if let Some((inst_len, parsed)) =
                strb_instructionVar406::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var406(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                strh_instructionVar407::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var407(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 248) == 56
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar408::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var408(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554433 == 33554433
            && (tokens_param[0] & 240) == 208
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar409::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var409(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 33554433 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar410::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var410(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 255) == 192
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar411::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var411(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 33554432 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar412::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var412(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:240:1, end:240:7))"]
#[derive(Clone, Debug)]
struct ItCondVar0 {}
impl ItCondVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableItCond {
    Var0(ItCondVar0),
}
impl TableItCond {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 1 == 1 {
            if let Some((inst_len, parsed)) =
                ItCondVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:241:1, end:241:15))"]
#[derive(Clone, Debug)]
struct CheckInIT_CZNOVar0 {}
impl CheckInIT_CZNOVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCheckInIT_CZNO {
    Var0(CheckInIT_CZNOVar0),
}
impl TableCheckInIT_CZNO {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 1 == 1 {
            if let Some((inst_len, parsed)) =
                CheckInIT_CZNOVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:242:1, end:242:14))"]
#[derive(Clone, Debug)]
struct CheckInIT_CZNVar0 {}
impl CheckInIT_CZNVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCheckInIT_CZN {
    Var0(CheckInIT_CZNVar0),
}
impl TableCheckInIT_CZN {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 1 == 1 {
            if let Some((inst_len, parsed)) =
                CheckInIT_CZNVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARM.sinc, start:243:1, end:243:13))"]
#[derive(Clone, Debug)]
struct CheckInIT_ZNVar0 {}
impl CheckInIT_ZNVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCheckInIT_ZN {
    Var0(CheckInIT_ZNVar0),
}
impl TableCheckInIT_ZN {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 1 == 1 {
            if let Some((inst_len, parsed)) =
                CheckInIT_ZNVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:626:1, end:626:3))"]
#[derive(Clone, Debug)]
struct rnVar0 {}
impl rnVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:627:1, end:627:3))"]
#[derive(Clone, Debug)]
struct rnVar1 {
    Rn: u8,
}
impl rnVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.Rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn }))
    }
}
#[derive(Clone, Debug)]
enum Tablern {
    Var0(rnVar0),
    Var1(rnVar1),
}
impl Tablern {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                rnVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rnVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:629:1, end:629:3))"]
#[derive(Clone, Debug)]
struct rmVar0 {}
impl rmVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:630:1, end:630:3))"]
#[derive(Clone, Debug)]
struct rmVar1 {
    Rm: u8,
}
impl rmVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.Rm)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rm }))
    }
}
#[derive(Clone, Debug)]
enum Tablerm {
    Var0(rmVar0),
    Var1(rmVar1),
}
impl Tablerm {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                rmVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rmVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:632:1, end:632:3))"]
#[derive(Clone, Debug)]
struct rsVar0 {}
impl rsVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:633:1, end:633:3))"]
#[derive(Clone, Debug)]
struct rsVar1 {
    Rs: u8,
}
impl rsVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.Rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rs = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rs }))
    }
}
#[derive(Clone, Debug)]
enum Tablers {
    Var0(rsVar0),
    Var1(rsVar1),
}
impl Tablers {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                rsVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rsVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:635:1, end:635:3))"]
#[derive(Clone, Debug)]
struct ccVar0 {}
impl ccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:636:1, end:636:3))"]
#[derive(Clone, Debug)]
struct ccVar1 {}
impl ccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:637:1, end:637:3))"]
#[derive(Clone, Debug)]
struct ccVar2 {}
impl ccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:638:1, end:638:3))"]
#[derive(Clone, Debug)]
struct ccVar3 {}
impl ccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:639:1, end:639:3))"]
#[derive(Clone, Debug)]
struct ccVar4 {}
impl ccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:640:1, end:640:3))"]
#[derive(Clone, Debug)]
struct ccVar5 {}
impl ccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:641:1, end:641:3))"]
#[derive(Clone, Debug)]
struct ccVar6 {}
impl ccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:642:1, end:642:3))"]
#[derive(Clone, Debug)]
struct ccVar7 {}
impl ccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:643:1, end:643:3))"]
#[derive(Clone, Debug)]
struct ccVar8 {}
impl ccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:644:1, end:644:3))"]
#[derive(Clone, Debug)]
struct ccVar9 {}
impl ccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:645:1, end:645:3))"]
#[derive(Clone, Debug)]
struct ccVar10 {}
impl ccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:646:1, end:646:3))"]
#[derive(Clone, Debug)]
struct ccVar11 {}
impl ccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:647:1, end:647:3))"]
#[derive(Clone, Debug)]
struct ccVar12 {}
impl ccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:648:1, end:648:3))"]
#[derive(Clone, Debug)]
struct ccVar13 {}
impl ccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecc {
    Var0(ccVar0),
    Var1(ccVar1),
    Var2(ccVar2),
    Var3(ccVar3),
    Var4(ccVar4),
    Var5(ccVar5),
    Var6(ccVar6),
    Var7(ccVar7),
    Var8(ccVar8),
    Var9(ccVar9),
    Var10(ccVar10),
    Var11(ccVar11),
    Var12(ccVar12),
    Var13(ccVar13),
}
impl Tablecc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                ccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                ccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                ccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                ccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                ccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                ccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 96 {
            if let Some((inst_len, parsed)) =
                ccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                ccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                ccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                ccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                ccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                ccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                ccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                ccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:651:1, end:651:5))"]
#[derive(Clone, Debug)]
struct CONDVar0 {}
impl CONDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:650:1, end:650:5))"]
#[derive(Clone, Debug)]
struct CONDVar1 {
    cc: Tablecc,
}
impl CONDVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc }))
    }
}
#[derive(Clone, Debug)]
enum TableCOND {
    Var0(CONDVar0),
    Var1(CONDVar1),
}
impl TableCOND {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && context_param.0 & 1 == 0 && (tokens_param[0] & 240) == 224 {
            if let Some((inst_len, parsed)) =
                CONDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 1 == 0 {
            if let Some((inst_len, parsed)) =
                CONDVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:659:1, end:659:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar0 {}
impl SBIT_CZNOVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:660:1, end:660:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar1 {}
impl SBIT_CZNOVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_CZNO {
    Var0(SBIT_CZNOVar0),
    Var1(SBIT_CZNOVar1),
}
impl TableSBIT_CZNO {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                SBIT_CZNOVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                SBIT_CZNOVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:661:1, end:661:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar0 {}
impl SBIT_ZNVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:662:1, end:662:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar1 {}
impl SBIT_ZNVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_ZN {
    Var0(SBIT_ZNVar0),
    Var1(SBIT_ZNVar1),
}
impl TableSBIT_ZN {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                SBIT_ZNVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                SBIT_ZNVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:664:1, end:664:7))"]
#[derive(Clone, Debug)]
struct Addr24Var0 {
    addr24: u32,
}
impl Addr24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    i128::try_from(
                        (if self.addr24 & 8388608 != 0 {
                            -1 & !8388607
                        } else {
                            0
                        } | self.addr24 as i32),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        let addr24 = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr24 {
    Var0(Addr24Var0),
}
impl TableAddr24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                Addr24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:669:1, end:669:8))"]
#[derive(Clone, Debug)]
struct HAddr24Var0 {
    addr24: u32,
    H24: u8,
}
impl HAddr24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    i128::try_from(
                        (if self.addr24 & 8388608 != 0 {
                            -1 & !8388607
                        } else {
                            0
                        } | self.addr24 as i32),
                    )
                    .unwrap(),
                ),
            )
            .wrapping_add(2i128.wrapping_mul(i128::try_from(self.H24).unwrap()))
            & 4294967295i128);
        global_set.set(Some(AddrType::try_from(calc_reloc).unwrap()), |context| {
            context.write_TMode(
                u8::try_from(i128::try_from(context.read_TMode()).unwrap() & 1).unwrap(),
            )
        });
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        let H24 = token_4(tokens_current);
        let addr24 = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24, H24 }))
    }
}
#[derive(Clone, Debug)]
enum TableHAddr24 {
    Var0(HAddr24Var0),
}
impl TableHAddr24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                HAddr24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:676:1, end:676:5))"]
#[derive(Clone, Debug)]
struct XBITVar0 {}
impl XBITVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let smRn = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:677:1, end:677:5))"]
#[derive(Clone, Debug)]
struct XBITVar1 {}
impl XBITVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let smRn = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableXBIT {
    Var0(XBITVar0),
    Var1(XBITVar1),
}
impl TableXBIT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                XBITVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                XBITVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:679:1, end:679:5))"]
#[derive(Clone, Debug)]
struct YBITVar0 {}
impl YBITVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let smRm = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:680:1, end:680:5))"]
#[derive(Clone, Debug)]
struct YBITVar1 {}
impl YBITVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let smRm = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableYBIT {
    Var0(YBITVar0),
    Var1(YBITVar1),
}
impl TableYBIT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                YBITVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                YBITVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:690:1, end:690:7))"]
#[derive(Clone, Debug)]
struct shift1Var0 {
    immed: u8,
    rotate: u8,
}
impl shift1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_value: i128 = 0;
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128)),
        )
        .ok()
        .and_then(|shl| i128::try_from(self.immed).unwrap().checked_shl(shl))
        .unwrap_or(0)
            | u32::try_from(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128))
                .ok()
                .and_then(|shr| i128::try_from(self.immed).unwrap().checked_shr(shr))
                .unwrap_or(0))
            & 4294967295i128);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_value.is_negative(), calc_value.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_value: i128 = 0;
        let mut block_0_len = 4;
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .wrapping_mul(2i128),
            ),
        )
        .ok()
        .and_then(|shl| {
            i128::try_from(token_25(tokens_current))
                .unwrap()
                .checked_shl(shl)
        })
        .unwrap_or(0)
            | u32::try_from(
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .wrapping_mul(2i128),
            )
            .ok()
            .and_then(|shr| {
                i128::try_from(token_25(tokens_current))
                    .unwrap()
                    .checked_shr(shr)
            })
            .unwrap_or(0))
            & 4294967295i128);
        let immed = token_25(tokens_current);
        let rotate = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift1 {
    Var0(shift1Var0),
}
impl Tableshift1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                shift1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:803:1, end:803:12))"]
#[derive(Clone, Debug)]
struct mcrOperandsVar0 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
}
impl mcrOperandsVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 11usize] = [
            meaning_8_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let opc1 = token_16(tokens_current);
        let cpn = token_14(tokens_current);
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        let CRn = token_10(tokens_current);
        let CRm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablemcrOperands {
    Var0(mcrOperandsVar0),
}
impl TablemcrOperands {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                mcrOperandsVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:809:1, end:809:7))"]
#[derive(Clone, Debug)]
struct shift2Var0 {
    rm: Tablerm,
}
impl shift2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:819:1, end:819:7))"]
#[derive(Clone, Debug)]
struct shift2Var1 {
    rm: Tablerm,
}
impl shift2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:829:1, end:829:7))"]
#[derive(Clone, Debug)]
struct shift2Var2 {
    rm: Tablerm,
}
impl shift2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("asr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:839:1, end:839:7))"]
#[derive(Clone, Debug)]
struct shift2Var3 {
    rm: Tablerm,
}
impl shift2Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("rrx"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:814:1, end:814:7))"]
#[derive(Clone, Debug)]
struct shift2Var4 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsl #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:824:1, end:824:7))"]
#[derive(Clone, Debug)]
struct shift2Var5 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:834:1, end:834:7))"]
#[derive(Clone, Debug)]
struct shift2Var6 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("asr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:844:1, end:844:7))"]
#[derive(Clone, Debug)]
struct shift2Var7 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("ror #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift2 {
    Var0(shift2Var0),
    Var1(shift2Var1),
    Var2(shift2Var2),
    Var3(shift2Var3),
    Var4(shift2Var4),
    Var5(shift2Var5),
    Var6(shift2Var6),
    Var7(shift2Var7),
}
impl Tableshift2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                shift2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 32
        {
            if let Some((inst_len, parsed)) =
                shift2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                shift2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 96
        {
            if let Some((inst_len, parsed)) =
                shift2Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 0 {
            if let Some((inst_len, parsed)) =
                shift2Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 32 {
            if let Some((inst_len, parsed)) =
                shift2Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 64 {
            if let Some((inst_len, parsed)) =
                shift2Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 96 {
            if let Some((inst_len, parsed)) =
                shift2Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:853:1, end:853:7))"]
#[derive(Clone, Debug)]
struct shift3Var0 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsl "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:858:1, end:858:7))"]
#[derive(Clone, Debug)]
struct shift3Var1 {
    rm: Tablerm,
    rs: Tablers,
}
impl shift3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsr "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:863:1, end:863:7))"]
#[derive(Clone, Debug)]
struct shift3Var2 {
    rm: Tablerm,
    rs: Tablers,
}
impl shift3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("asr "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rs }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:868:1, end:868:7))"]
#[derive(Clone, Debug)]
struct shift3Var3 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("ror "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift3 {
    Var0(shift3Var0),
    Var1(shift3Var1),
    Var2(shift3Var2),
    Var3(shift3Var3),
}
impl Tableshift3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                shift3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                shift3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                shift3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                shift3Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:940:1, end:940:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar0 {
    rm: Tablerm,
}
impl addr2shiftVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:943:1, end:943:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar1 {
    rm: Tablerm,
}
impl addr2shiftVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",lsr #32")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:945:1, end:945:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar2 {
    rm: Tablerm,
}
impl addr2shiftVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",asr #32")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:947:1, end:947:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar3 {
    rm: Tablerm,
}
impl addr2shiftVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",rrx")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:941:1, end:941:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar4 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",lsl #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:942:1, end:942:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar5 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",lsr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:944:1, end:944:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar6 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",asr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:946:1, end:946:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar7 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",ror #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr2shift {
    Var0(addr2shiftVar0),
    Var1(addr2shiftVar1),
    Var2(addr2shiftVar2),
    Var3(addr2shiftVar3),
    Var4(addr2shiftVar4),
    Var5(addr2shiftVar5),
    Var6(addr2shiftVar6),
    Var7(addr2shiftVar7),
}
impl Tableaddr2shift {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 96 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 0 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 32 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 64 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 96 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:951:1, end:951:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var0 {
    offset_12: u16,
}
impl addrmode2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(i128::try_from(token_24(tokens_current)).unwrap());
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:957:1, end:957:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var1 {
    offset_12: u16,
}
impl addrmode2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(i128::try_from(self.offset_12).unwrap()));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(i128::try_from(token_24(tokens_current)).unwrap()));
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:963:1, end:963:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var2 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:964:1, end:964:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var3 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:965:1, end:965:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var4 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:966:1, end:966:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var5 {
    addr2shift: Tableaddr2shift,
    rn: Tablern,
}
impl addrmode2Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:968:1, end:968:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var6 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:969:1, end:969:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var7 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:970:1, end:970:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var8 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:971:1, end:971:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var9 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:973:1, end:973:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var10 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:974:1, end:974:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var11 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:975:1, end:975:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var12 {
    addr2shift: Tableaddr2shift,
    rn: Tablern,
}
impl addrmode2Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:976:1, end:976:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var13 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:978:1, end:978:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var14 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:979:1, end:979:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var15 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:980:1, end:980:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var16 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:981:1, end:981:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var17 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode2 {
    Var0(addrmode2Var0),
    Var1(addrmode2Var1),
    Var2(addrmode2Var2),
    Var3(addrmode2Var3),
    Var4(addrmode2Var4),
    Var5(addrmode2Var5),
    Var6(addrmode2Var6),
    Var7(addrmode2Var7),
    Var8(addrmode2Var8),
    Var9(addrmode2Var9),
    Var10(addrmode2Var10),
    Var11(addrmode2Var11),
    Var12(addrmode2Var12),
    Var13(addrmode2Var13),
    Var14(addrmode2Var14),
    Var15(addrmode2Var15),
    Var16(addrmode2Var16),
    Var17(addrmode2Var17),
}
impl Tableaddrmode2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 175) == 143 {
            if let Some((inst_len, parsed)) =
                addrmode2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 175) == 15 {
            if let Some((inst_len, parsed)) =
                addrmode2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:990:1, end:990:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var0 {
    immedH: u8,
    immedL: u8,
}
impl addrmode3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
                    .unwrap_or(0)
                    | i128::try_from(self.immedL).unwrap()),
            );
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(token_11(tokens_current)).unwrap()),
            );
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:996:1, end:996:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var1 {
    immedH: u8,
    immedL: u8,
}
impl addrmode3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
                    .unwrap_or(0)
                    | i128::try_from(self.immedL).unwrap()),
            ),
        );
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(token_11(tokens_current)).unwrap()),
            ),
        );
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1014:1, end:1014:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var2 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1019:1, end:1019:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var3 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1036:1, end:1036:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var4 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1041:1, end:1041:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var5 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1002:1, end:1002:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var6 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1008:1, end:1008:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var7 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1024:1, end:1024:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var8 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1030:1, end:1030:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var9 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1058:1, end:1058:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var10 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1063:1, end:1063:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var11 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],-")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1046:1, end:1046:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var12 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1052:1, end:1052:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var13 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode3 {
    Var0(addrmode3Var0),
    Var1(addrmode3Var1),
    Var2(addrmode3Var2),
    Var3(addrmode3Var3),
    Var4(addrmode3Var4),
    Var5(addrmode3Var5),
    Var6(addrmode3Var6),
    Var7(addrmode3Var7),
    Var8(addrmode3Var8),
    Var9(addrmode3Var9),
    Var10(addrmode3Var10),
    Var11(addrmode3Var11),
    Var12(addrmode3Var12),
    Var13(addrmode3Var13),
}
impl Tableaddrmode3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 239) == 207 {
            if let Some((inst_len, parsed)) =
                addrmode3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 239) == 79 {
            if let Some((inst_len, parsed)) =
                addrmode3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                addrmode3Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                addrmode3Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                addrmode3Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                addrmode3Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 192) == 128
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                addrmode3Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                addrmode3Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1074:1, end:1074:7))"]
#[derive(Clone, Debug)]
struct linc15Var0 {}
impl linc15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1075:1, end:1075:7))"]
#[derive(Clone, Debug)]
struct linc15Var1 {}
impl linc15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc15 {
    Var0(linc15Var0),
    Var1(linc15Var1),
}
impl Tablelinc15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                linc15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                linc15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1077:1, end:1077:7))"]
#[derive(Clone, Debug)]
struct linc14Var0 {}
impl linc14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1076:1, end:1076:7))"]
#[derive(Clone, Debug)]
struct linc14Var1 {
    linc15: Tablelinc15,
}
impl linc14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc15
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc15 = if let Some((len, table)) =
            Tablelinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1078:1, end:1078:7))"]
#[derive(Clone, Debug)]
struct linc14Var2 {
    linc15: Tablelinc15,
}
impl linc14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc15 = if let Some((len, table)) =
            Tablelinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc14 {
    Var0(linc14Var0),
    Var1(linc14Var1),
    Var2(linc14Var2),
}
impl Tablelinc14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                linc14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                linc14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                linc14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1080:1, end:1080:7))"]
#[derive(Clone, Debug)]
struct linc13Var0 {}
impl linc13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1079:1, end:1079:7))"]
#[derive(Clone, Debug)]
struct linc13Var1 {
    linc14: Tablelinc14,
}
impl linc13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc14 = if let Some((len, table)) =
            Tablelinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct linc13Var2 {
    linc14: Tablelinc14,
}
impl linc13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc14 = if let Some((len, table)) =
            Tablelinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc13 {
    Var0(linc13Var0),
    Var1(linc13Var1),
    Var2(linc13Var2),
}
impl Tablelinc13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 7) == 4 {
            if let Some((inst_len, parsed)) =
                linc13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                linc13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                linc13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1083:1, end:1083:7))"]
#[derive(Clone, Debug)]
struct linc12Var0 {}
impl linc12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1082:1, end:1082:7))"]
#[derive(Clone, Debug)]
struct linc12Var1 {
    linc13: Tablelinc13,
}
impl linc12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc13
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc13 = if let Some((len, table)) =
            Tablelinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1084:1, end:1084:7))"]
#[derive(Clone, Debug)]
struct linc12Var2 {
    linc13: Tablelinc13,
}
impl linc12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc13 = if let Some((len, table)) =
            Tablelinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc12 {
    Var0(linc12Var0),
    Var1(linc12Var1),
    Var2(linc12Var2),
}
impl Tablelinc12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                linc12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                linc12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                linc12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1086:1, end:1086:7))"]
#[derive(Clone, Debug)]
struct linc11Var0 {}
impl linc11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1085:1, end:1085:7))"]
#[derive(Clone, Debug)]
struct linc11Var1 {
    linc12: Tablelinc12,
}
impl linc11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc12 = if let Some((len, table)) =
            Tablelinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1087:1, end:1087:7))"]
#[derive(Clone, Debug)]
struct linc11Var2 {
    linc12: Tablelinc12,
}
impl linc11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc12 = if let Some((len, table)) =
            Tablelinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc11 {
    Var0(linc11Var0),
    Var1(linc11Var1),
    Var2(linc11Var2),
}
impl Tablelinc11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 16 {
            if let Some((inst_len, parsed)) =
                linc11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                linc11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                linc11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1089:1, end:1089:7))"]
#[derive(Clone, Debug)]
struct linc10Var0 {}
impl linc10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1088:1, end:1088:7))"]
#[derive(Clone, Debug)]
struct linc10Var1 {
    linc11: Tablelinc11,
}
impl linc10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc11 = if let Some((len, table)) =
            Tablelinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1090:1, end:1090:7))"]
#[derive(Clone, Debug)]
struct linc10Var2 {
    linc11: Tablelinc11,
}
impl linc10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc11 = if let Some((len, table)) =
            Tablelinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc10 {
    Var0(linc10Var0),
    Var1(linc10Var1),
    Var2(linc10Var2),
}
impl Tablelinc10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 63) == 32 {
            if let Some((inst_len, parsed)) =
                linc10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                linc10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                linc10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1092:1, end:1092:6))"]
#[derive(Clone, Debug)]
struct linc9Var0 {}
impl linc9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1091:1, end:1091:6))"]
#[derive(Clone, Debug)]
struct linc9Var1 {
    linc10: Tablelinc10,
}
impl linc9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc10 = if let Some((len, table)) =
            Tablelinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1093:1, end:1093:6))"]
#[derive(Clone, Debug)]
struct linc9Var2 {
    linc10: Tablelinc10,
}
impl linc9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc10 = if let Some((len, table)) =
            Tablelinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc9 {
    Var0(linc9Var0),
    Var1(linc9Var1),
    Var2(linc9Var2),
}
impl Tablelinc9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 127) == 64 {
            if let Some((inst_len, parsed)) =
                linc9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                linc9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                linc9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1095:1, end:1095:6))"]
#[derive(Clone, Debug)]
struct linc8Var0 {}
impl linc8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1094:1, end:1094:6))"]
#[derive(Clone, Debug)]
struct linc8Var1 {
    linc9: Tablelinc9,
}
impl linc8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1096:1, end:1096:6))"]
#[derive(Clone, Debug)]
struct linc8Var2 {
    linc9: Tablelinc9,
}
impl linc8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc8 {
    Var0(linc8Var0),
    Var1(linc8Var1),
    Var2(linc8Var2),
}
impl Tablelinc8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 255) == 128 {
            if let Some((inst_len, parsed)) =
                linc8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                linc8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                linc8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1098:1, end:1098:6))"]
#[derive(Clone, Debug)]
struct linc7Var0 {}
impl linc7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1097:1, end:1097:6))"]
#[derive(Clone, Debug)]
struct linc7Var1 {
    linc8: Tablelinc8,
}
impl linc7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1099:1, end:1099:6))"]
#[derive(Clone, Debug)]
struct linc7Var2 {
    linc8: Tablelinc8,
}
impl linc7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc7 {
    Var0(linc7Var0),
    Var1(linc7Var1),
    Var2(linc7Var2),
}
impl Tablelinc7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                linc7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                linc7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1101:1, end:1101:6))"]
#[derive(Clone, Debug)]
struct linc6Var0 {}
impl linc6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1100:1, end:1100:6))"]
#[derive(Clone, Debug)]
struct linc6Var1 {
    linc7: Tablelinc7,
}
impl linc6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1102:1, end:1102:6))"]
#[derive(Clone, Debug)]
struct linc6Var2 {
    linc7: Tablelinc7,
}
impl linc6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc6 {
    Var0(linc6Var0),
    Var1(linc6Var1),
    Var2(linc6Var2),
}
impl Tablelinc6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                linc6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                linc6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1104:1, end:1104:6))"]
#[derive(Clone, Debug)]
struct linc5Var0 {}
impl linc5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1103:1, end:1103:6))"]
#[derive(Clone, Debug)]
struct linc5Var1 {
    linc6: Tablelinc6,
}
impl linc5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1105:1, end:1105:6))"]
#[derive(Clone, Debug)]
struct linc5Var2 {
    linc6: Tablelinc6,
}
impl linc5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc5 {
    Var0(linc5Var0),
    Var1(linc5Var1),
    Var2(linc5Var2),
}
impl Tablelinc5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 7) == 4 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                linc5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                linc5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1107:1, end:1107:6))"]
#[derive(Clone, Debug)]
struct linc4Var0 {}
impl linc4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1106:1, end:1106:6))"]
#[derive(Clone, Debug)]
struct linc4Var1 {
    linc5: Tablelinc5,
}
impl linc4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1108:1, end:1108:6))"]
#[derive(Clone, Debug)]
struct linc4Var2 {
    linc5: Tablelinc5,
}
impl linc4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc4 {
    Var0(linc4Var0),
    Var1(linc4Var1),
    Var2(linc4Var2),
}
impl Tablelinc4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 8 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                linc4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                linc4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1110:1, end:1110:6))"]
#[derive(Clone, Debug)]
struct linc3Var0 {}
impl linc3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1109:1, end:1109:6))"]
#[derive(Clone, Debug)]
struct linc3Var1 {
    linc4: Tablelinc4,
}
impl linc3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1111:1, end:1111:6))"]
#[derive(Clone, Debug)]
struct linc3Var2 {
    linc4: Tablelinc4,
}
impl linc3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc3 {
    Var0(linc3Var0),
    Var1(linc3Var1),
    Var2(linc3Var2),
}
impl Tablelinc3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 16 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                linc3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                linc3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1113:1, end:1113:6))"]
#[derive(Clone, Debug)]
struct linc2Var0 {}
impl linc2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1112:1, end:1112:6))"]
#[derive(Clone, Debug)]
struct linc2Var1 {
    linc3: Tablelinc3,
}
impl linc2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1114:1, end:1114:6))"]
#[derive(Clone, Debug)]
struct linc2Var2 {
    linc3: Tablelinc3,
}
impl linc2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc2 {
    Var0(linc2Var0),
    Var1(linc2Var1),
    Var2(linc2Var2),
}
impl Tablelinc2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                linc2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                linc2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1116:1, end:1116:6))"]
#[derive(Clone, Debug)]
struct linc1Var0 {}
impl linc1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1115:1, end:1115:6))"]
#[derive(Clone, Debug)]
struct linc1Var1 {
    linc2: Tablelinc2,
}
impl linc1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1117:1, end:1117:6))"]
#[derive(Clone, Debug)]
struct linc1Var2 {
    linc2: Tablelinc2,
}
impl linc1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc1 {
    Var0(linc1Var0),
    Var1(linc1Var1),
    Var2(linc1Var2),
}
impl Tablelinc1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 127) == 64 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                linc1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                linc1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                linc1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1119:1, end:1119:6))"]
#[derive(Clone, Debug)]
struct linc0Var0 {}
impl linc0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1118:1, end:1118:6))"]
#[derive(Clone, Debug)]
struct linc0Var1 {
    linc1: Tablelinc1,
}
impl linc0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1120:1, end:1120:6))"]
#[derive(Clone, Debug)]
struct linc0Var2 {
    linc1: Tablelinc1,
}
impl linc0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc0 {
    Var0(linc0Var0),
    Var1(linc0Var1),
    Var2(linc0Var2),
}
impl Tablelinc0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 128 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                linc0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                linc0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                linc0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1121:1, end:1121:11))"]
#[derive(Clone, Debug)]
struct ldlist_incVar0 {
    linc0: Tablelinc0,
}
impl ldlist_incVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.linc0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc0 = if let Some((len, table)) =
            Tablelinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_inc {
    Var0(ldlist_incVar0),
}
impl Tableldlist_inc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ldlist_incVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1124:1, end:1124:7))"]
#[derive(Clone, Debug)]
struct sinc15Var0 {}
impl sinc15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1125:1, end:1125:7))"]
#[derive(Clone, Debug)]
struct sinc15Var1 {}
impl sinc15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc15 {
    Var0(sinc15Var0),
    Var1(sinc15Var1),
}
impl Tablesinc15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sinc15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sinc15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1127:1, end:1127:7))"]
#[derive(Clone, Debug)]
struct sinc14Var0 {}
impl sinc14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1126:1, end:1126:7))"]
#[derive(Clone, Debug)]
struct sinc14Var1 {
    sinc15: Tablesinc15,
}
impl sinc14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc15
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc15 = if let Some((len, table)) =
            Tablesinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1128:1, end:1128:7))"]
#[derive(Clone, Debug)]
struct sinc14Var2 {
    sinc15: Tablesinc15,
}
impl sinc14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc15 = if let Some((len, table)) =
            Tablesinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc14 {
    Var0(sinc14Var0),
    Var1(sinc14Var1),
    Var2(sinc14Var2),
}
impl Tablesinc14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                sinc14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sinc14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sinc14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1130:1, end:1130:7))"]
#[derive(Clone, Debug)]
struct sinc13Var0 {}
impl sinc13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1129:1, end:1129:7))"]
#[derive(Clone, Debug)]
struct sinc13Var1 {
    sinc14: Tablesinc14,
}
impl sinc13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc14 = if let Some((len, table)) =
            Tablesinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1131:1, end:1131:7))"]
#[derive(Clone, Debug)]
struct sinc13Var2 {
    sinc14: Tablesinc14,
}
impl sinc13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc14 = if let Some((len, table)) =
            Tablesinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc13 {
    Var0(sinc13Var0),
    Var1(sinc13Var1),
    Var2(sinc13Var2),
}
impl Tablesinc13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 7) == 4 {
            if let Some((inst_len, parsed)) =
                sinc13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sinc13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sinc13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1133:1, end:1133:7))"]
#[derive(Clone, Debug)]
struct sinc12Var0 {}
impl sinc12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1132:1, end:1132:7))"]
#[derive(Clone, Debug)]
struct sinc12Var1 {
    sinc13: Tablesinc13,
}
impl sinc12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc13
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc13 = if let Some((len, table)) =
            Tablesinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1134:1, end:1134:7))"]
#[derive(Clone, Debug)]
struct sinc12Var2 {
    sinc13: Tablesinc13,
}
impl sinc12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc13 = if let Some((len, table)) =
            Tablesinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc12 {
    Var0(sinc12Var0),
    Var1(sinc12Var1),
    Var2(sinc12Var2),
}
impl Tablesinc12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                sinc12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sinc12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sinc12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1136:1, end:1136:7))"]
#[derive(Clone, Debug)]
struct sinc11Var0 {}
impl sinc11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1135:1, end:1135:7))"]
#[derive(Clone, Debug)]
struct sinc11Var1 {
    sinc12: Tablesinc12,
}
impl sinc11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc12 = if let Some((len, table)) =
            Tablesinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1137:1, end:1137:7))"]
#[derive(Clone, Debug)]
struct sinc11Var2 {
    sinc12: Tablesinc12,
}
impl sinc11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc12 = if let Some((len, table)) =
            Tablesinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc11 {
    Var0(sinc11Var0),
    Var1(sinc11Var1),
    Var2(sinc11Var2),
}
impl Tablesinc11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 16 {
            if let Some((inst_len, parsed)) =
                sinc11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sinc11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sinc11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1139:1, end:1139:7))"]
#[derive(Clone, Debug)]
struct sinc10Var0 {}
impl sinc10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1138:1, end:1138:7))"]
#[derive(Clone, Debug)]
struct sinc10Var1 {
    sinc11: Tablesinc11,
}
impl sinc10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc11 = if let Some((len, table)) =
            Tablesinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1140:1, end:1140:7))"]
#[derive(Clone, Debug)]
struct sinc10Var2 {
    sinc11: Tablesinc11,
}
impl sinc10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc11 = if let Some((len, table)) =
            Tablesinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc10 {
    Var0(sinc10Var0),
    Var1(sinc10Var1),
    Var2(sinc10Var2),
}
impl Tablesinc10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 63) == 32 {
            if let Some((inst_len, parsed)) =
                sinc10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sinc10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sinc10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1142:1, end:1142:6))"]
#[derive(Clone, Debug)]
struct sinc9Var0 {}
impl sinc9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1141:1, end:1141:6))"]
#[derive(Clone, Debug)]
struct sinc9Var1 {
    sinc10: Tablesinc10,
}
impl sinc9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc10 = if let Some((len, table)) =
            Tablesinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1143:1, end:1143:6))"]
#[derive(Clone, Debug)]
struct sinc9Var2 {
    sinc10: Tablesinc10,
}
impl sinc9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc10 = if let Some((len, table)) =
            Tablesinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc9 {
    Var0(sinc9Var0),
    Var1(sinc9Var1),
    Var2(sinc9Var2),
}
impl Tablesinc9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 127) == 64 {
            if let Some((inst_len, parsed)) =
                sinc9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sinc9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sinc9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1145:1, end:1145:6))"]
#[derive(Clone, Debug)]
struct sinc8Var0 {}
impl sinc8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1144:1, end:1144:6))"]
#[derive(Clone, Debug)]
struct sinc8Var1 {
    sinc9: Tablesinc9,
}
impl sinc8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1146:1, end:1146:6))"]
#[derive(Clone, Debug)]
struct sinc8Var2 {
    sinc9: Tablesinc9,
}
impl sinc8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc8 {
    Var0(sinc8Var0),
    Var1(sinc8Var1),
    Var2(sinc8Var2),
}
impl Tablesinc8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 255) == 128 {
            if let Some((inst_len, parsed)) =
                sinc8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sinc8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sinc8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1148:1, end:1148:6))"]
#[derive(Clone, Debug)]
struct sinc7Var0 {}
impl sinc7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1147:1, end:1147:6))"]
#[derive(Clone, Debug)]
struct sinc7Var1 {
    sinc8: Tablesinc8,
}
impl sinc7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1149:1, end:1149:6))"]
#[derive(Clone, Debug)]
struct sinc7Var2 {
    sinc8: Tablesinc8,
}
impl sinc7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc7 {
    Var0(sinc7Var0),
    Var1(sinc7Var1),
    Var2(sinc7Var2),
}
impl Tablesinc7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sinc7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sinc7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1151:1, end:1151:6))"]
#[derive(Clone, Debug)]
struct sinc6Var0 {}
impl sinc6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1150:1, end:1150:6))"]
#[derive(Clone, Debug)]
struct sinc6Var1 {
    sinc7: Tablesinc7,
}
impl sinc6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1152:1, end:1152:6))"]
#[derive(Clone, Debug)]
struct sinc6Var2 {
    sinc7: Tablesinc7,
}
impl sinc6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc6 {
    Var0(sinc6Var0),
    Var1(sinc6Var1),
    Var2(sinc6Var2),
}
impl Tablesinc6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sinc6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sinc6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1154:1, end:1154:6))"]
#[derive(Clone, Debug)]
struct sinc5Var0 {}
impl sinc5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1153:1, end:1153:6))"]
#[derive(Clone, Debug)]
struct sinc5Var1 {
    sinc6: Tablesinc6,
}
impl sinc5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1155:1, end:1155:6))"]
#[derive(Clone, Debug)]
struct sinc5Var2 {
    sinc6: Tablesinc6,
}
impl sinc5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc5 {
    Var0(sinc5Var0),
    Var1(sinc5Var1),
    Var2(sinc5Var2),
}
impl Tablesinc5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 7) == 4 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sinc5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sinc5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1157:1, end:1157:6))"]
#[derive(Clone, Debug)]
struct sinc4Var0 {}
impl sinc4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1156:1, end:1156:6))"]
#[derive(Clone, Debug)]
struct sinc4Var1 {
    sinc5: Tablesinc5,
}
impl sinc4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1158:1, end:1158:6))"]
#[derive(Clone, Debug)]
struct sinc4Var2 {
    sinc5: Tablesinc5,
}
impl sinc4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc4 {
    Var0(sinc4Var0),
    Var1(sinc4Var1),
    Var2(sinc4Var2),
}
impl Tablesinc4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 8 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sinc4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sinc4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1160:1, end:1160:6))"]
#[derive(Clone, Debug)]
struct sinc3Var0 {}
impl sinc3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1159:1, end:1159:6))"]
#[derive(Clone, Debug)]
struct sinc3Var1 {
    sinc4: Tablesinc4,
}
impl sinc3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1161:1, end:1161:6))"]
#[derive(Clone, Debug)]
struct sinc3Var2 {
    sinc4: Tablesinc4,
}
impl sinc3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc3 {
    Var0(sinc3Var0),
    Var1(sinc3Var1),
    Var2(sinc3Var2),
}
impl Tablesinc3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 16 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sinc3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sinc3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1163:1, end:1163:6))"]
#[derive(Clone, Debug)]
struct sinc2Var0 {}
impl sinc2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1162:1, end:1162:6))"]
#[derive(Clone, Debug)]
struct sinc2Var1 {
    sinc3: Tablesinc3,
}
impl sinc2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1164:1, end:1164:6))"]
#[derive(Clone, Debug)]
struct sinc2Var2 {
    sinc3: Tablesinc3,
}
impl sinc2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc2 {
    Var0(sinc2Var0),
    Var1(sinc2Var1),
    Var2(sinc2Var2),
}
impl Tablesinc2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sinc2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sinc2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1166:1, end:1166:6))"]
#[derive(Clone, Debug)]
struct sinc1Var0 {}
impl sinc1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1165:1, end:1165:6))"]
#[derive(Clone, Debug)]
struct sinc1Var1 {
    sinc2: Tablesinc2,
}
impl sinc1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1167:1, end:1167:6))"]
#[derive(Clone, Debug)]
struct sinc1Var2 {
    sinc2: Tablesinc2,
}
impl sinc1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc1 {
    Var0(sinc1Var0),
    Var1(sinc1Var1),
    Var2(sinc1Var2),
}
impl Tablesinc1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 127) == 64 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sinc1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sinc1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sinc1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1169:1, end:1169:6))"]
#[derive(Clone, Debug)]
struct sinc0Var0 {}
impl sinc0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1168:1, end:1168:6))"]
#[derive(Clone, Debug)]
struct sinc0Var1 {
    sinc1: Tablesinc1,
}
impl sinc0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1170:1, end:1170:6))"]
#[derive(Clone, Debug)]
struct sinc0Var2 {
    sinc1: Tablesinc1,
}
impl sinc0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc0 {
    Var0(sinc0Var0),
    Var1(sinc0Var1),
    Var2(sinc0Var2),
}
impl Tablesinc0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 128 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sinc0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sinc0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sinc0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1171:1, end:1171:11))"]
#[derive(Clone, Debug)]
struct stlist_incVar0 {
    sinc0: Tablesinc0,
}
impl stlist_incVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.sinc0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc0 = if let Some((len, table)) =
            Tablesinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_inc {
    Var0(stlist_incVar0),
}
impl Tablestlist_inc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                stlist_incVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1175:1, end:1175:7))"]
#[derive(Clone, Debug)]
struct ldec15Var0 {}
impl ldec15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1176:1, end:1176:7))"]
#[derive(Clone, Debug)]
struct ldec15Var1 {}
impl ldec15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableldec15 {
    Var0(ldec15Var0),
    Var1(ldec15Var1),
}
impl Tableldec15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                ldec15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                ldec15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1178:1, end:1178:7))"]
#[derive(Clone, Debug)]
struct ldec14Var0 {}
impl ldec14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1177:1, end:1177:7))"]
#[derive(Clone, Debug)]
struct ldec14Var1 {
    ldec15: Tableldec15,
}
impl ldec14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec15 = if let Some((len, table)) =
            Tableldec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1179:1, end:1179:7))"]
#[derive(Clone, Debug)]
struct ldec14Var2 {
    ldec15: Tableldec15,
}
impl ldec14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec15 = if let Some((len, table)) =
            Tableldec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec14 {
    Var0(ldec14Var0),
    Var1(ldec14Var1),
    Var2(ldec14Var2),
}
impl Tableldec14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                ldec14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                ldec14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                ldec14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1181:1, end:1181:7))"]
#[derive(Clone, Debug)]
struct ldec13Var0 {}
impl ldec13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1180:1, end:1180:7))"]
#[derive(Clone, Debug)]
struct ldec13Var1 {
    ldec14: Tableldec14,
}
impl ldec13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec14 = if let Some((len, table)) =
            Tableldec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1182:1, end:1182:7))"]
#[derive(Clone, Debug)]
struct ldec13Var2 {
    ldec14: Tableldec14,
}
impl ldec13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec14 = if let Some((len, table)) =
            Tableldec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec13 {
    Var0(ldec13Var0),
    Var1(ldec13Var1),
    Var2(ldec13Var2),
}
impl Tableldec13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                ldec13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                ldec13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                ldec13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1184:1, end:1184:7))"]
#[derive(Clone, Debug)]
struct ldec12Var0 {}
impl ldec12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1183:1, end:1183:7))"]
#[derive(Clone, Debug)]
struct ldec12Var1 {
    ldec13: Tableldec13,
}
impl ldec12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r12),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec13 = if let Some((len, table)) =
            Tableldec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1185:1, end:1185:7))"]
#[derive(Clone, Debug)]
struct ldec12Var2 {
    ldec13: Tableldec13,
}
impl ldec12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec13 = if let Some((len, table)) =
            Tableldec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec12 {
    Var0(ldec12Var0),
    Var1(ldec12Var1),
    Var2(ldec12Var2),
}
impl Tableldec12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                ldec12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                ldec12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                ldec12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1187:1, end:1187:7))"]
#[derive(Clone, Debug)]
struct ldec11Var0 {}
impl ldec11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1186:1, end:1186:7))"]
#[derive(Clone, Debug)]
struct ldec11Var1 {
    ldec12: Tableldec12,
}
impl ldec11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r11),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec12 = if let Some((len, table)) =
            Tableldec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1188:1, end:1188:7))"]
#[derive(Clone, Debug)]
struct ldec11Var2 {
    ldec12: Tableldec12,
}
impl ldec11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec12 = if let Some((len, table)) =
            Tableldec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec11 {
    Var0(ldec11Var0),
    Var1(ldec11Var1),
    Var2(ldec11Var2),
}
impl Tableldec11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                ldec11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                ldec11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                ldec11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1190:1, end:1190:7))"]
#[derive(Clone, Debug)]
struct ldec10Var0 {}
impl ldec10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1189:1, end:1189:7))"]
#[derive(Clone, Debug)]
struct ldec10Var1 {
    ldec11: Tableldec11,
}
impl ldec10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r10),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec11 = if let Some((len, table)) =
            Tableldec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1191:1, end:1191:7))"]
#[derive(Clone, Debug)]
struct ldec10Var2 {
    ldec11: Tableldec11,
}
impl ldec10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec11 = if let Some((len, table)) =
            Tableldec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec10 {
    Var0(ldec10Var0),
    Var1(ldec10Var1),
    Var2(ldec10Var2),
}
impl Tableldec10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                ldec10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                ldec10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                ldec10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1193:1, end:1193:6))"]
#[derive(Clone, Debug)]
struct ldec9Var0 {}
impl ldec9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1192:1, end:1192:6))"]
#[derive(Clone, Debug)]
struct ldec9Var1 {
    ldec10: Tableldec10,
}
impl ldec9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r9),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec10 = if let Some((len, table)) =
            Tableldec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1194:1, end:1194:6))"]
#[derive(Clone, Debug)]
struct ldec9Var2 {
    ldec10: Tableldec10,
}
impl ldec9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec10 = if let Some((len, table)) =
            Tableldec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec9 {
    Var0(ldec9Var0),
    Var1(ldec9Var1),
    Var2(ldec9Var2),
}
impl Tableldec9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                ldec9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                ldec9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                ldec9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1196:1, end:1196:6))"]
#[derive(Clone, Debug)]
struct ldec8Var0 {}
impl ldec8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1195:1, end:1195:6))"]
#[derive(Clone, Debug)]
struct ldec8Var1 {
    ldec9: Tableldec9,
}
impl ldec8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r8),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1197:1, end:1197:6))"]
#[derive(Clone, Debug)]
struct ldec8Var2 {
    ldec9: Tableldec9,
}
impl ldec8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec8 {
    Var0(ldec8Var0),
    Var1(ldec8Var1),
    Var2(ldec8Var2),
}
impl Tableldec8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                ldec8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                ldec8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                ldec8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1199:1, end:1199:6))"]
#[derive(Clone, Debug)]
struct ldec7Var0 {}
impl ldec7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1198:1, end:1198:6))"]
#[derive(Clone, Debug)]
struct ldec7Var1 {
    ldec8: Tableldec8,
}
impl ldec7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r7),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1200:1, end:1200:6))"]
#[derive(Clone, Debug)]
struct ldec7Var2 {
    ldec8: Tableldec8,
}
impl ldec7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec7 {
    Var0(ldec7Var0),
    Var1(ldec7Var1),
    Var2(ldec7Var2),
}
impl Tableldec7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                ldec7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                ldec7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                ldec7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1202:1, end:1202:6))"]
#[derive(Clone, Debug)]
struct ldec6Var0 {}
impl ldec6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1201:1, end:1201:6))"]
#[derive(Clone, Debug)]
struct ldec6Var1 {
    ldec7: Tableldec7,
}
impl ldec6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1203:1, end:1203:6))"]
#[derive(Clone, Debug)]
struct ldec6Var2 {
    ldec7: Tableldec7,
}
impl ldec6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec6 {
    Var0(ldec6Var0),
    Var1(ldec6Var1),
    Var2(ldec6Var2),
}
impl Tableldec6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                ldec6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                ldec6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                ldec6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1205:1, end:1205:6))"]
#[derive(Clone, Debug)]
struct ldec5Var0 {}
impl ldec5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1204:1, end:1204:6))"]
#[derive(Clone, Debug)]
struct ldec5Var1 {
    ldec6: Tableldec6,
}
impl ldec5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1206:1, end:1206:6))"]
#[derive(Clone, Debug)]
struct ldec5Var2 {
    ldec6: Tableldec6,
}
impl ldec5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec5 {
    Var0(ldec5Var0),
    Var1(ldec5Var1),
    Var2(ldec5Var2),
}
impl Tableldec5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                ldec5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                ldec5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                ldec5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1208:1, end:1208:6))"]
#[derive(Clone, Debug)]
struct ldec4Var0 {}
impl ldec4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1207:1, end:1207:6))"]
#[derive(Clone, Debug)]
struct ldec4Var1 {
    ldec5: Tableldec5,
}
impl ldec4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1209:1, end:1209:6))"]
#[derive(Clone, Debug)]
struct ldec4Var2 {
    ldec5: Tableldec5,
}
impl ldec4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec4 {
    Var0(ldec4Var0),
    Var1(ldec4Var1),
    Var2(ldec4Var2),
}
impl Tableldec4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                ldec4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                ldec4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                ldec4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1211:1, end:1211:6))"]
#[derive(Clone, Debug)]
struct ldec3Var0 {}
impl ldec3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1210:1, end:1210:6))"]
#[derive(Clone, Debug)]
struct ldec3Var1 {
    ldec4: Tableldec4,
}
impl ldec3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1212:1, end:1212:6))"]
#[derive(Clone, Debug)]
struct ldec3Var2 {
    ldec4: Tableldec4,
}
impl ldec3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec3 {
    Var0(ldec3Var0),
    Var1(ldec3Var1),
    Var2(ldec3Var2),
}
impl Tableldec3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                ldec3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                ldec3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                ldec3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1214:1, end:1214:6))"]
#[derive(Clone, Debug)]
struct ldec2Var0 {}
impl ldec2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1213:1, end:1213:6))"]
#[derive(Clone, Debug)]
struct ldec2Var1 {
    ldec3: Tableldec3,
}
impl ldec2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1215:1, end:1215:6))"]
#[derive(Clone, Debug)]
struct ldec2Var2 {
    ldec3: Tableldec3,
}
impl ldec2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec2 {
    Var0(ldec2Var0),
    Var1(ldec2Var1),
    Var2(ldec2Var2),
}
impl Tableldec2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                ldec2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                ldec2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                ldec2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1217:1, end:1217:6))"]
#[derive(Clone, Debug)]
struct ldec1Var0 {}
impl ldec1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1216:1, end:1216:6))"]
#[derive(Clone, Debug)]
struct ldec1Var1 {
    ldec2: Tableldec2,
}
impl ldec1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1218:1, end:1218:6))"]
#[derive(Clone, Debug)]
struct ldec1Var2 {
    ldec2: Tableldec2,
}
impl ldec1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec1 {
    Var0(ldec1Var0),
    Var1(ldec1Var1),
    Var2(ldec1Var2),
}
impl Tableldec1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                ldec1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                ldec1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                ldec1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1220:1, end:1220:6))"]
#[derive(Clone, Debug)]
struct ldec0Var0 {}
impl ldec0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1219:1, end:1219:6))"]
#[derive(Clone, Debug)]
struct ldec0Var1 {
    ldec1: Tableldec1,
}
impl ldec0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1221:1, end:1221:6))"]
#[derive(Clone, Debug)]
struct ldec0Var2 {
    ldec1: Tableldec1,
}
impl ldec0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec0 {
    Var0(ldec0Var0),
    Var1(ldec0Var1),
    Var2(ldec0Var2),
}
impl Tableldec0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                ldec0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                ldec0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                ldec0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1222:1, end:1222:11))"]
#[derive(Clone, Debug)]
struct ldlist_decVar0 {
    ldec0: Tableldec0,
}
impl ldlist_decVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldec0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec0 = if let Some((len, table)) =
            Tableldec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_dec {
    Var0(ldlist_decVar0),
}
impl Tableldlist_dec {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ldlist_decVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1225:1, end:1225:7))"]
#[derive(Clone, Debug)]
struct sdec15Var0 {}
impl sdec15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1226:1, end:1226:7))"]
#[derive(Clone, Debug)]
struct sdec15Var1 {}
impl sdec15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec15 {
    Var0(sdec15Var0),
    Var1(sdec15Var1),
}
impl Tablesdec15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sdec15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sdec15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1228:1, end:1228:7))"]
#[derive(Clone, Debug)]
struct sdec14Var0 {}
impl sdec14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1227:1, end:1227:7))"]
#[derive(Clone, Debug)]
struct sdec14Var1 {
    sdec15: Tablesdec15,
}
impl sdec14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec15 = if let Some((len, table)) =
            Tablesdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1229:1, end:1229:7))"]
#[derive(Clone, Debug)]
struct sdec14Var2 {
    sdec15: Tablesdec15,
}
impl sdec14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec15 = if let Some((len, table)) =
            Tablesdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec14 {
    Var0(sdec14Var0),
    Var1(sdec14Var1),
    Var2(sdec14Var2),
}
impl Tablesdec14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                sdec14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sdec14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sdec14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1231:1, end:1231:7))"]
#[derive(Clone, Debug)]
struct sdec13Var0 {}
impl sdec13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1230:1, end:1230:7))"]
#[derive(Clone, Debug)]
struct sdec13Var1 {
    sdec14: Tablesdec14,
}
impl sdec13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec14 = if let Some((len, table)) =
            Tablesdec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1232:1, end:1232:7))"]
#[derive(Clone, Debug)]
struct sdec13Var2 {
    sdec14: Tablesdec14,
}
impl sdec13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec14 = if let Some((len, table)) =
            Tablesdec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec13 {
    Var0(sdec13Var0),
    Var1(sdec13Var1),
    Var2(sdec13Var2),
}
impl Tablesdec13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                sdec13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sdec13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sdec13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1234:1, end:1234:7))"]
#[derive(Clone, Debug)]
struct sdec12Var0 {}
impl sdec12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1233:1, end:1233:7))"]
#[derive(Clone, Debug)]
struct sdec12Var1 {
    sdec13: Tablesdec13,
}
impl sdec12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r12),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec13 = if let Some((len, table)) =
            Tablesdec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1235:1, end:1235:7))"]
#[derive(Clone, Debug)]
struct sdec12Var2 {
    sdec13: Tablesdec13,
}
impl sdec12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec13 = if let Some((len, table)) =
            Tablesdec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec12 {
    Var0(sdec12Var0),
    Var1(sdec12Var1),
    Var2(sdec12Var2),
}
impl Tablesdec12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                sdec12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sdec12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sdec12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1237:1, end:1237:7))"]
#[derive(Clone, Debug)]
struct sdec11Var0 {}
impl sdec11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1236:1, end:1236:7))"]
#[derive(Clone, Debug)]
struct sdec11Var1 {
    sdec12: Tablesdec12,
}
impl sdec11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r11),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec12 = if let Some((len, table)) =
            Tablesdec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1238:1, end:1238:7))"]
#[derive(Clone, Debug)]
struct sdec11Var2 {
    sdec12: Tablesdec12,
}
impl sdec11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec12 = if let Some((len, table)) =
            Tablesdec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec11 {
    Var0(sdec11Var0),
    Var1(sdec11Var1),
    Var2(sdec11Var2),
}
impl Tablesdec11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                sdec11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sdec11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sdec11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1240:1, end:1240:7))"]
#[derive(Clone, Debug)]
struct sdec10Var0 {}
impl sdec10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1239:1, end:1239:7))"]
#[derive(Clone, Debug)]
struct sdec10Var1 {
    sdec11: Tablesdec11,
}
impl sdec10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r10),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec11 = if let Some((len, table)) =
            Tablesdec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1241:1, end:1241:7))"]
#[derive(Clone, Debug)]
struct sdec10Var2 {
    sdec11: Tablesdec11,
}
impl sdec10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec11 = if let Some((len, table)) =
            Tablesdec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec10 {
    Var0(sdec10Var0),
    Var1(sdec10Var1),
    Var2(sdec10Var2),
}
impl Tablesdec10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                sdec10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sdec10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sdec10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1243:1, end:1243:6))"]
#[derive(Clone, Debug)]
struct sdec9Var0 {}
impl sdec9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1242:1, end:1242:6))"]
#[derive(Clone, Debug)]
struct sdec9Var1 {
    sdec10: Tablesdec10,
}
impl sdec9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r9),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec10 = if let Some((len, table)) =
            Tablesdec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1244:1, end:1244:6))"]
#[derive(Clone, Debug)]
struct sdec9Var2 {
    sdec10: Tablesdec10,
}
impl sdec9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec10 = if let Some((len, table)) =
            Tablesdec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec9 {
    Var0(sdec9Var0),
    Var1(sdec9Var1),
    Var2(sdec9Var2),
}
impl Tablesdec9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                sdec9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sdec9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sdec9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1246:1, end:1246:6))"]
#[derive(Clone, Debug)]
struct sdec8Var0 {}
impl sdec8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1245:1, end:1245:6))"]
#[derive(Clone, Debug)]
struct sdec8Var1 {
    sdec9: Tablesdec9,
}
impl sdec8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r8),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1247:1, end:1247:6))"]
#[derive(Clone, Debug)]
struct sdec8Var2 {
    sdec9: Tablesdec9,
}
impl sdec8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec8 {
    Var0(sdec8Var0),
    Var1(sdec8Var1),
    Var2(sdec8Var2),
}
impl Tablesdec8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                sdec8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sdec8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sdec8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1249:1, end:1249:6))"]
#[derive(Clone, Debug)]
struct sdec7Var0 {}
impl sdec7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1248:1, end:1248:6))"]
#[derive(Clone, Debug)]
struct sdec7Var1 {
    sdec8: Tablesdec8,
}
impl sdec7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r7),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1250:1, end:1250:6))"]
#[derive(Clone, Debug)]
struct sdec7Var2 {
    sdec8: Tablesdec8,
}
impl sdec7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec7 {
    Var0(sdec7Var0),
    Var1(sdec7Var1),
    Var2(sdec7Var2),
}
impl Tablesdec7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                sdec7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sdec7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sdec7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1252:1, end:1252:6))"]
#[derive(Clone, Debug)]
struct sdec6Var0 {}
impl sdec6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1251:1, end:1251:6))"]
#[derive(Clone, Debug)]
struct sdec6Var1 {
    sdec7: Tablesdec7,
}
impl sdec6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1253:1, end:1253:6))"]
#[derive(Clone, Debug)]
struct sdec6Var2 {
    sdec7: Tablesdec7,
}
impl sdec6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec6 {
    Var0(sdec6Var0),
    Var1(sdec6Var1),
    Var2(sdec6Var2),
}
impl Tablesdec6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                sdec6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sdec6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sdec6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1255:1, end:1255:6))"]
#[derive(Clone, Debug)]
struct sdec5Var0 {}
impl sdec5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1254:1, end:1254:6))"]
#[derive(Clone, Debug)]
struct sdec5Var1 {
    sdec6: Tablesdec6,
}
impl sdec5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1256:1, end:1256:6))"]
#[derive(Clone, Debug)]
struct sdec5Var2 {
    sdec6: Tablesdec6,
}
impl sdec5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec5 {
    Var0(sdec5Var0),
    Var1(sdec5Var1),
    Var2(sdec5Var2),
}
impl Tablesdec5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                sdec5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sdec5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sdec5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1258:1, end:1258:6))"]
#[derive(Clone, Debug)]
struct sdec4Var0 {}
impl sdec4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1257:1, end:1257:6))"]
#[derive(Clone, Debug)]
struct sdec4Var1 {
    sdec5: Tablesdec5,
}
impl sdec4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1259:1, end:1259:6))"]
#[derive(Clone, Debug)]
struct sdec4Var2 {
    sdec5: Tablesdec5,
}
impl sdec4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec4 {
    Var0(sdec4Var0),
    Var1(sdec4Var1),
    Var2(sdec4Var2),
}
impl Tablesdec4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                sdec4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sdec4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sdec4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1261:1, end:1261:6))"]
#[derive(Clone, Debug)]
struct sdec3Var0 {}
impl sdec3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1260:1, end:1260:6))"]
#[derive(Clone, Debug)]
struct sdec3Var1 {
    sdec4: Tablesdec4,
}
impl sdec3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1262:1, end:1262:6))"]
#[derive(Clone, Debug)]
struct sdec3Var2 {
    sdec4: Tablesdec4,
}
impl sdec3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec3 {
    Var0(sdec3Var0),
    Var1(sdec3Var1),
    Var2(sdec3Var2),
}
impl Tablesdec3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                sdec3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sdec3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sdec3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1264:1, end:1264:6))"]
#[derive(Clone, Debug)]
struct sdec2Var0 {}
impl sdec2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1263:1, end:1263:6))"]
#[derive(Clone, Debug)]
struct sdec2Var1 {
    sdec3: Tablesdec3,
}
impl sdec2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1265:1, end:1265:6))"]
#[derive(Clone, Debug)]
struct sdec2Var2 {
    sdec3: Tablesdec3,
}
impl sdec2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec2 {
    Var0(sdec2Var0),
    Var1(sdec2Var1),
    Var2(sdec2Var2),
}
impl Tablesdec2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                sdec2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sdec2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sdec2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1267:1, end:1267:6))"]
#[derive(Clone, Debug)]
struct sdec1Var0 {}
impl sdec1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1266:1, end:1266:6))"]
#[derive(Clone, Debug)]
struct sdec1Var1 {
    sdec2: Tablesdec2,
}
impl sdec1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1268:1, end:1268:6))"]
#[derive(Clone, Debug)]
struct sdec1Var2 {
    sdec2: Tablesdec2,
}
impl sdec1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec1 {
    Var0(sdec1Var0),
    Var1(sdec1Var1),
    Var2(sdec1Var2),
}
impl Tablesdec1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                sdec1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sdec1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sdec1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1270:1, end:1270:6))"]
#[derive(Clone, Debug)]
struct sdec0Var0 {}
impl sdec0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1269:1, end:1269:6))"]
#[derive(Clone, Debug)]
struct sdec0Var1 {
    sdec1: Tablesdec1,
}
impl sdec0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1271:1, end:1271:6))"]
#[derive(Clone, Debug)]
struct sdec0Var2 {
    sdec1: Tablesdec1,
}
impl sdec0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec0 {
    Var0(sdec0Var0),
    Var1(sdec0Var1),
    Var2(sdec0Var2),
}
impl Tablesdec0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                sdec0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sdec0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sdec0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1273:1, end:1273:11))"]
#[derive(Clone, Debug)]
struct stlist_decVar0 {
    sdec0: Tablesdec0,
}
impl stlist_decVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.sdec0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec0 = if let Some((len, table)) =
            Tablesdec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_dec {
    Var0(stlist_decVar0),
}
impl Tablestlist_dec {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                stlist_decVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1278:1, end:1278:8))"]
#[derive(Clone, Debug)]
struct reglistVar0 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1283:1, end:1283:8))"]
#[derive(Clone, Debug)]
struct reglistVar1 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1288:1, end:1288:8))"]
#[derive(Clone, Debug)]
struct reglistVar2 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1293:1, end:1293:8))"]
#[derive(Clone, Debug)]
struct reglistVar3 {
    ldlist_inc: Tableldlist_inc,
    rn: Tablern,
}
impl reglistVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1298:1, end:1298:8))"]
#[derive(Clone, Debug)]
struct reglistVar4 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1303:1, end:1303:8))"]
#[derive(Clone, Debug)]
struct reglistVar5 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1308:1, end:1308:8))"]
#[derive(Clone, Debug)]
struct reglistVar6 {
    ldlist_inc: Tableldlist_inc,
    rn: Tablern,
}
impl reglistVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1313:1, end:1313:8))"]
#[derive(Clone, Debug)]
struct reglistVar7 {
    ldlist_inc: Tableldlist_inc,
    rn: Tablern,
}
impl reglistVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1318:1, end:1318:8))"]
#[derive(Clone, Debug)]
struct reglistVar8 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1323:1, end:1323:8))"]
#[derive(Clone, Debug)]
struct reglistVar9 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1328:1, end:1328:8))"]
#[derive(Clone, Debug)]
struct reglistVar10 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1333:1, end:1333:8))"]
#[derive(Clone, Debug)]
struct reglistVar11 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1338:1, end:1338:8))"]
#[derive(Clone, Debug)]
struct reglistVar12 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1343:1, end:1343:8))"]
#[derive(Clone, Debug)]
struct reglistVar13 {
    ldlist_dec: Tableldlist_dec,
    rn: Tablern,
}
impl reglistVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1348:1, end:1348:8))"]
#[derive(Clone, Debug)]
struct reglistVar14 {
    ldlist_dec: Tableldlist_dec,
    rn: Tablern,
}
impl reglistVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1353:1, end:1353:8))"]
#[derive(Clone, Debug)]
struct reglistVar15 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1358:1, end:1358:8))"]
#[derive(Clone, Debug)]
struct reglistVar16 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1363:1, end:1363:8))"]
#[derive(Clone, Debug)]
struct reglistVar17 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1374:1, end:1374:8))"]
#[derive(Clone, Debug)]
struct reglistVar18 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1380:1, end:1380:8))"]
#[derive(Clone, Debug)]
struct reglistVar19 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1385:1, end:1385:8))"]
#[derive(Clone, Debug)]
struct reglistVar20 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1390:1, end:1390:8))"]
#[derive(Clone, Debug)]
struct reglistVar21 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1395:1, end:1395:8))"]
#[derive(Clone, Debug)]
struct reglistVar22 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1400:1, end:1400:8))"]
#[derive(Clone, Debug)]
struct reglistVar23 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1405:1, end:1405:8))"]
#[derive(Clone, Debug)]
struct reglistVar24 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1410:1, end:1410:8))"]
#[derive(Clone, Debug)]
struct reglistVar25 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1415:1, end:1415:8))"]
#[derive(Clone, Debug)]
struct reglistVar26 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1420:1, end:1420:8))"]
#[derive(Clone, Debug)]
struct reglistVar27 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1425:1, end:1425:8))"]
#[derive(Clone, Debug)]
struct reglistVar28 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[derive(Clone, Debug)]
enum Tablereglist {
    Var0(reglistVar0),
    Var1(reglistVar1),
    Var2(reglistVar2),
    Var3(reglistVar3),
    Var4(reglistVar4),
    Var5(reglistVar5),
    Var6(reglistVar6),
    Var7(reglistVar7),
    Var8(reglistVar8),
    Var9(reglistVar9),
    Var10(reglistVar10),
    Var11(reglistVar11),
    Var12(reglistVar12),
    Var13(reglistVar13),
    Var14(reglistVar14),
    Var15(reglistVar15),
    Var16(reglistVar16),
    Var17(reglistVar17),
    Var18(reglistVar18),
    Var19(reglistVar19),
    Var20(reglistVar20),
    Var21(reglistVar21),
    Var22(reglistVar22),
    Var23(reglistVar23),
    Var24(reglistVar24),
    Var25(reglistVar25),
    Var26(reglistVar26),
    Var27(reglistVar27),
    Var28(reglistVar28),
}
impl Tablereglist {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                reglistVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                reglistVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                reglistVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 240 {
            if let Some((inst_len, parsed)) =
                reglistVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                reglistVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                reglistVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                reglistVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 240 {
            if let Some((inst_len, parsed)) =
                reglistVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                reglistVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                reglistVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                reglistVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                reglistVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                reglistVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                reglistVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                reglistVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                reglistVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                reglistVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                reglistVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 224 {
            if let Some((inst_len, parsed)) =
                reglistVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                reglistVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                reglistVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                reglistVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                reglistVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                reglistVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                reglistVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                reglistVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                reglistVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                reglistVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                reglistVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1431:1, end:1431:5))"]
#[derive(Clone, Debug)]
struct mdirVar0 {}
impl mdirVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ia")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1432:1, end:1432:5))"]
#[derive(Clone, Debug)]
struct mdirVar1 {}
impl mdirVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ib")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1433:1, end:1433:5))"]
#[derive(Clone, Debug)]
struct mdirVar2 {}
impl mdirVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("da")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1434:1, end:1434:5))"]
#[derive(Clone, Debug)]
struct mdirVar3 {}
impl mdirVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("db")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablemdir {
    Var0(mdirVar0),
    Var1(mdirVar1),
    Var2(mdirVar2),
    Var3(mdirVar3),
}
impl Tablemdir {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                mdirVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                mdirVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                mdirVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                mdirVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1439:1, end:1439:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var0 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = i128::try_from(self.immed).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1440:1, end:1440:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var1 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-i128::try_from(self.immed).unwrap().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1441:1, end:1441:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var2 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = i128::try_from(self.immed).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1442:1, end:1442:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var3 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-i128::try_from(self.immed).unwrap().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1443:1, end:1443:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var4 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = i128::try_from(self.immed).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1444:1, end:1444:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var5 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-i128::try_from(self.immed).unwrap().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1445:1, end:1445:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var6 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("],{"),
            DisplayElement::Number(true, false, self.immed as u64),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode5 {
    Var0(addrmode5Var0),
    Var1(addrmode5Var1),
    Var2(addrmode5Var2),
    Var3(addrmode5Var3),
    Var4(addrmode5Var4),
    Var5(addrmode5Var5),
    Var6(addrmode5Var6),
}
impl Tableaddrmode5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode5Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode5Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode5Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode5Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1449:1, end:1449:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar0 {}
impl cpsrmaskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1450:1, end:1450:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar1 {}
impl cpsrmaskVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1451:1, end:1451:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar2 {}
impl cpsrmaskVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1452:1, end:1452:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar3 {}
impl cpsrmaskVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1453:1, end:1453:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar4 {}
impl cpsrmaskVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1454:1, end:1454:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar5 {}
impl cpsrmaskVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1455:1, end:1455:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar6 {}
impl cpsrmaskVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1456:1, end:1456:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar7 {}
impl cpsrmaskVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1457:1, end:1457:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar8 {}
impl cpsrmaskVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1458:1, end:1458:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar9 {}
impl cpsrmaskVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1459:1, end:1459:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar10 {}
impl cpsrmaskVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1460:1, end:1460:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar11 {}
impl cpsrmaskVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1461:1, end:1461:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar12 {}
impl cpsrmaskVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1462:1, end:1462:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar13 {}
impl cpsrmaskVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1463:1, end:1463:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar14 {}
impl cpsrmaskVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1464:1, end:1464:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar15 {}
impl cpsrmaskVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecpsrmask {
    Var0(cpsrmaskVar0),
    Var1(cpsrmaskVar1),
    Var2(cpsrmaskVar2),
    Var3(cpsrmaskVar3),
    Var4(cpsrmaskVar4),
    Var5(cpsrmaskVar5),
    Var6(cpsrmaskVar6),
    Var7(cpsrmaskVar7),
    Var8(cpsrmaskVar8),
    Var9(cpsrmaskVar9),
    Var10(cpsrmaskVar10),
    Var11(cpsrmaskVar11),
    Var12(cpsrmaskVar12),
    Var13(cpsrmaskVar13),
    Var14(cpsrmaskVar14),
    Var15(cpsrmaskVar15),
}
impl Tablecpsrmask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 14 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1468:1, end:1468:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar0 {}
impl spsrmaskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1469:1, end:1469:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar1 {}
impl spsrmaskVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1470:1, end:1470:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar2 {}
impl spsrmaskVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1471:1, end:1471:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar3 {}
impl spsrmaskVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1472:1, end:1472:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar4 {}
impl spsrmaskVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1473:1, end:1473:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar5 {}
impl spsrmaskVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1474:1, end:1474:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar6 {}
impl spsrmaskVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1475:1, end:1475:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar7 {}
impl spsrmaskVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1476:1, end:1476:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar8 {}
impl spsrmaskVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1477:1, end:1477:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar9 {}
impl spsrmaskVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1478:1, end:1478:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar10 {}
impl spsrmaskVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1479:1, end:1479:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar11 {}
impl spsrmaskVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1480:1, end:1480:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar12 {}
impl spsrmaskVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1481:1, end:1481:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar13 {}
impl spsrmaskVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1482:1, end:1482:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar14 {}
impl spsrmaskVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1483:1, end:1483:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar15 {}
impl spsrmaskVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablespsrmask {
    Var0(spsrmaskVar0),
    Var1(spsrmaskVar1),
    Var2(spsrmaskVar2),
    Var3(spsrmaskVar3),
    Var4(spsrmaskVar4),
    Var5(spsrmaskVar5),
    Var6(spsrmaskVar6),
    Var7(spsrmaskVar7),
    Var8(spsrmaskVar8),
    Var9(spsrmaskVar9),
    Var10(spsrmaskVar10),
    Var11(spsrmaskVar11),
    Var12(spsrmaskVar12),
    Var13(spsrmaskVar13),
    Var14(spsrmaskVar14),
    Var15(spsrmaskVar15),
}
impl Tablespsrmask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 14 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1570:1, end:1570:10))"]
#[derive(Clone, Debug)]
struct immed12_4Var0 {
    immed12: u16,
    immed4: u8,
}
impl immed12_4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immed12).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immed4).unwrap());
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 4;
        calc_tmp = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_15(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let immed4 = token_11(tokens_current);
        let immed12 = token_15(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed12, immed4 }))
    }
}
#[derive(Clone, Debug)]
enum Tableimmed12_4 {
    Var0(immed12_4Var0),
}
impl Tableimmed12_4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && context_param.0 & 33554433 == 33554432 {
            if let Some((inst_len, parsed)) =
                immed12_4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1984:1, end:1984:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var0 {
    immed: u8,
    rotate: u8,
}
impl ArmPCRelImmed12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(
                    32i128.wrapping_sub(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128)),
                )
                .ok()
                .and_then(|shl| i128::try_from(self.immed).unwrap().checked_shl(shl))
                .unwrap_or(0)
                    | u32::try_from(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128))
                        .ok()
                        .and_then(|shr| i128::try_from(self.immed).unwrap().checked_shr(shr))
                        .unwrap_or(0))
                    & 4294967295i128),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloff.is_negative(),
            calc_reloff.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_25(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0)
                    | u32::try_from(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .and_then(|shr| {
                        i128::try_from(token_25(tokens_current))
                            .unwrap()
                            .checked_shr(shr)
                    })
                    .unwrap_or(0))
                    & 4294967295i128),
            );
        let immed = token_25(tokens_current);
        let rotate = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1990:1, end:1990:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var1 {
    immed: u8,
    rotate: u8,
}
impl ArmPCRelImmed12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(
                    32i128.wrapping_sub(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128)),
                )
                .ok()
                .and_then(|shl| i128::try_from(self.immed).unwrap().checked_shl(shl))
                .unwrap_or(0)
                    | u32::try_from(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128))
                        .ok()
                        .and_then(|shr| i128::try_from(self.immed).unwrap().checked_shr(shr))
                        .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloff.is_negative(),
            calc_reloff.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_25(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0)
                    | u32::try_from(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .and_then(|shr| {
                        i128::try_from(token_25(tokens_current))
                            .unwrap()
                            .checked_shr(shr)
                    })
                    .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let immed = token_25(tokens_current);
        let rotate = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum TableArmPCRelImmed12 {
    Var0(ArmPCRelImmed12Var0),
    Var1(ArmPCRelImmed12Var1),
}
impl TableArmPCRelImmed12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                ArmPCRelImmed12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                ArmPCRelImmed12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:269:1, end:269:5))"]
#[derive(Clone, Debug)]
struct thccVar0 {}
impl thccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:270:1, end:270:5))"]
#[derive(Clone, Debug)]
struct thccVar1 {}
impl thccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:271:1, end:271:5))"]
#[derive(Clone, Debug)]
struct thccVar2 {}
impl thccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:272:1, end:272:5))"]
#[derive(Clone, Debug)]
struct thccVar3 {}
impl thccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:273:1, end:273:5))"]
#[derive(Clone, Debug)]
struct thccVar4 {}
impl thccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:274:1, end:274:5))"]
#[derive(Clone, Debug)]
struct thccVar5 {}
impl thccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:275:1, end:275:5))"]
#[derive(Clone, Debug)]
struct thccVar6 {}
impl thccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:276:1, end:276:5))"]
#[derive(Clone, Debug)]
struct thccVar7 {}
impl thccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:277:1, end:277:5))"]
#[derive(Clone, Debug)]
struct thccVar8 {}
impl thccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:278:1, end:278:5))"]
#[derive(Clone, Debug)]
struct thccVar9 {}
impl thccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:279:1, end:279:5))"]
#[derive(Clone, Debug)]
struct thccVar10 {}
impl thccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:280:1, end:280:5))"]
#[derive(Clone, Debug)]
struct thccVar11 {}
impl thccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:281:1, end:281:5))"]
#[derive(Clone, Debug)]
struct thccVar12 {}
impl thccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:282:1, end:282:5))"]
#[derive(Clone, Debug)]
struct thccVar13 {}
impl thccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablethcc {
    Var0(thccVar0),
    Var1(thccVar1),
    Var2(thccVar2),
    Var3(thccVar3),
    Var4(thccVar4),
    Var5(thccVar5),
    Var6(thccVar6),
    Var7(thccVar7),
    Var8(thccVar8),
    Var9(thccVar9),
    Var10(thccVar10),
    Var11(thccVar11),
    Var12(thccVar12),
    Var13(thccVar13),
}
impl Tablethcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                thccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                thccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                thccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                thccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                thccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                thccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                thccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                thccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                thccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                thccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                thccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                thccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                thccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                thccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:353:1, end:353:8))"]
#[derive(Clone, Debug)]
struct Hrd0002Var0 {}
impl Hrd0002Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:351:1, end:351:8))"]
#[derive(Clone, Debug)]
struct Hrd0002Var1 {
    Rd0002: u8,
}
impl Hrd0002Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rd0002)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rd0002 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:352:1, end:352:8))"]
#[derive(Clone, Debug)]
struct Hrd0002Var2 {
    hrd0002: u8,
}
impl Hrd0002Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_7_display(self.hrd0002)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let hrd0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hrd0002 }))
    }
}
#[derive(Clone, Debug)]
enum TableHrd0002 {
    Var0(Hrd0002Var0),
    Var1(Hrd0002Var1),
    Var2(Hrd0002Var2),
}
impl TableHrd0002 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 135) == 135 {
            if let Some((inst_len, parsed)) =
                Hrd0002Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                Hrd0002Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                Hrd0002Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:357:1, end:357:8))"]
#[derive(Clone, Debug)]
struct Hrn0002Var0 {}
impl Hrn0002Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:355:1, end:355:8))"]
#[derive(Clone, Debug)]
struct Hrn0002Var1 {
    Rn0002: u8,
}
impl Hrn0002Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0002)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0002 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:356:1, end:356:8))"]
#[derive(Clone, Debug)]
struct Hrn0002Var2 {
    hrn0002: u8,
}
impl Hrn0002Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_7_display(self.hrn0002)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let hrn0002 = token_150(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hrn0002 }))
    }
}
#[derive(Clone, Debug)]
enum TableHrn0002 {
    Var0(Hrn0002Var0),
    Var1(Hrn0002Var1),
    Var2(Hrn0002Var2),
}
impl TableHrn0002 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 135) == 135 {
            if let Some((inst_len, parsed)) =
                Hrn0002Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                Hrn0002Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                Hrn0002Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:361:1, end:361:8))"]
#[derive(Clone, Debug)]
struct Hrm0305Var0 {}
impl Hrm0305Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:359:1, end:359:8))"]
#[derive(Clone, Debug)]
struct Hrm0305Var1 {
    Rm0305: u8,
}
impl Hrm0305Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rm0305)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rm0305 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:360:1, end:360:8))"]
#[derive(Clone, Debug)]
struct Hrm0305Var2 {
    hrm0305: u8,
}
impl Hrm0305Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_7_display(self.hrm0305)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let hrm0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { hrm0305 }))
    }
}
#[derive(Clone, Debug)]
enum TableHrm0305 {
    Var0(Hrm0305Var0),
    Var1(Hrm0305Var1),
    Var2(Hrm0305Var2),
}
impl TableHrm0305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 120) == 120 {
            if let Some((inst_len, parsed)) =
                Hrm0305Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                Hrm0305Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                Hrm0305Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:368:1, end:368:7))"]
#[derive(Clone, Debug)]
struct Immed8Var0 {
    immed8: u8,
}
impl Immed8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.immed8 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed8 {
    Var0(Immed8Var0),
}
impl TableImmed8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Immed8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:369:1, end:369:7))"]
#[derive(Clone, Debug)]
struct Immed3Var0 {
    immed3: u8,
}
impl Immed3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.immed3 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let immed3 = token_147(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed3 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed3 {
    Var0(Immed3Var0),
}
impl TableImmed3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Immed3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:371:1, end:371:7))"]
#[derive(Clone, Debug)]
struct Pcrel8Var0 {
    immed8: u8,
}
impl Pcrel8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(self.immed8).unwrap()));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloc.is_negative(), calc_reloc.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_149(tokens_current)).unwrap()));
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TablePcrel8 {
    Var0(Pcrel8Var0),
}
impl TablePcrel8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Pcrel8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:388:1, end:388:7))"]
#[derive(Clone, Debug)]
struct Sprel8Var0 {
    immed8: u8,
}
impl Sprel8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_immval: i128 = 0;
        calc_immval = i128::try_from(self.immed8).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_immval.is_negative(), calc_immval.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2;
        calc_immval = i128::try_from(token_149(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSprel8 {
    Var0(Sprel8Var0),
}
impl TableSprel8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Sprel8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:389:1, end:389:9))"]
#[derive(Clone, Debug)]
struct Immed7_4Var0 {
    immed7: u8,
}
impl Immed7_4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_immval: i128 = 0;
        calc_immval = i128::try_from(self.immed7).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_immval.is_negative(), calc_immval.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2;
        calc_immval = i128::try_from(token_156(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let immed7 = token_156(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed7 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed7_4 {
    Var0(Immed7_4Var0),
}
impl TableImmed7_4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Immed7_4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:390:1, end:390:7))"]
#[derive(Clone, Debug)]
struct Immed5Var0 {
    immed5: u8,
}
impl Immed5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.immed5 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let immed5 = token_148(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableImmed5 {
    Var0(Immed5Var0),
}
impl TableImmed5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Immed5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:534:1, end:534:6))"]
#[derive(Clone, Debug)]
struct Addr5Var0 {
    thc0909: u8,
    imm5: u8,
}
impl Addr5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (u32::try_from(6i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.thc0909).unwrap().checked_shl(shl))
                    .unwrap_or(0)
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.imm5).unwrap().checked_shl(shl))
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (u32::try_from(6i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_133(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_161(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)),
            );
        let imm5 = token_161(tokens_current);
        let thc0909 = token_133(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thc0909, imm5 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr5 {
    Var0(Addr5Var0),
}
impl TableAddr5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Addr5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:540:1, end:540:6))"]
#[derive(Clone, Debug)]
struct Addr8Var0 {
    soffset8: u8,
}
impl Addr8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.soffset8 & 128 != 0 {
                            -1 & !127
                        } else {
                            0
                        } | self.soffset8 as i8),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_149(tokens_current)).unwrap()));
        let soffset8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { soffset8 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr8 {
    Var0(Addr8Var0),
}
impl TableAddr8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Addr8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:546:1, end:546:7))"]
#[derive(Clone, Debug)]
struct Addr11Var0 {
    soffset11: u16,
}
impl Addr11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                2i128.wrapping_mul(
                    i128::try_from(
                        (if self.soffset11 & 1024 != 0 {
                            -1 & !1023
                        } else {
                            0
                        } | self.soffset11 as i16),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(2i128.wrapping_mul(i128::try_from(token_125(tokens_current)).unwrap()));
        let soffset11 = token_125(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { soffset11 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr11 {
    Var0(Addr11Var0),
}
impl TableAddr11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Addr11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:568:1, end:568:9))"]
#[derive(Clone, Debug)]
struct ThAddr24Var0 {
    part2J1: u8,
    part2J2: u8,
    offset10: u16,
    part2off: u16,
}
impl ThAddr24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .and_then(|shl| {
                        (i128::try_from(self.part2J1).unwrap() ^ 1i128).checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| {
                            (i128::try_from(self.part2J2).unwrap() ^ 1i128).checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.offset10).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2off).unwrap().checked_shl(shl))
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        let offset10 = token_126(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .and_then(|shl| {
                        (i128::try_from(token_120(tokens_current)).unwrap() ^ 1i128)
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| {
                            (i128::try_from(token_121(tokens_current)).unwrap() ^ 1i128)
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_126(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_125(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)),
            );
        let part2off = token_125(tokens_current);
        let part2J1 = token_120(tokens_current);
        let part2J2 = token_121(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                part2J1,
                part2J2,
                offset10,
                part2off,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:574:1, end:574:9))"]
#[derive(Clone, Debug)]
struct ThAddr24Var1 {
    part2J1: u8,
    part2J2: u8,
    offset10: u16,
    part2off: u16,
}
impl ThAddr24Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .and_then(|shl| (-1i128).checked_shl(shl))
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2J1).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2J2).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.offset10).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2off).unwrap().checked_shl(shl))
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        let offset10 = token_126(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .and_then(|shl| (-1i128).checked_shl(shl))
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_120(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_121(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_126(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_125(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)),
            );
        let part2J2 = token_121(tokens_current);
        let part2J1 = token_120(tokens_current);
        let part2off = token_125(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                part2J1,
                part2J2,
                offset10,
                part2off,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableThAddr24 {
    Var0(ThAddr24Var0),
    Var1(ThAddr24Var1),
}
impl TableThAddr24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                ThAddr24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                ThAddr24Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:582:1, end:582:12))"]
#[derive(Clone, Debug)]
struct ThArmAddr23Var0 {
    part2J1: u8,
    part2J2: u8,
    offset10: u16,
    part2off_10: u16,
}
impl ThArmAddr23Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .and_then(|shl| {
                        (i128::try_from(self.part2J1).unwrap() ^ 1i128).checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| {
                            (i128::try_from(self.part2J2).unwrap() ^ 1i128).checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.offset10).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2off_10).unwrap().checked_shl(shl))
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        let offset10 = token_126(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(
                (((u32::try_from(23i128)
                    .ok()
                    .and_then(|shl| {
                        (i128::try_from(token_120(tokens_current)).unwrap() ^ 1i128)
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| {
                            (i128::try_from(token_121(tokens_current)).unwrap() ^ 1i128)
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_126(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_127(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)),
            );
        let part2off_10 = token_127(tokens_current);
        let part2J1 = token_120(tokens_current);
        let part2J2 = token_121(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                part2J1,
                part2J2,
                offset10,
                part2off_10,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:588:1, end:588:12))"]
#[derive(Clone, Debug)]
struct ThArmAddr23Var1 {
    part2J1: u8,
    part2J2: u8,
    offset10: u16,
    part2off_10: u16,
}
impl ThArmAddr23Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .and_then(|shl| (-1i128).checked_shl(shl))
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2J1).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2J2).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.offset10).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.part2off_10).unwrap().checked_shl(shl))
                        .unwrap_or(0)),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        let offset10 = token_126(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(
                ((((u32::try_from(24i128)
                    .ok()
                    .and_then(|shl| (-1i128).checked_shl(shl))
                    .unwrap_or(0)
                    | u32::try_from(23i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_120(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(22i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_121(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(12i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_126(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | u32::try_from(2i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_127(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0)),
            );
        let part2off_10 = token_127(tokens_current);
        let part2J1 = token_120(tokens_current);
        let part2J2 = token_121(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                part2J1,
                part2J2,
                offset10,
                part2off_10,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TableThArmAddr23 {
    Var0(ThArmAddr23Var0),
    Var1(ThArmAddr23Var1),
}
impl TableThArmAddr23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                ThArmAddr23Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                ThArmAddr23Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:597:1, end:597:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar0 {
    Rn0810: u8,
}
impl Rn_exclaimVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:598:1, end:598:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar1 {
    Rn0810: u8,
}
impl Rn_exclaimVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:599:1, end:599:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar2 {
    Rn0810: u8,
}
impl Rn_exclaimVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:600:1, end:600:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar3 {
    Rn0810: u8,
}
impl Rn_exclaimVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:601:1, end:601:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar4 {
    Rn0810: u8,
}
impl Rn_exclaimVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:602:1, end:602:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar5 {
    Rn0810: u8,
}
impl Rn_exclaimVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:603:1, end:603:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar6 {
    Rn0810: u8,
}
impl Rn_exclaimVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:604:1, end:604:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar7 {
    Rn0810: u8,
}
impl Rn_exclaimVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.Rn0810)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:605:1, end:605:11))"]
#[derive(Clone, Debug)]
struct Rn_exclaimVar8 {
    Rn0810: u8,
}
impl Rn_exclaimVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            meaning_4_display(self.Rn0810),
            <DisplayElement>::Literal("!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        let thc0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0810 }))
    }
}
#[derive(Clone, Debug)]
enum TableRn_exclaim {
    Var0(Rn_exclaimVar0),
    Var1(Rn_exclaimVar1),
    Var2(Rn_exclaimVar2),
    Var3(Rn_exclaimVar3),
    Var4(Rn_exclaimVar4),
    Var5(Rn_exclaimVar5),
    Var6(Rn_exclaimVar6),
    Var7(Rn_exclaimVar7),
    Var8(Rn_exclaimVar8),
}
impl TableRn_exclaim {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 0 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 1 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 3 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 4 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 5 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 6 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 7 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rn_exclaimVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:607:1, end:607:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar0 {}
impl Rn_exclaim_WBVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:608:1, end:608:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar1 {}
impl Rn_exclaim_WBVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:609:1, end:609:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar2 {}
impl Rn_exclaim_WBVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:610:1, end:610:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar3 {}
impl Rn_exclaim_WBVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:611:1, end:611:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar4 {}
impl Rn_exclaim_WBVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:612:1, end:612:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar5 {}
impl Rn_exclaim_WBVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:613:1, end:613:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar6 {}
impl Rn_exclaim_WBVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:614:1, end:614:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar7 {}
impl Rn_exclaim_WBVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:615:1, end:615:14))"]
#[derive(Clone, Debug)]
struct Rn_exclaim_WBVar8 {}
impl Rn_exclaim_WBVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0810 = token_151(tokens_current);
        let Rn0810 = token_151(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableRn_exclaim_WB {
    Var0(Rn_exclaim_WBVar0),
    Var1(Rn_exclaim_WBVar1),
    Var2(Rn_exclaim_WBVar2),
    Var3(Rn_exclaim_WBVar3),
    Var4(Rn_exclaim_WBVar4),
    Var5(Rn_exclaim_WBVar5),
    Var6(Rn_exclaim_WBVar6),
    Var7(Rn_exclaim_WBVar7),
    Var8(Rn_exclaim_WBVar8),
}
impl TableRn_exclaim_WB {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 0 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 1 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 3 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 4 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 5 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 6 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 7) == 7 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Rn_exclaim_WBVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:618:1, end:618:9))"]
#[derive(Clone, Debug)]
struct LdRtype0Var0 {}
impl LdRtype0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:619:1, end:619:9))"]
#[derive(Clone, Debug)]
struct LdRtype0Var1 {}
impl LdRtype0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:620:1, end:620:9))"]
#[derive(Clone, Debug)]
struct LdRtype0Var2 {}
impl LdRtype0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype0 {
    Var0(LdRtype0Var0),
    Var1(LdRtype0Var1),
    Var2(LdRtype0Var2),
}
impl TableLdRtype0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                LdRtype0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                LdRtype0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:621:1, end:621:9))"]
#[derive(Clone, Debug)]
struct LdRtype1Var0 {
    LdRtype0: TableLdRtype0,
}
impl LdRtype1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype0 = if let Some((len, table)) =
            TableLdRtype0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:622:1, end:622:9))"]
#[derive(Clone, Debug)]
struct LdRtype1Var1 {
    LdRtype0: TableLdRtype0,
}
impl LdRtype1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype0 = if let Some((len, table)) =
            TableLdRtype0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:623:1, end:623:9))"]
#[derive(Clone, Debug)]
struct LdRtype1Var2 {
    LdRtype0: TableLdRtype0,
}
impl LdRtype1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype0 = if let Some((len, table)) =
            TableLdRtype0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype0 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype1 {
    Var0(LdRtype1Var0),
    Var1(LdRtype1Var1),
    Var2(LdRtype1Var2),
}
impl TableLdRtype1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                LdRtype1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                LdRtype1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:624:1, end:624:9))"]
#[derive(Clone, Debug)]
struct LdRtype2Var0 {
    LdRtype1: TableLdRtype1,
}
impl LdRtype2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype1 = if let Some((len, table)) =
            TableLdRtype1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:625:1, end:625:9))"]
#[derive(Clone, Debug)]
struct LdRtype2Var1 {
    LdRtype1: TableLdRtype1,
}
impl LdRtype2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype1 = if let Some((len, table)) =
            TableLdRtype1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:626:1, end:626:9))"]
#[derive(Clone, Debug)]
struct LdRtype2Var2 {
    LdRtype1: TableLdRtype1,
}
impl LdRtype2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype1 = if let Some((len, table)) =
            TableLdRtype1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype1 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype2 {
    Var0(LdRtype2Var0),
    Var1(LdRtype2Var1),
    Var2(LdRtype2Var2),
}
impl TableLdRtype2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                LdRtype2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                LdRtype2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:627:1, end:627:9))"]
#[derive(Clone, Debug)]
struct LdRtype3Var0 {
    LdRtype2: TableLdRtype2,
}
impl LdRtype3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype2 = if let Some((len, table)) =
            TableLdRtype2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:628:1, end:628:9))"]
#[derive(Clone, Debug)]
struct LdRtype3Var1 {
    LdRtype2: TableLdRtype2,
}
impl LdRtype3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype2 = if let Some((len, table)) =
            TableLdRtype2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:629:1, end:629:9))"]
#[derive(Clone, Debug)]
struct LdRtype3Var2 {
    LdRtype2: TableLdRtype2,
}
impl LdRtype3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype2 = if let Some((len, table)) =
            TableLdRtype2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype2 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype3 {
    Var0(LdRtype3Var0),
    Var1(LdRtype3Var1),
    Var2(LdRtype3Var2),
}
impl TableLdRtype3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                LdRtype3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                LdRtype3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:630:1, end:630:9))"]
#[derive(Clone, Debug)]
struct LdRtype4Var0 {
    LdRtype3: TableLdRtype3,
}
impl LdRtype4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype3 = if let Some((len, table)) =
            TableLdRtype3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:631:1, end:631:9))"]
#[derive(Clone, Debug)]
struct LdRtype4Var1 {
    LdRtype3: TableLdRtype3,
}
impl LdRtype4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype3 = if let Some((len, table)) =
            TableLdRtype3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:632:1, end:632:9))"]
#[derive(Clone, Debug)]
struct LdRtype4Var2 {
    LdRtype3: TableLdRtype3,
}
impl LdRtype4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype3 = if let Some((len, table)) =
            TableLdRtype3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype3 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype4 {
    Var0(LdRtype4Var0),
    Var1(LdRtype4Var1),
    Var2(LdRtype4Var2),
}
impl TableLdRtype4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                LdRtype4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                LdRtype4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:633:1, end:633:9))"]
#[derive(Clone, Debug)]
struct LdRtype5Var0 {
    LdRtype4: TableLdRtype4,
}
impl LdRtype5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype4 = if let Some((len, table)) =
            TableLdRtype4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:634:1, end:634:9))"]
#[derive(Clone, Debug)]
struct LdRtype5Var1 {
    LdRtype4: TableLdRtype4,
}
impl LdRtype5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype4 = if let Some((len, table)) =
            TableLdRtype4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:635:1, end:635:9))"]
#[derive(Clone, Debug)]
struct LdRtype5Var2 {
    LdRtype4: TableLdRtype4,
}
impl LdRtype5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype4 = if let Some((len, table)) =
            TableLdRtype4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype4 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype5 {
    Var0(LdRtype5Var0),
    Var1(LdRtype5Var1),
    Var2(LdRtype5Var2),
}
impl TableLdRtype5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                LdRtype5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                LdRtype5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:636:1, end:636:9))"]
#[derive(Clone, Debug)]
struct LdRtype6Var0 {
    LdRtype5: TableLdRtype5,
}
impl LdRtype6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype5 = if let Some((len, table)) =
            TableLdRtype5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:637:1, end:637:9))"]
#[derive(Clone, Debug)]
struct LdRtype6Var1 {
    LdRtype5: TableLdRtype5,
}
impl LdRtype6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype5 = if let Some((len, table)) =
            TableLdRtype5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:638:1, end:638:9))"]
#[derive(Clone, Debug)]
struct LdRtype6Var2 {
    LdRtype5: TableLdRtype5,
}
impl LdRtype6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype5 = if let Some((len, table)) =
            TableLdRtype5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype5 }))
    }
}
#[derive(Clone, Debug)]
enum TableLdRtype6 {
    Var0(LdRtype6Var0),
    Var1(LdRtype6Var1),
    Var2(LdRtype6Var2),
}
impl TableLdRtype6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                LdRtype6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                LdRtype6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                LdRtype6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:639:1, end:639:7))"]
#[derive(Clone, Debug)]
struct ldlistVar0 {
    LdRtype6: TableLdRtype6,
}
impl ldlistVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype6 = if let Some((len, table)) =
            TableLdRtype6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:640:1, end:640:7))"]
#[derive(Clone, Debug)]
struct ldlistVar1 {
    LdRtype6: TableLdRtype6,
}
impl ldlistVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.LdRtype6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let LdRtype6 = if let Some((len, table)) =
            TableLdRtype6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LdRtype6 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist {
    Var0(ldlistVar0),
    Var1(ldlistVar1),
}
impl Tableldlist {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                ldlistVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                ldlistVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:643:1, end:643:9))"]
#[derive(Clone, Debug)]
struct StrType0Var0 {}
impl StrType0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:644:1, end:644:9))"]
#[derive(Clone, Debug)]
struct StrType0Var1 {}
impl StrType0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:645:1, end:645:9))"]
#[derive(Clone, Debug)]
struct StrType0Var2 {}
impl StrType0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableStrType0 {
    Var0(StrType0Var0),
    Var1(StrType0Var1),
    Var2(StrType0Var2),
}
impl TableStrType0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                StrType0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                StrType0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                StrType0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:646:1, end:646:9))"]
#[derive(Clone, Debug)]
struct StrType1Var0 {
    StrType0: TableStrType0,
}
impl StrType1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType0 = if let Some((len, table)) =
            TableStrType0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:647:1, end:647:9))"]
#[derive(Clone, Debug)]
struct StrType1Var1 {
    StrType0: TableStrType0,
}
impl StrType1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType0 = if let Some((len, table)) =
            TableStrType0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:648:1, end:648:9))"]
#[derive(Clone, Debug)]
struct StrType1Var2 {
    StrType0: TableStrType0,
}
impl StrType1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType0 = if let Some((len, table)) =
            TableStrType0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType0 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType1 {
    Var0(StrType1Var0),
    Var1(StrType1Var1),
    Var2(StrType1Var2),
}
impl TableStrType1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                StrType1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                StrType1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                StrType1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:649:1, end:649:9))"]
#[derive(Clone, Debug)]
struct StrType2Var0 {
    StrType1: TableStrType1,
}
impl StrType2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType1 = if let Some((len, table)) =
            TableStrType1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:650:1, end:650:9))"]
#[derive(Clone, Debug)]
struct StrType2Var1 {
    StrType1: TableStrType1,
}
impl StrType2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType1 = if let Some((len, table)) =
            TableStrType1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:651:1, end:651:9))"]
#[derive(Clone, Debug)]
struct StrType2Var2 {
    StrType1: TableStrType1,
}
impl StrType2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType1 = if let Some((len, table)) =
            TableStrType1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType1 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType2 {
    Var0(StrType2Var0),
    Var1(StrType2Var1),
    Var2(StrType2Var2),
}
impl TableStrType2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                StrType2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                StrType2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                StrType2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:652:1, end:652:9))"]
#[derive(Clone, Debug)]
struct StrType3Var0 {
    StrType2: TableStrType2,
}
impl StrType3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType2 = if let Some((len, table)) =
            TableStrType2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:653:1, end:653:9))"]
#[derive(Clone, Debug)]
struct StrType3Var1 {
    StrType2: TableStrType2,
}
impl StrType3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType2 = if let Some((len, table)) =
            TableStrType2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:654:1, end:654:9))"]
#[derive(Clone, Debug)]
struct StrType3Var2 {
    StrType2: TableStrType2,
}
impl StrType3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType2 = if let Some((len, table)) =
            TableStrType2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType2 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType3 {
    Var0(StrType3Var0),
    Var1(StrType3Var1),
    Var2(StrType3Var2),
}
impl TableStrType3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                StrType3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                StrType3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                StrType3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:655:1, end:655:9))"]
#[derive(Clone, Debug)]
struct StrType4Var0 {
    StrType3: TableStrType3,
}
impl StrType4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType3 = if let Some((len, table)) =
            TableStrType3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:656:1, end:656:9))"]
#[derive(Clone, Debug)]
struct StrType4Var1 {
    StrType3: TableStrType3,
}
impl StrType4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType3 = if let Some((len, table)) =
            TableStrType3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:657:1, end:657:9))"]
#[derive(Clone, Debug)]
struct StrType4Var2 {
    StrType3: TableStrType3,
}
impl StrType4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType3 = if let Some((len, table)) =
            TableStrType3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType3 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType4 {
    Var0(StrType4Var0),
    Var1(StrType4Var1),
    Var2(StrType4Var2),
}
impl TableStrType4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                StrType4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                StrType4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                StrType4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:658:1, end:658:9))"]
#[derive(Clone, Debug)]
struct StrType5Var0 {
    StrType4: TableStrType4,
}
impl StrType5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType4 = if let Some((len, table)) =
            TableStrType4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:659:1, end:659:9))"]
#[derive(Clone, Debug)]
struct StrType5Var1 {
    StrType4: TableStrType4,
}
impl StrType5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType4 = if let Some((len, table)) =
            TableStrType4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:660:1, end:660:9))"]
#[derive(Clone, Debug)]
struct StrType5Var2 {
    StrType4: TableStrType4,
}
impl StrType5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType4 = if let Some((len, table)) =
            TableStrType4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType4 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType5 {
    Var0(StrType5Var0),
    Var1(StrType5Var1),
    Var2(StrType5Var2),
}
impl TableStrType5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                StrType5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                StrType5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                StrType5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:661:1, end:661:9))"]
#[derive(Clone, Debug)]
struct StrType6Var0 {
    StrType5: TableStrType5,
}
impl StrType6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType5 = if let Some((len, table)) =
            TableStrType5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:662:1, end:662:9))"]
#[derive(Clone, Debug)]
struct StrType6Var1 {
    StrType5: TableStrType5,
}
impl StrType6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType5 = if let Some((len, table)) =
            TableStrType5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:663:1, end:663:9))"]
#[derive(Clone, Debug)]
struct StrType6Var2 {
    StrType5: TableStrType5,
}
impl StrType6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType5 = if let Some((len, table)) =
            TableStrType5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType5 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType6 {
    Var0(StrType6Var0),
    Var1(StrType6Var1),
    Var2(StrType6Var2),
}
impl TableStrType6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                StrType6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                StrType6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                StrType6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:664:1, end:664:9))"]
#[derive(Clone, Debug)]
struct StrType7Var0 {
    StrType6: TableStrType6,
}
impl StrType7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType6 = if let Some((len, table)) =
            TableStrType6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:665:1, end:665:9))"]
#[derive(Clone, Debug)]
struct StrType7Var1 {
    StrType6: TableStrType6,
}
impl StrType7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType6 = if let Some((len, table)) =
            TableStrType6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType6 }))
    }
}
#[derive(Clone, Debug)]
enum TableStrType7 {
    Var0(StrType7Var0),
    Var1(StrType7Var1),
}
impl TableStrType7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                StrType7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                StrType7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:666:1, end:666:8))"]
#[derive(Clone, Debug)]
struct strlistVar0 {
    StrType7: TableStrType7,
}
impl strlistVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.StrType7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let StrType7 = if let Some((len, table)) =
            TableStrType7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { StrType7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestrlist {
    Var0(strlistVar0),
}
impl Tablestrlist {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                strlistVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:672:1, end:672:9))"]
#[derive(Clone, Debug)]
struct PshType7Var0 {}
impl PshType7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:673:1, end:673:9))"]
#[derive(Clone, Debug)]
struct PshType7Var1 {}
impl PshType7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablePshType7 {
    Var0(PshType7Var0),
    Var1(PshType7Var1),
}
impl TablePshType7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                PshType7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                PshType7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:675:1, end:675:9))"]
#[derive(Clone, Debug)]
struct PshType6Var0 {}
impl PshType6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:674:1, end:674:9))"]
#[derive(Clone, Debug)]
struct PshType6Var1 {
    PshType7: TablePshType7,
}
impl PshType6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType7 = if let Some((len, table)) =
            TablePshType7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:676:1, end:676:9))"]
#[derive(Clone, Debug)]
struct PshType6Var2 {
    PshType7: TablePshType7,
}
impl PshType6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType7 = if let Some((len, table)) =
            TablePshType7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType7 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType6 {
    Var0(PshType6Var0),
    Var1(PshType6Var1),
    Var2(PshType6Var2),
}
impl TablePshType6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                PshType6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                PshType6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                PshType6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:678:1, end:678:9))"]
#[derive(Clone, Debug)]
struct PshType5Var0 {}
impl PshType5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:677:1, end:677:9))"]
#[derive(Clone, Debug)]
struct PshType5Var1 {
    PshType6: TablePshType6,
}
impl PshType5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType6 = if let Some((len, table)) =
            TablePshType6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:679:1, end:679:9))"]
#[derive(Clone, Debug)]
struct PshType5Var2 {
    PshType6: TablePshType6,
}
impl PshType5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType6 = if let Some((len, table)) =
            TablePshType6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType6 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType5 {
    Var0(PshType5Var0),
    Var1(PshType5Var1),
    Var2(PshType5Var2),
}
impl TablePshType5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                PshType5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                PshType5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                PshType5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:681:1, end:681:9))"]
#[derive(Clone, Debug)]
struct PshType4Var0 {}
impl PshType4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:680:1, end:680:9))"]
#[derive(Clone, Debug)]
struct PshType4Var1 {
    PshType5: TablePshType5,
}
impl PshType4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType5 = if let Some((len, table)) =
            TablePshType5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:682:1, end:682:9))"]
#[derive(Clone, Debug)]
struct PshType4Var2 {
    PshType5: TablePshType5,
}
impl PshType4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType5 = if let Some((len, table)) =
            TablePshType5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType5 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType4 {
    Var0(PshType4Var0),
    Var1(PshType4Var1),
    Var2(PshType4Var2),
}
impl TablePshType4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                PshType4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                PshType4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                PshType4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:684:1, end:684:9))"]
#[derive(Clone, Debug)]
struct PshType3Var0 {}
impl PshType3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:683:1, end:683:9))"]
#[derive(Clone, Debug)]
struct PshType3Var1 {
    PshType4: TablePshType4,
}
impl PshType3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType4 = if let Some((len, table)) =
            TablePshType4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:685:1, end:685:9))"]
#[derive(Clone, Debug)]
struct PshType3Var2 {
    PshType4: TablePshType4,
}
impl PshType3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType4 = if let Some((len, table)) =
            TablePshType4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType4 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType3 {
    Var0(PshType3Var0),
    Var1(PshType3Var1),
    Var2(PshType3Var2),
}
impl TablePshType3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                PshType3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                PshType3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                PshType3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:687:1, end:687:9))"]
#[derive(Clone, Debug)]
struct PshType2Var0 {}
impl PshType2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:686:1, end:686:9))"]
#[derive(Clone, Debug)]
struct PshType2Var1 {
    PshType3: TablePshType3,
}
impl PshType2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType3 = if let Some((len, table)) =
            TablePshType3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:688:1, end:688:9))"]
#[derive(Clone, Debug)]
struct PshType2Var2 {
    PshType3: TablePshType3,
}
impl PshType2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType3 = if let Some((len, table)) =
            TablePshType3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType3 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType2 {
    Var0(PshType2Var0),
    Var1(PshType2Var1),
    Var2(PshType2Var2),
}
impl TablePshType2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                PshType2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                PshType2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                PshType2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:690:1, end:690:9))"]
#[derive(Clone, Debug)]
struct PshType1Var0 {}
impl PshType1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:689:1, end:689:9))"]
#[derive(Clone, Debug)]
struct PshType1Var1 {
    PshType2: TablePshType2,
}
impl PshType1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType2 = if let Some((len, table)) =
            TablePshType2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:691:1, end:691:9))"]
#[derive(Clone, Debug)]
struct PshType1Var2 {
    PshType2: TablePshType2,
}
impl PshType1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType2 = if let Some((len, table)) =
            TablePshType2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType2 }))
    }
}
#[derive(Clone, Debug)]
enum TablePshType1 {
    Var0(PshType1Var0),
    Var1(PshType1Var1),
    Var2(PshType1Var2),
}
impl TablePshType1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                PshType1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                PshType1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                PshType1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:693:1, end:693:8))"]
#[derive(Clone, Debug)]
struct pshlistVar0 {}
impl pshlistVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:692:1, end:692:8))"]
#[derive(Clone, Debug)]
struct pshlistVar1 {
    PshType1: TablePshType1,
}
impl pshlistVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PshType1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType1 = if let Some((len, table)) =
            TablePshType1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:694:1, end:694:8))"]
#[derive(Clone, Debug)]
struct pshlistVar2 {
    PshType1: TablePshType1,
}
impl pshlistVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.PshType1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let PshType1 = if let Some((len, table)) =
            TablePshType1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PshType1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablepshlist {
    Var0(pshlistVar0),
    Var1(pshlistVar1),
    Var2(pshlistVar2),
}
impl Tablepshlist {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                pshlistVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                pshlistVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                pshlistVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:697:1, end:697:10))"]
#[derive(Clone, Debug)]
struct thrlist15Var0 {}
impl thrlist15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:698:1, end:698:10))"]
#[derive(Clone, Debug)]
struct thrlist15Var1 {}
impl thrlist15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:699:1, end:699:10))"]
#[derive(Clone, Debug)]
struct thrlist15Var2 {}
impl thrlist15Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist15 {
    Var0(thrlist15Var0),
    Var1(thrlist15Var1),
    Var2(thrlist15Var2),
}
impl Tablethrlist15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                thrlist15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                thrlist15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist15Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:700:1, end:700:10))"]
#[derive(Clone, Debug)]
struct thrlist14Var0 {
    thrlist15: Tablethrlist15,
}
impl thrlist14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist15
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist15 = if let Some((len, table)) =
            Tablethrlist15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:701:1, end:701:10))"]
#[derive(Clone, Debug)]
struct thrlist14Var1 {
    thrlist15: Tablethrlist15,
}
impl thrlist14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist15
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist15 = if let Some((len, table)) =
            Tablethrlist15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:702:1, end:702:10))"]
#[derive(Clone, Debug)]
struct thrlist14Var2 {
    thrlist15: Tablethrlist15,
}
impl thrlist14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist15 = if let Some((len, table)) =
            Tablethrlist15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist14 {
    Var0(thrlist14Var0),
    Var1(thrlist14Var1),
    Var2(thrlist14Var2),
}
impl Tablethrlist14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                thrlist14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                thrlist14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:703:1, end:703:10))"]
#[derive(Clone, Debug)]
struct thrlist13Var0 {
    thrlist14: Tablethrlist14,
}
impl thrlist13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist14 = if let Some((len, table)) =
            Tablethrlist14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:704:1, end:704:10))"]
#[derive(Clone, Debug)]
struct thrlist13Var1 {
    thrlist14: Tablethrlist14,
}
impl thrlist13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist14 = if let Some((len, table)) =
            Tablethrlist14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:705:1, end:705:10))"]
#[derive(Clone, Debug)]
struct thrlist13Var2 {
    thrlist14: Tablethrlist14,
}
impl thrlist13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist14 = if let Some((len, table)) =
            Tablethrlist14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist13 {
    Var0(thrlist13Var0),
    Var1(thrlist13Var1),
    Var2(thrlist13Var2),
}
impl Tablethrlist13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                thrlist13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                thrlist13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:706:1, end:706:10))"]
#[derive(Clone, Debug)]
struct thrlist12Var0 {
    thrlist13: Tablethrlist13,
}
impl thrlist12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist13
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist13 = if let Some((len, table)) =
            Tablethrlist13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:707:1, end:707:10))"]
#[derive(Clone, Debug)]
struct thrlist12Var1 {
    thrlist13: Tablethrlist13,
}
impl thrlist12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist13
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist13 = if let Some((len, table)) =
            Tablethrlist13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:708:1, end:708:10))"]
#[derive(Clone, Debug)]
struct thrlist12Var2 {
    thrlist13: Tablethrlist13,
}
impl thrlist12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist13 = if let Some((len, table)) =
            Tablethrlist13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist12 {
    Var0(thrlist12Var0),
    Var1(thrlist12Var1),
    Var2(thrlist12Var2),
}
impl Tablethrlist12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                thrlist12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                thrlist12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:709:1, end:709:10))"]
#[derive(Clone, Debug)]
struct thrlist11Var0 {
    thrlist12: Tablethrlist12,
}
impl thrlist11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist12 = if let Some((len, table)) =
            Tablethrlist12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:710:1, end:710:10))"]
#[derive(Clone, Debug)]
struct thrlist11Var1 {
    thrlist12: Tablethrlist12,
}
impl thrlist11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist12 = if let Some((len, table)) =
            Tablethrlist12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:711:1, end:711:10))"]
#[derive(Clone, Debug)]
struct thrlist11Var2 {
    thrlist12: Tablethrlist12,
}
impl thrlist11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist12 = if let Some((len, table)) =
            Tablethrlist12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist11 {
    Var0(thrlist11Var0),
    Var1(thrlist11Var1),
    Var2(thrlist11Var2),
}
impl Tablethrlist11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                thrlist11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                thrlist11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:712:1, end:712:10))"]
#[derive(Clone, Debug)]
struct thrlist10Var0 {
    thrlist11: Tablethrlist11,
}
impl thrlist10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist11 = if let Some((len, table)) =
            Tablethrlist11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:713:1, end:713:10))"]
#[derive(Clone, Debug)]
struct thrlist10Var1 {
    thrlist11: Tablethrlist11,
}
impl thrlist10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist11 = if let Some((len, table)) =
            Tablethrlist11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:714:1, end:714:10))"]
#[derive(Clone, Debug)]
struct thrlist10Var2 {
    thrlist11: Tablethrlist11,
}
impl thrlist10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist11 = if let Some((len, table)) =
            Tablethrlist11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist10 {
    Var0(thrlist10Var0),
    Var1(thrlist10Var1),
    Var2(thrlist10Var2),
}
impl Tablethrlist10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                thrlist10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                thrlist10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:715:1, end:715:9))"]
#[derive(Clone, Debug)]
struct thrlist9Var0 {
    thrlist10: Tablethrlist10,
}
impl thrlist9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist10 = if let Some((len, table)) =
            Tablethrlist10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:716:1, end:716:9))"]
#[derive(Clone, Debug)]
struct thrlist9Var1 {
    thrlist10: Tablethrlist10,
}
impl thrlist9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist10 = if let Some((len, table)) =
            Tablethrlist10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:717:1, end:717:9))"]
#[derive(Clone, Debug)]
struct thrlist9Var2 {
    thrlist10: Tablethrlist10,
}
impl thrlist9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist10 = if let Some((len, table)) =
            Tablethrlist10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist9 {
    Var0(thrlist9Var0),
    Var1(thrlist9Var1),
    Var2(thrlist9Var2),
}
impl Tablethrlist9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                thrlist9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                thrlist9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:718:1, end:718:9))"]
#[derive(Clone, Debug)]
struct thrlist8Var0 {
    thrlist9: Tablethrlist9,
}
impl thrlist8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist9 = if let Some((len, table)) =
            Tablethrlist9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:719:1, end:719:9))"]
#[derive(Clone, Debug)]
struct thrlist8Var1 {
    thrlist9: Tablethrlist9,
}
impl thrlist8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r7),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist9 = if let Some((len, table)) =
            Tablethrlist9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:720:1, end:720:9))"]
#[derive(Clone, Debug)]
struct thrlist8Var2 {
    thrlist9: Tablethrlist9,
}
impl thrlist8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist9 = if let Some((len, table)) =
            Tablethrlist9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist8 {
    Var0(thrlist8Var0),
    Var1(thrlist8Var1),
    Var2(thrlist8Var2),
}
impl Tablethrlist8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                thrlist8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                thrlist8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:721:1, end:721:9))"]
#[derive(Clone, Debug)]
struct thrlist7Var0 {
    thrlist8: Tablethrlist8,
}
impl thrlist7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist8 = if let Some((len, table)) =
            Tablethrlist8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:722:1, end:722:9))"]
#[derive(Clone, Debug)]
struct thrlist7Var1 {
    thrlist8: Tablethrlist8,
}
impl thrlist7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r8),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist8 = if let Some((len, table)) =
            Tablethrlist8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:723:1, end:723:9))"]
#[derive(Clone, Debug)]
struct thrlist7Var2 {
    thrlist8: Tablethrlist8,
}
impl thrlist7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist8 = if let Some((len, table)) =
            Tablethrlist8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist7 {
    Var0(thrlist7Var0),
    Var1(thrlist7Var1),
    Var2(thrlist7Var2),
}
impl Tablethrlist7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                thrlist7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                thrlist7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:724:1, end:724:9))"]
#[derive(Clone, Debug)]
struct thrlist6Var0 {
    thrlist7: Tablethrlist7,
}
impl thrlist6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist7 = if let Some((len, table)) =
            Tablethrlist7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:725:1, end:725:9))"]
#[derive(Clone, Debug)]
struct thrlist6Var1 {
    thrlist7: Tablethrlist7,
}
impl thrlist6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r9),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist7 = if let Some((len, table)) =
            Tablethrlist7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:726:1, end:726:9))"]
#[derive(Clone, Debug)]
struct thrlist6Var2 {
    thrlist7: Tablethrlist7,
}
impl thrlist6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist7 = if let Some((len, table)) =
            Tablethrlist7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist6 {
    Var0(thrlist6Var0),
    Var1(thrlist6Var1),
    Var2(thrlist6Var2),
}
impl Tablethrlist6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                thrlist6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                thrlist6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:727:1, end:727:9))"]
#[derive(Clone, Debug)]
struct thrlist5Var0 {
    thrlist6: Tablethrlist6,
}
impl thrlist5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist6 = if let Some((len, table)) =
            Tablethrlist6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:728:1, end:728:9))"]
#[derive(Clone, Debug)]
struct thrlist5Var1 {
    thrlist6: Tablethrlist6,
}
impl thrlist5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r10),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist6 = if let Some((len, table)) =
            Tablethrlist6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:729:1, end:729:9))"]
#[derive(Clone, Debug)]
struct thrlist5Var2 {
    thrlist6: Tablethrlist6,
}
impl thrlist5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist6 = if let Some((len, table)) =
            Tablethrlist6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist5 {
    Var0(thrlist5Var0),
    Var1(thrlist5Var1),
    Var2(thrlist5Var2),
}
impl Tablethrlist5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                thrlist5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                thrlist5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:730:1, end:730:9))"]
#[derive(Clone, Debug)]
struct thrlist4Var0 {
    thrlist5: Tablethrlist5,
}
impl thrlist4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist5 = if let Some((len, table)) =
            Tablethrlist5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:731:1, end:731:9))"]
#[derive(Clone, Debug)]
struct thrlist4Var1 {
    thrlist5: Tablethrlist5,
}
impl thrlist4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r11),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist5 = if let Some((len, table)) =
            Tablethrlist5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:732:1, end:732:9))"]
#[derive(Clone, Debug)]
struct thrlist4Var2 {
    thrlist5: Tablethrlist5,
}
impl thrlist4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist5 = if let Some((len, table)) =
            Tablethrlist5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist4 {
    Var0(thrlist4Var0),
    Var1(thrlist4Var1),
    Var2(thrlist4Var2),
}
impl Tablethrlist4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                thrlist4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                thrlist4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:733:1, end:733:9))"]
#[derive(Clone, Debug)]
struct thrlist3Var0 {
    thrlist4: Tablethrlist4,
}
impl thrlist3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist4 = if let Some((len, table)) =
            Tablethrlist4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:734:1, end:734:9))"]
#[derive(Clone, Debug)]
struct thrlist3Var1 {
    thrlist4: Tablethrlist4,
}
impl thrlist3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r12),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist4 = if let Some((len, table)) =
            Tablethrlist4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:735:1, end:735:9))"]
#[derive(Clone, Debug)]
struct thrlist3Var2 {
    thrlist4: Tablethrlist4,
}
impl thrlist3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist4 = if let Some((len, table)) =
            Tablethrlist4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist3 {
    Var0(thrlist3Var0),
    Var1(thrlist3Var1),
    Var2(thrlist3Var2),
}
impl Tablethrlist3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                thrlist3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                thrlist3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:736:1, end:736:9))"]
#[derive(Clone, Debug)]
struct thrlist2Var0 {
    thrlist3: Tablethrlist3,
}
impl thrlist2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist3 = if let Some((len, table)) =
            Tablethrlist3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:737:1, end:737:9))"]
#[derive(Clone, Debug)]
struct thrlist2Var1 {
    thrlist3: Tablethrlist3,
}
impl thrlist2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist3 = if let Some((len, table)) =
            Tablethrlist3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:738:1, end:738:9))"]
#[derive(Clone, Debug)]
struct thrlist2Var2 {
    thrlist3: Tablethrlist3,
}
impl thrlist2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist3 = if let Some((len, table)) =
            Tablethrlist3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist2 {
    Var0(thrlist2Var0),
    Var1(thrlist2Var1),
    Var2(thrlist2Var2),
}
impl Tablethrlist2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                thrlist2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                thrlist2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:739:1, end:739:9))"]
#[derive(Clone, Debug)]
struct thrlist1Var0 {
    thrlist2: Tablethrlist2,
}
impl thrlist1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist2 = if let Some((len, table)) =
            Tablethrlist2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:740:1, end:740:9))"]
#[derive(Clone, Debug)]
struct thrlist1Var1 {
    thrlist2: Tablethrlist2,
}
impl thrlist1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist2 = if let Some((len, table)) =
            Tablethrlist2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:741:1, end:741:9))"]
#[derive(Clone, Debug)]
struct thrlist1Var2 {
    thrlist2: Tablethrlist2,
}
impl thrlist1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thrlist2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist2 = if let Some((len, table)) =
            Tablethrlist2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethrlist1 {
    Var0(thrlist1Var0),
    Var1(thrlist1Var1),
    Var2(thrlist1Var2),
}
impl Tablethrlist1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                thrlist1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                thrlist1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                thrlist1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:742:1, end:742:14))"]
#[derive(Clone, Debug)]
struct thldrlist_incVar0 {
    thrlist1: Tablethrlist1,
}
impl thldrlist_incVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.thrlist1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist1 = if let Some((len, table)) =
            Tablethrlist1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:743:1, end:743:14))"]
#[derive(Clone, Debug)]
struct thldrlist_incVar1 {
    thrlist1: Tablethrlist1,
}
impl thldrlist_incVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.thrlist1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thrlist1 = if let Some((len, table)) =
            Tablethrlist1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thrlist1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethldrlist_inc {
    Var0(thldrlist_incVar0),
    Var1(thldrlist_incVar1),
}
impl Tablethldrlist_inc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                thldrlist_incVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                thldrlist_incVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:848:1, end:848:9))"]
#[derive(Clone, Debug)]
struct thsdec15Var0 {}
impl thsdec15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:849:1, end:849:9))"]
#[derive(Clone, Debug)]
struct thsdec15Var1 {}
impl thsdec15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec15 {
    Var0(thsdec15Var0),
    Var1(thsdec15Var1),
}
impl Tablethsdec15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                thsdec15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:850:1, end:850:9))"]
#[derive(Clone, Debug)]
struct thsdec14Var0 {
    thsdec15: Tablethsdec15,
}
impl thsdec14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec15 = if let Some((len, table)) =
            Tablethsdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:851:1, end:851:9))"]
#[derive(Clone, Debug)]
struct thsdec14Var1 {
    thsdec15: Tablethsdec15,
}
impl thsdec14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec15 = if let Some((len, table)) =
            Tablethsdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:852:1, end:852:9))"]
#[derive(Clone, Debug)]
struct thsdec14Var2 {
    thsdec15: Tablethsdec15,
}
impl thsdec14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec15 = if let Some((len, table)) =
            Tablethsdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec14 {
    Var0(thsdec14Var0),
    Var1(thsdec14Var1),
    Var2(thsdec14Var2),
}
impl Tablethsdec14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                thsdec14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                thsdec14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:853:1, end:853:9))"]
#[derive(Clone, Debug)]
struct thsdec13Var0 {}
impl thsdec13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:854:1, end:854:9))"]
#[derive(Clone, Debug)]
struct thsdec13Var1 {
    thsdec14: Tablethsdec14,
}
impl thsdec13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec14 = if let Some((len, table)) =
            Tablethsdec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:855:1, end:855:9))"]
#[derive(Clone, Debug)]
struct thsdec13Var2 {
    thsdec14: Tablethsdec14,
}
impl thsdec13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec14 = if let Some((len, table)) =
            Tablethsdec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec13 {
    Var0(thsdec13Var0),
    Var1(thsdec13Var1),
    Var2(thsdec13Var2),
}
impl Tablethsdec13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                thsdec13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                thsdec13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:856:1, end:856:9))"]
#[derive(Clone, Debug)]
struct thsdec12Var0 {}
impl thsdec12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:857:1, end:857:9))"]
#[derive(Clone, Debug)]
struct thsdec12Var1 {
    thsdec13: Tablethsdec13,
}
impl thsdec12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r12),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec13 = if let Some((len, table)) =
            Tablethsdec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:858:1, end:858:9))"]
#[derive(Clone, Debug)]
struct thsdec12Var2 {
    thsdec13: Tablethsdec13,
}
impl thsdec12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec13 = if let Some((len, table)) =
            Tablethsdec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec12 {
    Var0(thsdec12Var0),
    Var1(thsdec12Var1),
    Var2(thsdec12Var2),
}
impl Tablethsdec12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                thsdec12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                thsdec12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:859:1, end:859:9))"]
#[derive(Clone, Debug)]
struct thsdec11Var0 {}
impl thsdec11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:860:1, end:860:9))"]
#[derive(Clone, Debug)]
struct thsdec11Var1 {
    thsdec12: Tablethsdec12,
}
impl thsdec11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r11),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec12 = if let Some((len, table)) =
            Tablethsdec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:861:1, end:861:9))"]
#[derive(Clone, Debug)]
struct thsdec11Var2 {
    thsdec12: Tablethsdec12,
}
impl thsdec11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec12 = if let Some((len, table)) =
            Tablethsdec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec11 {
    Var0(thsdec11Var0),
    Var1(thsdec11Var1),
    Var2(thsdec11Var2),
}
impl Tablethsdec11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                thsdec11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                thsdec11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:862:1, end:862:9))"]
#[derive(Clone, Debug)]
struct thsdec10Var0 {}
impl thsdec10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:863:1, end:863:9))"]
#[derive(Clone, Debug)]
struct thsdec10Var1 {
    thsdec11: Tablethsdec11,
}
impl thsdec10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r10),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec11 = if let Some((len, table)) =
            Tablethsdec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:864:1, end:864:9))"]
#[derive(Clone, Debug)]
struct thsdec10Var2 {
    thsdec11: Tablethsdec11,
}
impl thsdec10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec11 = if let Some((len, table)) =
            Tablethsdec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec10 {
    Var0(thsdec10Var0),
    Var1(thsdec10Var1),
    Var2(thsdec10Var2),
}
impl Tablethsdec10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                thsdec10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                thsdec10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:865:1, end:865:8))"]
#[derive(Clone, Debug)]
struct thsdec9Var0 {}
impl thsdec9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:866:1, end:866:8))"]
#[derive(Clone, Debug)]
struct thsdec9Var1 {
    thsdec10: Tablethsdec10,
}
impl thsdec9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r9),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec10 = if let Some((len, table)) =
            Tablethsdec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:867:1, end:867:8))"]
#[derive(Clone, Debug)]
struct thsdec9Var2 {
    thsdec10: Tablethsdec10,
}
impl thsdec9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec10 = if let Some((len, table)) =
            Tablethsdec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec9 {
    Var0(thsdec9Var0),
    Var1(thsdec9Var1),
    Var2(thsdec9Var2),
}
impl Tablethsdec9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                thsdec9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                thsdec9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:868:1, end:868:8))"]
#[derive(Clone, Debug)]
struct thsdec8Var0 {}
impl thsdec8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:869:1, end:869:8))"]
#[derive(Clone, Debug)]
struct thsdec8Var1 {
    thsdec9: Tablethsdec9,
}
impl thsdec8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r8),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec9 = if let Some((len, table)) =
            Tablethsdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:870:1, end:870:8))"]
#[derive(Clone, Debug)]
struct thsdec8Var2 {
    thsdec9: Tablethsdec9,
}
impl thsdec8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec9 = if let Some((len, table)) =
            Tablethsdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec8 {
    Var0(thsdec8Var0),
    Var1(thsdec8Var1),
    Var2(thsdec8Var2),
}
impl Tablethsdec8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                thsdec8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                thsdec8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:871:1, end:871:8))"]
#[derive(Clone, Debug)]
struct thsdec7Var0 {}
impl thsdec7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:872:1, end:872:8))"]
#[derive(Clone, Debug)]
struct thsdec7Var1 {
    thsdec8: Tablethsdec8,
}
impl thsdec7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r7),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec8 = if let Some((len, table)) =
            Tablethsdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:873:1, end:873:8))"]
#[derive(Clone, Debug)]
struct thsdec7Var2 {
    thsdec8: Tablethsdec8,
}
impl thsdec7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec8 = if let Some((len, table)) =
            Tablethsdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec7 {
    Var0(thsdec7Var0),
    Var1(thsdec7Var1),
    Var2(thsdec7Var2),
}
impl Tablethsdec7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                thsdec7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                thsdec7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:874:1, end:874:8))"]
#[derive(Clone, Debug)]
struct thsdec6Var0 {}
impl thsdec6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:875:1, end:875:8))"]
#[derive(Clone, Debug)]
struct thsdec6Var1 {
    thsdec7: Tablethsdec7,
}
impl thsdec6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec7 = if let Some((len, table)) =
            Tablethsdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:876:1, end:876:8))"]
#[derive(Clone, Debug)]
struct thsdec6Var2 {
    thsdec7: Tablethsdec7,
}
impl thsdec6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec7 = if let Some((len, table)) =
            Tablethsdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec6 {
    Var0(thsdec6Var0),
    Var1(thsdec6Var1),
    Var2(thsdec6Var2),
}
impl Tablethsdec6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                thsdec6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                thsdec6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:877:1, end:877:8))"]
#[derive(Clone, Debug)]
struct thsdec5Var0 {}
impl thsdec5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:878:1, end:878:8))"]
#[derive(Clone, Debug)]
struct thsdec5Var1 {
    thsdec6: Tablethsdec6,
}
impl thsdec5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec6 = if let Some((len, table)) =
            Tablethsdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:879:1, end:879:8))"]
#[derive(Clone, Debug)]
struct thsdec5Var2 {
    thsdec6: Tablethsdec6,
}
impl thsdec5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec6 = if let Some((len, table)) =
            Tablethsdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec5 {
    Var0(thsdec5Var0),
    Var1(thsdec5Var1),
    Var2(thsdec5Var2),
}
impl Tablethsdec5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                thsdec5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                thsdec5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:880:1, end:880:8))"]
#[derive(Clone, Debug)]
struct thsdec4Var0 {}
impl thsdec4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:881:1, end:881:8))"]
#[derive(Clone, Debug)]
struct thsdec4Var1 {
    thsdec5: Tablethsdec5,
}
impl thsdec4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec5 = if let Some((len, table)) =
            Tablethsdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:882:1, end:882:8))"]
#[derive(Clone, Debug)]
struct thsdec4Var2 {
    thsdec5: Tablethsdec5,
}
impl thsdec4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec5 = if let Some((len, table)) =
            Tablethsdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec4 {
    Var0(thsdec4Var0),
    Var1(thsdec4Var1),
    Var2(thsdec4Var2),
}
impl Tablethsdec4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                thsdec4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                thsdec4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:883:1, end:883:8))"]
#[derive(Clone, Debug)]
struct thsdec3Var0 {}
impl thsdec3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:884:1, end:884:8))"]
#[derive(Clone, Debug)]
struct thsdec3Var1 {
    thsdec4: Tablethsdec4,
}
impl thsdec3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec4 = if let Some((len, table)) =
            Tablethsdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:885:1, end:885:8))"]
#[derive(Clone, Debug)]
struct thsdec3Var2 {
    thsdec4: Tablethsdec4,
}
impl thsdec3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec4 = if let Some((len, table)) =
            Tablethsdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec3 {
    Var0(thsdec3Var0),
    Var1(thsdec3Var1),
    Var2(thsdec3Var2),
}
impl Tablethsdec3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                thsdec3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                thsdec3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:886:1, end:886:8))"]
#[derive(Clone, Debug)]
struct thsdec2Var0 {}
impl thsdec2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:887:1, end:887:8))"]
#[derive(Clone, Debug)]
struct thsdec2Var1 {
    thsdec3: Tablethsdec3,
}
impl thsdec2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec3 = if let Some((len, table)) =
            Tablethsdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:888:1, end:888:8))"]
#[derive(Clone, Debug)]
struct thsdec2Var2 {
    thsdec3: Tablethsdec3,
}
impl thsdec2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec3 = if let Some((len, table)) =
            Tablethsdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec2 {
    Var0(thsdec2Var0),
    Var1(thsdec2Var1),
    Var2(thsdec2Var2),
}
impl Tablethsdec2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                thsdec2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                thsdec2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:889:1, end:889:8))"]
#[derive(Clone, Debug)]
struct thsdec1Var0 {}
impl thsdec1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:890:1, end:890:8))"]
#[derive(Clone, Debug)]
struct thsdec1Var1 {
    thsdec2: Tablethsdec2,
}
impl thsdec1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec2 = if let Some((len, table)) =
            Tablethsdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:891:1, end:891:8))"]
#[derive(Clone, Debug)]
struct thsdec1Var2 {
    thsdec2: Tablethsdec2,
}
impl thsdec1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.thsdec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec2 = if let Some((len, table)) =
            Tablethsdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethsdec1 {
    Var0(thsdec1Var0),
    Var1(thsdec1Var1),
    Var2(thsdec1Var2),
}
impl Tablethsdec1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                thsdec1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                thsdec1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                thsdec1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:892:1, end:892:14))"]
#[derive(Clone, Debug)]
struct thstrlist_decVar0 {}
impl thstrlist_decVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:893:1, end:893:14))"]
#[derive(Clone, Debug)]
struct thstrlist_decVar1 {
    thsdec1: Tablethsdec1,
}
impl thstrlist_decVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.thsdec1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec1 = if let Some((len, table)) =
            Tablethsdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:894:1, end:894:14))"]
#[derive(Clone, Debug)]
struct thstrlist_decVar2 {
    thsdec1: Tablethsdec1,
}
impl thstrlist_decVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.thsdec1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsdec1 = if let Some((len, table)) =
            Tablethsdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsdec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablethstrlist_dec {
    Var0(thstrlist_decVar0),
    Var1(thstrlist_decVar1),
    Var2(thstrlist_decVar2),
}
impl Tablethstrlist_dec {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 255) == 0 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                thstrlist_decVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                thstrlist_decVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                thstrlist_decVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:896:1, end:896:8))"]
#[derive(Clone, Debug)]
struct ldbraceVar0 {
    ldlist: Tableldlist,
}
impl ldbraceVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldlist
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ldlist = if let Some((len, table)) =
            Tableldlist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist }))
    }
}
#[derive(Clone, Debug)]
enum Tableldbrace {
    Var0(ldbraceVar0),
}
impl Tableldbrace {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                ldbraceVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:897:1, end:897:8))"]
#[derive(Clone, Debug)]
struct stbraceVar0 {
    strlist: Tablestrlist,
}
impl stbraceVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.strlist
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let strlist = if let Some((len, table)) =
            Tablestrlist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { strlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablestbrace {
    Var0(stbraceVar0),
}
impl Tablestbrace {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                stbraceVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:898:1, end:898:8))"]
#[derive(Clone, Debug)]
struct psbraceVar0 {
    pshlist: Tablepshlist,
}
impl psbraceVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.pshlist
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let pshlist = if let Some((len, table)) =
            Tablepshlist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { pshlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablepsbrace {
    Var0(psbraceVar0),
}
impl Tablepsbrace {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                psbraceVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:902:1, end:902:9))"]
#[derive(Clone, Debug)]
struct pclbraceVar0 {}
impl pclbraceVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:901:1, end:901:9))"]
#[derive(Clone, Debug)]
struct pclbraceVar1 {
    ldlist: Tableldlist,
}
impl pclbraceVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldlist
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ldlist = if let Some((len, table)) =
            Tableldlist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablepclbrace {
    Var0(pclbraceVar0),
    Var1(pclbraceVar1),
}
impl Tablepclbrace {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                pclbraceVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                pclbraceVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:904:1, end:904:9))"]
#[derive(Clone, Debug)]
struct pcpbraceVar0 {}
impl pcpbraceVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:903:1, end:903:9))"]
#[derive(Clone, Debug)]
struct pcpbraceVar1 {
    pshlist: Tablepshlist,
}
impl pcpbraceVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.pshlist
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let pshlist = if let Some((len, table)) =
            Tablepshlist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { pshlist }))
    }
}
#[derive(Clone, Debug)]
enum Tablepcpbrace {
    Var0(pcpbraceVar0),
    Var1(pcpbraceVar1),
}
impl Tablepcpbrace {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                pcpbraceVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                pcpbraceVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:928:1, end:928:12))"]
#[derive(Clone, Debug)]
struct RnIndirect4Var0 {
    Rn0305: u8,
    immed5: u8,
}
impl RnIndirect4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_immval: i128 = 0;
        calc_immval = i128::try_from(self.immed5).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("["),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_immval.is_negative(), calc_immval.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2;
        calc_immval = i128::try_from(token_148(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let Rn0305 = token_153(tokens_current);
        let immed5 = token_148(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnIndirect4 {
    Var0(RnIndirect4Var0),
}
impl TableRnIndirect4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RnIndirect4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:929:1, end:929:12))"]
#[derive(Clone, Debug)]
struct RnIndirect2Var0 {
    Rn0305: u8,
    immed5: u8,
}
impl RnIndirect2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_immval: i128 = 0;
        calc_immval = i128::try_from(self.immed5).unwrap().wrapping_mul(2i128);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("["),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_immval.is_negative(), calc_immval.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2;
        calc_immval = i128::try_from(token_148(tokens_current))
            .unwrap()
            .wrapping_mul(2i128);
        let immed5 = token_148(tokens_current);
        let Rn0305 = token_153(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnIndirect2 {
    Var0(RnIndirect2Var0),
}
impl TableRnIndirect2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RnIndirect2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:930:1, end:930:12))"]
#[derive(Clone, Debug)]
struct RnIndirect1Var0 {
    Rn0305: u8,
    immed5: u8,
}
impl RnIndirect1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("["),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(true, false, self.immed5 as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0305 = token_153(tokens_current);
        let immed5 = token_148(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, immed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnIndirect1 {
    Var0(RnIndirect1Var0),
}
impl TableRnIndirect1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RnIndirect1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:932:1, end:932:13))"]
#[derive(Clone, Debug)]
struct RnRmIndirectVar0 {
    Rn0305: u8,
    Rm0608: u8,
}
impl RnRmIndirectVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("["),
            meaning_4_display(self.Rn0305),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.Rm0608),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0305 = token_153(tokens_current);
        let Rm0608 = token_147(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn0305, Rm0608 }))
    }
}
#[derive(Clone, Debug)]
enum TableRnRmIndirect {
    Var0(RnRmIndirectVar0),
}
impl TableRnRmIndirect {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                RnRmIndirectVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:934:1, end:934:15))"]
#[derive(Clone, Debug)]
struct Pcrel8IndirectVar0 {
    immed8: u8,
}
impl Pcrel8IndirectVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(self.immed8).unwrap()));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloc.is_negative(), calc_reloc.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = (i128::try_from(inst_start).unwrap().wrapping_add(4i128) & 4294967292i128)
            .wrapping_add(4i128.wrapping_mul(i128::try_from(token_149(tokens_current)).unwrap()));
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TablePcrel8Indirect {
    Var0(Pcrel8IndirectVar0),
}
impl TablePcrel8Indirect {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Pcrel8IndirectVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:940:1, end:940:15))"]
#[derive(Clone, Debug)]
struct Sprel8IndirectVar0 {
    immed8: u8,
}
impl Sprel8IndirectVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_immval: i128 = 0;
        calc_immval = i128::try_from(self.immed8).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_immval.is_negative(), calc_immval.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_immval: i128 = 0;
        let mut block_0_len = 2;
        calc_immval = i128::try_from(token_149(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let immed8 = token_149(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSprel8Indirect {
    Var0(Sprel8IndirectVar0),
}
impl TableSprel8Indirect {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                Sprel8IndirectVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:957:1, end:957:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar0 {}
impl thSRSModeVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("usr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:958:1, end:958:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar1 {}
impl thSRSModeVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("fiq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:959:1, end:959:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar2 {}
impl thSRSModeVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("irq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:960:1, end:960:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar3 {}
impl thSRSModeVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("svc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:961:1, end:961:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar4 {}
impl thSRSModeVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("mon")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:962:1, end:962:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar5 {}
impl thSRSModeVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("abt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:963:1, end:963:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar6 {}
impl thSRSModeVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("und")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:964:1, end:964:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar7 {}
impl thSRSModeVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("sys")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0004 = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:965:1, end:965:10))"]
#[derive(Clone, Debug)]
struct thSRSModeVar8 {
    thsrsMode: u8,
}
impl thSRSModeVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.thsrsMode as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thsrsMode = token_158(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { thsrsMode }))
    }
}
#[derive(Clone, Debug)]
enum TablethSRSMode {
    Var0(thSRSModeVar0),
    Var1(thSRSModeVar1),
    Var2(thSRSModeVar2),
    Var3(thSRSModeVar3),
    Var4(thSRSModeVar4),
    Var5(thSRSModeVar5),
    Var6(thSRSModeVar6),
    Var7(thSRSModeVar7),
    Var8(thSRSModeVar8),
}
impl TablethSRSMode {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 8 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 9 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 10 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 11 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 14 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 15 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 19 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 31) == 23 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                thSRSModeVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1499:1, end:1499:5))"]
#[derive(Clone, Debug)]
struct bxnsVar0 {}
impl bxnsVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ns")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:1498:1, end:1498:5))"]
#[derive(Clone, Debug)]
struct bxnsVar1 {}
impl bxnsVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let thc0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablebxns {
    Var0(bxnsVar0),
    Var1(bxnsVar1),
}
impl Tablebxns {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 7) == 4
        {
            if let Some((inst_len, parsed)) =
                bxnsVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 33554432 == 33554432 {
            if let Some((inst_len, parsed)) =
                bxnsVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3853:1, end:3853:7))"]
#[derive(Clone, Debug)]
struct thXBITVar0 {}
impl thXBITVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3854:1, end:3854:7))"]
#[derive(Clone, Debug)]
struct thXBITVar1 {}
impl thXBITVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rn0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethXBIT {
    Var0(thXBITVar0),
    Var1(thXBITVar1),
}
impl TablethXBIT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[3] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                thXBITVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[3] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                thXBITVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3856:1, end:3856:7))"]
#[derive(Clone, Debug)]
struct thYBITVar0 {}
impl thYBITVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3857:1, end:3857:7))"]
#[derive(Clone, Debug)]
struct thYBITVar1 {}
impl thYBITVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethYBIT {
    Var0(thYBITVar0),
    Var1(thYBITVar1),
}
impl TablethYBIT {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                thYBITVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                thYBITVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3867:1, end:3867:8))"]
#[derive(Clone, Debug)]
struct thdXbotVar0 {}
impl thdXbotVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3868:1, end:3868:8))"]
#[derive(Clone, Debug)]
struct thdXbotVar1 {}
impl thdXbotVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("X")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethdXbot {
    Var0(thdXbotVar0),
    Var1(thdXbotVar1),
}
impl TablethdXbot {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                thdXbotVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                thdXbotVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3870:1, end:3870:8))"]
#[derive(Clone, Debug)]
struct thdXtopVar0 {}
impl thdXtopVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMTHUMBinstructions.sinc, start:3871:1, end:3871:8))"]
#[derive(Clone, Debug)]
struct thdXtopVar1 {}
impl thdXtopVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("X")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Rm0003 = token_138(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TablethdXtop {
    Var0(thdXtopVar0),
    Var1(thdXtopVar1),
}
impl TablethdXtop {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                thdXtopVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 33554432 == 33554432
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                thdXtopVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
