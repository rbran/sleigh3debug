pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    A,
    B,
    D,
    IX,
    IY,
    TMP2,
    TMP3,
    TMP1,
    IXH,
    IXL,
    IYH,
    IYL,
    TMP2H,
    TMP2L,
    TMP3H,
    TMP3L,
    TMP1H,
    TMP1L,
    PCE,
    PC,
    SP,
    PCH,
    PCL,
    SPH,
    SPL,
    CCRW,
    CCRH,
    CCR,
    physPage,
    DIRECT,
    PPAGE,
    contextreg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::A => "A",
            Self::B => "B",
            Self::D => "D",
            Self::IX => "IX",
            Self::IY => "IY",
            Self::TMP2 => "TMP2",
            Self::TMP3 => "TMP3",
            Self::TMP1 => "TMP1",
            Self::IXH => "IXH",
            Self::IXL => "IXL",
            Self::IYH => "IYH",
            Self::IYL => "IYL",
            Self::TMP2H => "TMP2H",
            Self::TMP2L => "TMP2L",
            Self::TMP3H => "TMP3H",
            Self::TMP3L => "TMP3L",
            Self::TMP1H => "TMP1H",
            Self::TMP1L => "TMP1L",
            Self::PCE => "PCE",
            Self::PC => "PC",
            Self::SP => "SP",
            Self::PCH => "PCH",
            Self::PCL => "PCL",
            Self::SPH => "SPH",
            Self::SPL => "SPL",
            Self::CCRW => "CCRW",
            Self::CCRH => "CCRH",
            Self::CCR => "CCR",
            Self::physPage => "physPage",
            Self::DIRECT => "DIRECT",
            Self::PPAGE => "PPAGE",
            Self::contextreg => "contextreg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::IX,
        1 => Register::IY,
        2 => Register::SP,
        3 => Register::PC,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::IX,
        1 => Register::IY,
        2 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D,
        1 => Register::IX,
        2 => Register::IY,
        3 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        3 => Register::TMP3L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_9_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCRH,
        3 => Register::TMP3H,
        4 => Register::B,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_11_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_11_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_12_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_12_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_13_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        2 => Register::CCRW,
        3 => Register::TMP3,
        4 => Register::D,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_13_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_14_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2L,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_14_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_15_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2H,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_15_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_16_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3L,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_16_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_17_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3H,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_17_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_18_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP3,
        5 => Register::IX,
        6 => Register::IY,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_18_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_19_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A,
        1 => Register::B,
        2 => Register::CCR,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_19_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_20_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2H,
        4 => Register::A,
        5 => Register::IXH,
        6 => Register::IYH,
        7 => Register::SPH,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_20_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_21_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        3 => Register::TMP2L,
        4 => Register::B,
        5 => Register::IXL,
        6 => Register::IYL,
        7 => Register::SPL,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_21_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_22_value<T>(num: T) -> i8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 1,
        1 => 2,
        2 => 3,
        3 => 4,
        4 => 5,
        5 => 6,
        6 => 7,
        7 => 8,
        8 => -8,
        9 => -7,
        10 => -6,
        11 => -5,
        12 => -4,
        13 => -3,
        14 => -2,
        15 => -1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_22_value(num);
    <DisplayElement>::Number(hex, value.is_negative(), value.abs() as u64)
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: rr7_6 rr7_6a"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: op7_4 columns7_4"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: xb2_1"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 1) & 3) as u8)
}
#[doc = "Create token_fields: xb2_2"]
fn token_11(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: aa1_0"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: notUsed7_7"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: op15_13"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: xb5_5"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: xb7_5"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: op6_4 abcdxys6_4 bytes_ABCl_6_4 bytes_ABClT3lBXlYlSl_6_4 bytes_ABChT3hBXhYhSh_6_4 words_CT3DXYS_6_4 words_T3DXYS_6_4 bytes_T3lDlXlYlSl_6_4 bytes_T3l_XlYlSl_6_4 bytes_T3h_XhYhSh_6_4 words_T3_XYS_6_4"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: sign12_12"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: byte9_8 word9_8"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 3) as u8)
}
#[doc = "Create token_fields: rr4_3"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 3) & 3) as u8)
}
#[doc = "Create token_fields: imm16rv"]
fn token_31(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 4095) as u16)
}
#[doc = "Create token_fields: size10_10"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: not_used11"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: xb2_0 dxys2_0 abcdxys2_0 rows2_0 bytes_ABCl_2_0 words_T2DXYS_2_0 bytes_T2h_XhYhSh_2_0 bytes_T2l_XlYlSl_2_0 bytes_T2hDhXhYhSh_2_0 bytes_T2lDlXlYlSl_2_0"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: p4_4"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: op0_0 s0_0 ss0_0 aa0_0"]
fn token_5(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: rr7_0"]
fn token_27(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: imm16ev"]
fn token_30(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: imm16e"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 255) as u8)
}
#[doc = "Create token_fields: imm16p"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: z1_1"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: nn3_0 rows3_0"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: nn4_0"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: abc5_4"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: op16 imm16 simm16"]
fn token_21(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: op8 trapnum imm8 simm8 rel"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: nIndex"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 1) & 7) as u8)
}
#[doc = "Create token_fields: imm16pv"]
fn token_32(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 16383) as u16)
}
#[doc = "Create token_fields: decrement3_3"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u8::from_be_bytes(tokens[0..1].try_into().unwrap()) >> 3) & 1) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u8);
impl ContextMemory {
    pub fn read_Prefix18(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 1) as u8)
    }
    pub fn write_Prefix18(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 7)) | ((value as u8 & 1) << 7)).reverse_bits();
    }
    pub fn read_PrefixHCS12X(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 1) as u8)
    }
    pub fn write_PrefixHCS12X(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 7)) | ((value as u8 & 1) << 7)).reverse_bits();
    }
    pub fn read_UseGPAGE(&self) -> u8 {
        (((self.0.reverse_bits() >> 6) & 1) as u8)
    }
    pub fn write_UseGPAGE(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 6)) | ((value as u8 & 1) << 6)).reverse_bits();
    }
    pub fn read_XGATE(&self) -> u8 {
        (((self.0.reverse_bits() >> 5) & 1) as u8)
    }
    pub fn write_XGATE(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 5)) | ((value as u8 & 1) << 5)).reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:940:1, end:940:2))"]
#[derive(Clone, Debug)]
struct ABX_instructionVar0 {}
impl ABX_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ABX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_21(tokens) != 6885 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:945:1, end:945:2))"]
#[derive(Clone, Debug)]
struct ABY_instructionVar1 {}
impl ABY_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ABY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_21(tokens) != 6637 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2142:1, end:2142:2))"]
#[derive(Clone, Debug)]
struct CLC_instructionVar2 {}
impl CLC_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLC"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2147:1, end:2147:2))"]
#[derive(Clone, Debug)]
struct CLI_instructionVar3 {}
impl CLI_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2232:1, end:2232:2))"]
#[derive(Clone, Debug)]
struct CLV_instructionVar4 {}
impl CLV_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2877:1, end:2877:2))"]
#[derive(Clone, Debug)]
struct DES_instructionVar5 {}
impl DES_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DES"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3175:1, end:3175:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar6 {}
impl EXG_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 0 {
                        return None;
                    }
                    let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 12 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 8 {
                        return None;
                    }
                    let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 12 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3189:1, end:3189:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar7 {}
impl EXG_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 1 {
                        return None;
                    }
                    let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 12 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 9 {
                        return None;
                    }
                    let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 12 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3202:1, end:3202:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar8 {}
impl EXG_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 4 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 8 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 12 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 8 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3214:1, end:3214:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar9 {}
impl EXG_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::B),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c28 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c28(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 4 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 12 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3226:1, end:3226:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar10 {}
impl EXG_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRH),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 8 {
                    return None;
                }
                let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 10 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3238:1, end:3238:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar11 {}
impl EXG_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRH),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 10 {
                    return None;
                }
                let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 8 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3250:1, end:3250:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar12 {}
impl EXG_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRW),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CCRW"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c36 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c36(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 10 {
                    return None;
                }
                let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 10 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3259:1, end:3259:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar13 {
    bytes_ABCl_6_4: u8,
    bytes_ABCl_2_0: u8,
}
impl EXG_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_19_display(self.bytes_ABCl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.bytes_ABCl_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 0 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 1 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 8 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 9 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_2_0 = token_14(tokens_current);
        let bytes_ABCl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_ABCl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3274:1, end:3274:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar14 {
    bytes_ABCl_6_4: u8,
}
impl EXG_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_19_display(self.bytes_ABCl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 2 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 10 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bytes_ABCl_6_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3287:1, end:3287:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar15 {
    bytes_ABCl_2_0: u8,
}
impl EXG_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCR),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.bytes_ABCl_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 0 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 1 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 2 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 9 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { bytes_ABCl_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3302:1, end:3302:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar16 {
    bytes_T3l_XlYlSl_6_4: u8,
}
impl EXG_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.bytes_T3l_XlYlSl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 0 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 11 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 13 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 14 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 15 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 = token_3(tokens_current);
        let words_T3_XYS_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3313:1, end:3313:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar17 {
    bytes_T3h_XhYhSh_6_4: u8,
}
impl EXG_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_17_display(self.bytes_T3h_XhYhSh_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 8 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 11 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 13 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 14 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 15 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3h_XhYhSh_6_4 = token_3(tokens_current);
        let words_T3_XYS_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3h_XhYhSh_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3324:1, end:3324:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar18 {
    bytes_T3l_XlYlSl_6_4: u8,
}
impl EXG_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.bytes_T3l_XlYlSl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 1 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 11 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 13 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 14 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 15 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3_XYS_6_4 = token_3(tokens_current);
        let bytes_T3l_XlYlSl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar19 {
    bytes_T3l_XlYlSl_6_4: u8,
}
impl EXG_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_16_display(self.bytes_T3l_XlYlSl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 9 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 11 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 13 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 14 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 15 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T3l_XlYlSl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3l_XlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3346:1, end:3346:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar20 {
    bytes_T3lDlXlYlSl_6_4: u8,
}
impl EXG_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_11_display(self.bytes_T3lDlXlYlSl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 2 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 11 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 12 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 13 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 14 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 15 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_3(tokens_current);
        let bytes_T3lDlXlYlSl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T3lDlXlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3358:1, end:3358:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar21 {
    words_T3DXYS_6_4: u8,
}
impl EXG_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_12_display(self.words_T3DXYS_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRW),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 10 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 11 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 12 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 13 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 14 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 15 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T3DXYS_6_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3370:1, end:3370:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar22 {}
impl EXG_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TMP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 11 {
                    return None;
                }
                let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 12 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3382:1, end:3382:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar23 {}
impl EXG_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TMP1),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 12 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 11 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3393:1, end:3393:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar24 {
    words_T3DXYS_6_4: u8,
    words_T2DXYS_2_0: u8,
}
impl EXG_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_12_display(self.words_T3DXYS_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.words_T2DXYS_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 3 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 4 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 5 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 6 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 7 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 12 {
                        return None;
                    }
                    let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 11 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 12 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 13 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 14 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 15 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T3DXYS_6_4 = token_3(tokens_current);
        let words_T2DXYS_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                words_T3DXYS_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3416:1, end:3416:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar25 {
    bytes_ABCl_6_4: u8,
    words_T2DXYS_2_0: u8,
}
impl EXG_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_19_display(self.bytes_ABCl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.words_T2DXYS_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 3 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 5 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 6 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 7 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 8 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 9 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2lDlXlYlSl_2_0 = token_14(tokens_current);
        let bytes_ABCl_6_4 = token_3(tokens_current);
        let words_T2DXYS_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3431:1, end:3431:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar26 {
    bytes_ABCl_6_4: u8,
    bytes_T2hDhXhYhSh_2_0: u8,
}
impl EXG_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_19_display(self.bytes_ABCl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_20_display(self.bytes_T2hDhXhYhSh_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c61 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c61(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 8 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 8 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 8 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 8 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_6_4 = token_3(tokens_current);
        let bytes_T2hDhXhYhSh_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_T2hDhXhYhSh_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3447:1, end:3447:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar27 {
    bytes_ABCl_6_4: u8,
    bytes_T2lDlXlYlSl_2_0: u8,
}
impl EXG_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_19_display(self.bytes_ABCl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_21_display(self.bytes_T2lDlXlYlSl_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c61 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c61(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 9 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2lDlXlYlSl_2_0 = token_14(tokens_current);
        let bytes_ABCl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABCl_6_4,
                bytes_T2lDlXlYlSl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3462:1, end:3462:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar28 {
    words_T2DXYS_2_0: u8,
}
impl EXG_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCR),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.words_T2DXYS_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c45 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c45(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 3 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 4 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 5 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 6 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 7 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2lDlXlYlSl_2_0 = token_14(tokens_current);
        let words_T2DXYS_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3477:1, end:3477:2))"]
#[derive(Clone, Debug)]
struct EXG_instructionVar29 {
    words_T2DXYS_2_0: u8,
}
impl EXG_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EXG"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRW),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.words_T2DXYS_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 12 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 10 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3684:1, end:3684:2))"]
#[derive(Clone, Debug)]
struct INS_instructionVar30 {}
impl INS_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5161:1, end:5161:2))"]
#[derive(Clone, Debug)]
struct SEC_instructionVar31 {}
impl SEC_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SEC"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5166:1, end:5166:2))"]
#[derive(Clone, Debug)]
struct SEI_instructionVar32 {}
impl SEI_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SEI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5171:1, end:5171:2))"]
#[derive(Clone, Debug)]
struct SEV_instructionVar33 {}
impl SEV_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SEV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5226:1, end:5226:2))"]
#[derive(Clone, Debug)]
struct SEX_instructionVar34 {
    abc5_4: u8,
    dxys2_0: u8,
}
impl SEX_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SEX"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.abc5_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.dxys2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 3 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 4 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 5 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 6 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 7 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let abc5_4 = token_20(tokens_current);
        let dxys2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { abc5_4, dxys2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5635:1, end:5635:2))"]
#[derive(Clone, Debug)]
struct TAP_instructionVar35 {}
impl TAP_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TAP"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5678:1, end:5678:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar36 {
    bytes_ABClT3lBXlYlSl_6_4: u8,
    bytes_ABCl_2_0: u8,
}
impl TFR_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.bytes_ABClT3lBXlYlSl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_7_display(self.bytes_ABCl_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c64 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c64(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 0 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 1 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 8 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 9 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 0 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABCl_2_0 = token_14(tokens_current);
        let bytes_ABClT3lBXlYlSl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABClT3lBXlYlSl_6_4,
                bytes_ABCl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5692:1, end:5692:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar37 {
    bytes_ABClT3lBXlYlSl_6_4: u8,
}
impl TFR_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.bytes_ABClT3lBXlYlSl_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 2 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 1 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 2 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 10 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 1 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABClT3lBXlYlSl_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABClT3lBXlYlSl_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5704:1, end:5704:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar38 {
    bytes_ABChT3hBXhYhSh_6_4: u8,
}
impl TFR_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_9_display(self.bytes_ABChT3hBXhYhSh_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c51 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c51(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 8 {
                    return None;
                }
                let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 2 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 3 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 5 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 6 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 7 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_ABChT3hBXhYhSh_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_ABChT3hBXhYhSh_6_4,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5713:1, end:5713:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar39 {}
impl TFR_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRH),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 10 {
                    return None;
                }
                let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5722:1, end:5722:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar40 {
    words_CT3DXYS_6_4: u8,
}
impl TFR_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_13_display(self.words_CT3DXYS_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRW),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 10 {
                    return None;
                }
                let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                        if token_2(tokens_param) == 2 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 3 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 4 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 5 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 6 {
                            return Some(((), (), 1));
                        }
                        if token_2(tokens_param) == 7 {
                            return Some(((), (), 1));
                        }
                        None
                    };
                    let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_CT3DXYS_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_CT3DXYS_6_4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5731:1, end:5731:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar41 {
    words_T3DXYS_6_4: u8,
    words_T2DXYS_2_0: u8,
}
impl TFR_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_12_display(self.words_T3DXYS_6_4),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.words_T2DXYS_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c58 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c58(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 3 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 4 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 5 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 6 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 7 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 12 {
                        return None;
                    }
                    let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                            if token_2(tokens_param) == 3 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 4 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 5 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 6 {
                                return Some(((), (), 1));
                            }
                            if token_2(tokens_param) == 7 {
                                return Some(((), (), 1));
                            }
                            None
                        };
                        let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_14(tokens_current);
        let words_T3DXYS_6_4 = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                words_T3DXYS_6_4,
                words_T2DXYS_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5754:1, end:5754:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar42 {}
impl TFR_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TMP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 11 {
                    return None;
                }
                let mut sub_pattern_c88 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 4 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c88(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5763:1, end:5763:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar43 {}
impl TFR_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TMP1),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c31 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c31(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let mut block_0_len = 1;
                if token_17(tokens) != 12 {
                    return None;
                }
                let mut sub_pattern_c71 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_2(tokens) != 3 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let ((), (), sub_len) = sub_pattern_c71(tokens, &mut context_instance)?;
                block_0_len = block_0_len.max(sub_len);
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c4(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5772:1, end:5772:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar44 {
    words_T2DXYS_2_0: u8,
}
impl TFR_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CCRW),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.words_T2DXYS_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 2 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 12 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 2 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 2 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 2 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 2 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c54(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let words_T2DXYS_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { words_T2DXYS_2_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5785:1, end:5785:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar45 {
    bytes_T2h_XhYhSh_2_0: u8,
}
impl TFR_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_15_display(self.bytes_T2h_XhYhSh_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 0 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 0 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 0 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c20 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 0 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c20(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2h_XhYhSh_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T2h_XhYhSh_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5798:1, end:5798:2))"]
#[derive(Clone, Debug)]
struct TFR_instructionVar46 {
    bytes_T2l_XlYlSl_2_0: u8,
}
impl TFR_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TFR"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_14_display(self.bytes_T2l_XlYlSl_2_0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 183 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let mut sub_pattern_c2 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 11 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 1 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 13 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 1 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 14 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 1 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                let mut sub_pattern_c4 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 1;
                    if token_17(tokens) != 15 {
                        return None;
                    }
                    let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
                        let mut pattern_len = 0;
                        let mut context_instance = context_param.clone();
                        let mut tokens = tokens;
                        let mut block_0_len = 1;
                        if token_2(tokens) != 1 {
                            return None;
                        }
                        pattern_len += block_0_len;
                        tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                        *context_param = context_instance;
                        Some(((), (), pattern_len))
                    };
                    let ((), (), sub_len) = sub_pattern_c37(tokens, &mut context_instance)?;
                    block_0_len = block_0_len.max(sub_len);
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c4(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c2(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let bytes_T2l_XlYlSl_2_0 = token_14(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                bytes_T2l_XlYlSl_2_0,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5811:1, end:5811:2))"]
#[derive(Clone, Debug)]
struct TPA_instructionVar47 {}
impl TPA_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TPA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5904:1, end:5904:2))"]
#[derive(Clone, Debug)]
struct TSX_instructionVar48 {}
impl TSX_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TSX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5909:1, end:5909:2))"]
#[derive(Clone, Debug)]
struct TSY_instructionVar49 {}
impl TSY_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TSY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5914:1, end:5914:2))"]
#[derive(Clone, Debug)]
struct TXS_instructionVar50 {}
impl TXS_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TXS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5919:1, end:5919:2))"]
#[derive(Clone, Debug)]
struct TYS_instructionVar51 {}
impl TYS_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TYS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5955:1, end:5955:2))"]
#[derive(Clone, Debug)]
struct XGDX_instructionVar52 {}
impl XGDX_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XGDX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5962:1, end:5962:2))"]
#[derive(Clone, Debug)]
struct XGDY_instructionVar53 {}
impl XGDY_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("XGDY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2769:1, end:2769:2))"]
#[derive(Clone, Debug)]
struct DBEQ_instructionVar54 {
    byte9_8: u8,
    rel9: Tablerel9,
}
impl DBEQ_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DBEQ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.byte9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let byte9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2775:1, end:2775:2))"]
#[derive(Clone, Debug)]
struct DBEQ_instructionVar55 {
    word9_8: u8,
    rel9: Tablerel9,
}
impl DBEQ_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DBEQ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.word9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let word9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2781:1, end:2781:2))"]
#[derive(Clone, Debug)]
struct DBNE_instructionVar56 {
    byte9_8: u8,
    rel9: Tablerel9,
}
impl DBNE_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DBNE"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.byte9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let byte9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2787:1, end:2787:2))"]
#[derive(Clone, Debug)]
struct DBNE_instructionVar57 {
    word9_8: u8,
    rel9: Tablerel9,
}
impl DBNE_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DBNE"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.word9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let word9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3553:1, end:3553:2))"]
#[derive(Clone, Debug)]
struct IBEQ_instructionVar58 {
    byte9_8: u8,
    rel9: Tablerel9,
}
impl IBEQ_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IBEQ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.byte9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let byte9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3559:1, end:3559:2))"]
#[derive(Clone, Debug)]
struct IBEQ_instructionVar59 {
    word9_8: u8,
    rel9: Tablerel9,
}
impl IBEQ_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IBEQ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.word9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let word9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3565:1, end:3565:2))"]
#[derive(Clone, Debug)]
struct IBNE_instructionVar60 {
    byte9_8: u8,
    rel9: Tablerel9,
}
impl IBNE_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IBNE"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.byte9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let byte9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3571:1, end:3571:2))"]
#[derive(Clone, Debug)]
struct IBNE_instructionVar61 {
    word9_8: u8,
    rel9: Tablerel9,
}
impl IBNE_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IBNE"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.word9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let word9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5648:1, end:5648:2))"]
#[derive(Clone, Debug)]
struct TBEQ_instructionVar62 {
    byte9_8: u8,
    rel9: Tablerel9,
}
impl TBEQ_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TBEQ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.byte9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let byte9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5653:1, end:5653:2))"]
#[derive(Clone, Debug)]
struct TBEQ_instructionVar63 {
    word9_8: u8,
    rel9: Tablerel9,
}
impl TBEQ_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TBEQ"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.word9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let word9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5668:1, end:5668:2))"]
#[derive(Clone, Debug)]
struct TBNE_instructionVar64 {
    byte9_8: u8,
    rel9: Tablerel9,
}
impl TBNE_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TBNE"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.byte9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let byte9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, byte9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5673:1, end:5673:2))"]
#[derive(Clone, Debug)]
struct TBNE_instructionVar65 {
    word9_8: u8,
    rel9: Tablerel9,
}
impl TBNE_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TBNE"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.word9_8),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel9 = if let Some((len, table)) =
            Tablerel9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let word9_8 = token_26(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel9, word9_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:933:1, end:933:2))"]
#[derive(Clone, Debug)]
struct ABA_instructionVar66 {}
impl ABA_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ABA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c29 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if context_instance.read_Prefix18() != 1 {
                return None;
            }
            if token_1(tokens) != 6 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c29(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:950:1, end:950:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar67 {
    iopr8i: Tableiopr8i,
}
impl ADCA_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 137 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:960:1, end:960:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar68 {
    opr8a_8: Tableopr8a_8,
}
impl ADCA_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 153 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:970:1, end:970:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar69 {
    opr16a_8: Tableopr16a_8,
}
impl ADCA_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 185 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:980:1, end:980:2))"]
#[derive(Clone, Debug)]
struct ADCA_instructionVar70 {
    indexed1_5: Tableindexed1_5,
}
impl ADCA_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 169 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:989:1, end:989:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar71 {
    iopr8i: Tableiopr8i,
}
impl ADCB_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 201 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:999:1, end:999:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar72 {
    opr8a_8: Tableopr8a_8,
}
impl ADCB_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 217 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1008:1, end:1008:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar73 {
    opr16a_8: Tableopr16a_8,
}
impl ADCB_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 249 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1018:1, end:1018:2))"]
#[derive(Clone, Debug)]
struct ADCB_instructionVar74 {
    indexed1_5: Tableindexed1_5,
}
impl ADCB_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 233 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1028:1, end:1028:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar75 {
    iopr8i: Tableiopr8i,
}
impl ADDA_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 139 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1038:1, end:1038:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar76 {
    opr8a_8: Tableopr8a_8,
}
impl ADDA_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 155 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1047:1, end:1047:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar77 {
    opr16a_8: Tableopr16a_8,
}
impl ADDA_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 187 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1056:1, end:1056:2))"]
#[derive(Clone, Debug)]
struct ADDA_instructionVar78 {
    indexed1_5: Tableindexed1_5,
}
impl ADDA_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 171 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1065:1, end:1065:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar79 {
    iopr8i: Tableiopr8i,
}
impl ADDB_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 203 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1074:1, end:1074:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar80 {
    opr8a_8: Tableopr8a_8,
}
impl ADDB_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 219 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1083:1, end:1083:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar81 {
    opr16a_8: Tableopr16a_8,
}
impl ADDB_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 251 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1092:1, end:1092:2))"]
#[derive(Clone, Debug)]
struct ADDB_instructionVar82 {
    indexed1_5: Tableindexed1_5,
}
impl ADDB_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 235 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1101:1, end:1101:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar83 {
    iopr16i: Tableiopr16i,
}
impl ADDD_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 195 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1110:1, end:1110:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar84 {
    opr8a_16: Tableopr8a_16,
}
impl ADDD_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 211 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1119:1, end:1119:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar85 {
    opr16a_16: Tableopr16a_16,
}
impl ADDD_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 243 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1128:1, end:1128:2))"]
#[derive(Clone, Debug)]
struct ADDD_instructionVar86 {
    indexed2_5: Tableindexed2_5,
}
impl ADDD_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ADDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 227 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1357:1, end:1357:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar87 {
    iopr8i: Tableiopr8i,
}
impl ANDA_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 132 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1365:1, end:1365:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar88 {
    opr8a_8: Tableopr8a_8,
}
impl ANDA_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 148 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1373:1, end:1373:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar89 {
    opr16a_8: Tableopr16a_8,
}
impl ANDA_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 180 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1381:1, end:1381:2))"]
#[derive(Clone, Debug)]
struct ANDA_instructionVar90 {
    indexed1_5: Tableindexed1_5,
}
impl ANDA_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 164 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1389:1, end:1389:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar91 {
    iopr8i: Tableiopr8i,
}
impl ANDB_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 196 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1397:1, end:1397:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar92 {
    opr8a_8: Tableopr8a_8,
}
impl ANDB_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 212 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1405:1, end:1405:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar93 {
    opr16a_8: Tableopr16a_8,
}
impl ANDB_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 244 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1413:1, end:1413:2))"]
#[derive(Clone, Debug)]
struct ANDB_instructionVar94 {
    indexed1_5: Tableindexed1_5,
}
impl ANDB_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 228 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1421:1, end:1421:2))"]
#[derive(Clone, Debug)]
struct ANDCC_instructionVar95 {
    iopr8i: Tableiopr8i,
}
impl ANDCC_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ANDCC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 16 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1506:1, end:1506:2))"]
#[derive(Clone, Debug)]
struct ASL_instructionVar96 {
    opr16a_8: Tableopr16a_8,
}
impl ASL_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 120 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1517:1, end:1517:2))"]
#[derive(Clone, Debug)]
struct ASL_instructionVar97 {
    indexed1_5: Tableindexed1_5,
}
impl ASL_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 104 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1528:1, end:1528:2))"]
#[derive(Clone, Debug)]
struct ASLA_instructionVar98 {}
impl ASLA_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASLA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1537:1, end:1537:2))"]
#[derive(Clone, Debug)]
struct ASLB_instructionVar99 {}
impl ASLB_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASLB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1546:1, end:1546:2))"]
#[derive(Clone, Debug)]
struct ASLD_instructionVar100 {}
impl ASLD_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASLD"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1603:1, end:1603:2))"]
#[derive(Clone, Debug)]
struct ASR_instructionVar101 {
    opr16a_8: Tableopr16a_8,
}
impl ASR_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 119 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1614:1, end:1614:2))"]
#[derive(Clone, Debug)]
struct ASR_instructionVar102 {
    indexed1_5: Tableindexed1_5,
}
impl ASR_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 103 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1625:1, end:1625:2))"]
#[derive(Clone, Debug)]
struct ASRA_instructionVar103 {}
impl ASRA_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASRA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1634:1, end:1634:2))"]
#[derive(Clone, Debug)]
struct ASRB_instructionVar104 {}
impl ASRB_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ASRB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1691:1, end:1691:2))"]
#[derive(Clone, Debug)]
struct BCC_instructionVar105 {
    rel8: Tablerel8,
}
impl BCC_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BCC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1696:1, end:1696:2))"]
#[derive(Clone, Debug)]
struct BCLR_instructionVar106 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
}
impl BCLR_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BCLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c38 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 77 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c38(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1706:1, end:1706:2))"]
#[derive(Clone, Debug)]
struct BCLR_instructionVar107 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
}
impl BCLR_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BCLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c38 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 29 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c38(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1716:1, end:1716:2))"]
#[derive(Clone, Debug)]
struct BCLR_instructionVar108 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
}
impl BCLR_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BCLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c40 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 13 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c40(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_3 = if let Some((len, table)) =
            Tableindexed1_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1726:1, end:1726:2))"]
#[derive(Clone, Debug)]
struct BCS_instructionVar109 {
    rel8: Tablerel8,
}
impl BCS_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BCS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1731:1, end:1731:2))"]
#[derive(Clone, Debug)]
struct BEQ_instructionVar110 {
    rel8: Tablerel8,
}
impl BEQ_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BEQ"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1736:1, end:1736:2))"]
#[derive(Clone, Debug)]
struct BGE_instructionVar111 {
    rel8: Tablerel8,
}
impl BGE_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BGE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1742:1, end:1742:2))"]
#[derive(Clone, Debug)]
struct BGND_instructionVar112 {}
impl BGND_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BGND"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1751:1, end:1751:2))"]
#[derive(Clone, Debug)]
struct BGT_instructionVar113 {
    rel8: Tablerel8,
}
impl BGT_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BGT"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1756:1, end:1756:2))"]
#[derive(Clone, Debug)]
struct BHI_instructionVar114 {
    rel8: Tablerel8,
}
impl BHI_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BHI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1763:1, end:1763:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar115 {
    iopr8i: Tableiopr8i,
}
impl BITA_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 133 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1771:1, end:1771:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar116 {
    opr8a_8: Tableopr8a_8,
}
impl BITA_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 149 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1779:1, end:1779:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar117 {
    opr16a_8: Tableopr16a_8,
}
impl BITA_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 181 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1787:1, end:1787:2))"]
#[derive(Clone, Debug)]
struct BITA_instructionVar118 {
    indexed1_5: Tableindexed1_5,
}
impl BITA_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 165 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1795:1, end:1795:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar119 {
    iopr8i: Tableiopr8i,
}
impl BITB_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 197 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1803:1, end:1803:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar120 {
    opr8a_8: Tableopr8a_8,
}
impl BITB_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 213 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1811:1, end:1811:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar121 {
    opr16a_8: Tableopr16a_8,
}
impl BITB_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 245 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1819:1, end:1819:2))"]
#[derive(Clone, Debug)]
struct BITB_instructionVar122 {
    indexed1_5: Tableindexed1_5,
}
impl BITB_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BITB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 229 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1908:1, end:1908:2))"]
#[derive(Clone, Debug)]
struct BLE_instructionVar123 {
    rel8: Tablerel8,
}
impl BLE_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BLE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1915:1, end:1915:2))"]
#[derive(Clone, Debug)]
struct BLS_instructionVar124 {
    rel8: Tablerel8,
}
impl BLS_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BLS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1920:1, end:1920:2))"]
#[derive(Clone, Debug)]
struct BLT_instructionVar125 {
    rel8: Tablerel8,
}
impl BLT_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BLT"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1925:1, end:1925:2))"]
#[derive(Clone, Debug)]
struct BMI_instructionVar126 {
    rel8: Tablerel8,
}
impl BMI_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BMI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1930:1, end:1930:2))"]
#[derive(Clone, Debug)]
struct BNE_instructionVar127 {
    rel8: Tablerel8,
}
impl BNE_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BNE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1935:1, end:1935:2))"]
#[derive(Clone, Debug)]
struct BPL_instructionVar128 {
    rel8: Tablerel8,
}
impl BPL_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1940:1, end:1940:2))"]
#[derive(Clone, Debug)]
struct BRA_instructionVar129 {
    rel8: Tablerel8,
}
impl BRA_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1945:1, end:1945:2))"]
#[derive(Clone, Debug)]
struct BRCLR_instructionVar130 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRCLR_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRCLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current = &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr8a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1951:1, end:1951:2))"]
#[derive(Clone, Debug)]
struct BRCLR_instructionVar131 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRCLR_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRCLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current = &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1957:1, end:1957:2))"]
#[derive(Clone, Debug)]
struct BRCLR_instructionVar132 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRCLR_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRCLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_3 = if let Some((len, table)) =
            Tableindexed1_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current = &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_3,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1966:1, end:1966:2))"]
#[derive(Clone, Debug)]
struct BRN_instructionVar133 {
    SkipNextInstr: TableSkipNextInstr,
}
impl BRN_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRN"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.SkipNextInstr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let SkipNextInstr = if let Some((len, table)) =
            TableSkipNextInstr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNextInstr }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct BRSET_instructionVar134 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRSET_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRSET"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current = &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr8a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1977:1, end:1977:2))"]
#[derive(Clone, Debug)]
struct BRSET_instructionVar135 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRSET_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRSET"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current = &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1983:1, end:1983:2))"]
#[derive(Clone, Debug)]
struct BRSET_instructionVar136 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
    rel8: Tablerel8,
}
impl BRSET_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BRSET"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_3 = if let Some((len, table)) =
            Tableindexed1_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        let mut block_3_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_3_len = block_3_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_3_len;
        tokens_current = &tokens_current[usize::try_from(block_3_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_3,
                msk8,
                rel8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1989:1, end:1989:2))"]
#[derive(Clone, Debug)]
struct BSET_instructionVar137 {
    opr8a_8: Tableopr8a_8,
    msk8: Tablemsk8,
}
impl BSET_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BSET"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1998:1, end:1998:2))"]
#[derive(Clone, Debug)]
struct BSET_instructionVar138 {
    opr16a_8: Tableopr16a_8,
    msk8: Tablemsk8,
}
impl BSET_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BSET"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2007:1, end:2007:2))"]
#[derive(Clone, Debug)]
struct BSET_instructionVar139 {
    indexed1_3: Tableindexed1_3,
    msk8: Tablemsk8,
}
impl BSET_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BSET"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.msk8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_3 = if let Some((len, table)) =
            Tableindexed1_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let msk8 = if let Some((len, table)) =
            Tablemsk8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3, msk8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2016:1, end:2016:2))"]
#[derive(Clone, Debug)]
struct BSR_instructionVar140 {
    rel8: Tablerel8,
}
impl BSR_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BSR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2061:1, end:2061:2))"]
#[derive(Clone, Debug)]
struct BVC_instructionVar141 {
    rel8: Tablerel8,
}
impl BVC_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BVC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2066:1, end:2066:2))"]
#[derive(Clone, Debug)]
struct BVS_instructionVar142 {
    rel8: Tablerel8,
}
impl BVS_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("BVS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let rel8 = if let Some((len, table)) =
            Tablerel8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2080:1, end:2080:2))"]
#[derive(Clone, Debug)]
struct CALL_instructionVar143 {
    CallDest: TableCallDest,
}
impl CALL_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CallDest
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 3;
        let CallDest = if let Some((len, table)) =
            TableCallDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CallDest }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2096:1, end:2096:2))"]
#[derive(Clone, Debug)]
struct CALL_instructionVar144 {
    indexed2_3: Tableindexed2_3,
    page: Tablepage,
}
impl CALL_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.page
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 75 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_3 = if let Some((len, table)) =
            Tableindexed2_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let page = if let Some((len, table)) =
            Tablepage::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_3, page }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2113:1, end:2113:2))"]
#[derive(Clone, Debug)]
struct CALL_instructionVar145 {
    indexed0_2: Tableindexed0_2,
}
impl CALL_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CALL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed0_2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c37 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 75 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c37(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed0_2 = if let Some((len, table)) =
            Tableindexed0_2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2133:1, end:2133:2))"]
#[derive(Clone, Debug)]
struct CBA_instructionVar146 {}
impl CBA_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CBA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if context_instance.read_Prefix18() != 1 {
                return None;
            }
            if token_1(tokens) != 23 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2152:1, end:2152:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar147 {
    opr16a_8: Tableopr16a_8,
}
impl CLR_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 121 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct CLR_instructionVar148 {
    indexed1_5: Tableindexed1_5,
}
impl CLR_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 105 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2170:1, end:2170:2))"]
#[derive(Clone, Debug)]
struct CLRA_instructionVar149 {}
impl CLRA_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLRA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2179:1, end:2179:2))"]
#[derive(Clone, Debug)]
struct CLRB_instructionVar150 {}
impl CLRB_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CLRB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2237:1, end:2237:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar151 {
    iopr8i: Tableiopr8i,
}
impl CMPA_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 129 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2247:1, end:2247:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar152 {
    opr8a_8: Tableopr8a_8,
}
impl CMPA_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 145 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2257:1, end:2257:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar153 {
    opr16a_8: Tableopr16a_8,
}
impl CMPA_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 177 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2267:1, end:2267:2))"]
#[derive(Clone, Debug)]
struct CMPA_instructionVar154 {
    indexed1_5: Tableindexed1_5,
}
impl CMPA_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 161 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2277:1, end:2277:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar155 {
    iopr8i: Tableiopr8i,
}
impl CMPB_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 193 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2287:1, end:2287:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar156 {
    opr8a_8: Tableopr8a_8,
}
impl CMPB_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 209 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2297:1, end:2297:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar157 {
    opr16a_8: Tableopr16a_8,
}
impl CMPB_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 241 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2307:1, end:2307:2))"]
#[derive(Clone, Debug)]
struct CMPB_instructionVar158 {
    indexed1_5: Tableindexed1_5,
}
impl CMPB_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CMPB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 225 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2317:1, end:2317:2))"]
#[derive(Clone, Debug)]
struct COM_instructionVar159 {
    opr16a_8: Tableopr16a_8,
}
impl COM_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 113 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2327:1, end:2327:2))"]
#[derive(Clone, Debug)]
struct COM_instructionVar160 {
    indexed1_5: Tableindexed1_5,
}
impl COM_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 97 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2337:1, end:2337:2))"]
#[derive(Clone, Debug)]
struct COMA_instructionVar161 {}
impl COMA_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COMA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2346:1, end:2346:2))"]
#[derive(Clone, Debug)]
struct COMB_instructionVar162 {}
impl COMB_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("COMB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2401:1, end:2401:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar163 {
    iopr16i: Tableiopr16i,
}
impl CPD_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 140 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2411:1, end:2411:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar164 {
    opr8a_16: Tableopr8a_16,
}
impl CPD_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 156 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2421:1, end:2421:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar165 {
    opr16a_16: Tableopr16a_16,
}
impl CPD_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 188 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2431:1, end:2431:2))"]
#[derive(Clone, Debug)]
struct CPD_instructionVar166 {
    indexed2_5: Tableindexed2_5,
}
impl CPD_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 172 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2635:1, end:2635:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar167 {
    SkipNext2Bytes: TableSkipNext2Bytes,
}
impl CPS_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_loc: i128 = 0;
        calc_loc = (i128::try_from(inst_next).unwrap() & 16777215i128);
        display.push(DisplayElement::Literal("CPS"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_loc.is_negative(), calc_loc.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_loc: i128 = 0;
        let mut block_0_len = 1;
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 143 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let SkipNext2Bytes = if let Some((len, table)) =
            TableSkipNext2Bytes::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNext2Bytes }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2647:1, end:2647:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar168 {
    opr8a_16: Tableopr8a_16,
}
impl CPS_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 159 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2657:1, end:2657:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar169 {
    SkipNext2Bytes: TableSkipNext2Bytes,
}
impl CPS_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_loc: i128 = 0;
        calc_loc = (i128::try_from(inst_next).unwrap() & 16777215i128);
        display.push(DisplayElement::Literal("CPS"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_loc.is_negative(), calc_loc.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_loc: i128 = 0;
        let mut block_0_len = 1;
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 191 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let SkipNext2Bytes = if let Some((len, table)) =
            TableSkipNext2Bytes::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SkipNext2Bytes }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct CPS_instructionVar170 {
    indexed2_5: Tableindexed2_5,
}
impl CPS_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 175 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2680:1, end:2680:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar171 {
    iopr16i: Tableiopr16i,
}
impl CPX_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 142 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2690:1, end:2690:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar172 {
    opr8a_16: Tableopr8a_16,
}
impl CPX_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 158 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2700:1, end:2700:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar173 {
    opr16a_16: Tableopr16a_16,
}
impl CPX_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 190 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2710:1, end:2710:2))"]
#[derive(Clone, Debug)]
struct CPX_instructionVar174 {
    indexed2_5: Tableindexed2_5,
}
impl CPX_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 174 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2720:1, end:2720:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar175 {
    iopr16i: Tableiopr16i,
}
impl CPY_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 141 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2730:1, end:2730:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar176 {
    opr8a_16: Tableopr8a_16,
}
impl CPY_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 157 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2740:1, end:2740:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar177 {
    opr16a_16: Tableopr16a_16,
}
impl CPY_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 189 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2750:1, end:2750:2))"]
#[derive(Clone, Debug)]
struct CPY_instructionVar178 {
    indexed2_5: Tableindexed2_5,
}
impl CPY_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("CPY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 173 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2760:1, end:2760:2))"]
#[derive(Clone, Debug)]
struct DAA_instructionVar179 {}
impl DAA_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DAA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2793:1, end:2793:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar180 {
    opr16a_8: Tableopr16a_8,
}
impl DEC_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 115 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2803:1, end:2803:2))"]
#[derive(Clone, Debug)]
struct DEC_instructionVar181 {
    indexed1_5: Tableindexed1_5,
}
impl DEC_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 99 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2813:1, end:2813:2))"]
#[derive(Clone, Debug)]
struct DECA_instructionVar182 {}
impl DECA_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DECA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2822:1, end:2822:2))"]
#[derive(Clone, Debug)]
struct DECB_instructionVar183 {}
impl DECB_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DECB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2882:1, end:2882:2))"]
#[derive(Clone, Debug)]
struct DEX_instructionVar184 {}
impl DEX_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2888:1, end:2888:2))"]
#[derive(Clone, Debug)]
struct DEY_instructionVar185 {}
impl DEY_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("DEY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2894:1, end:2894:2))"]
#[derive(Clone, Debug)]
struct EDIV_instructionVar186 {}
impl EDIV_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EDIV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2907:1, end:2907:2))"]
#[derive(Clone, Debug)]
struct EDIVS_instructionVar187 {}
impl EDIVS_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EDIVS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2920:1, end:2920:2))"]
#[derive(Clone, Debug)]
struct EMACS_instructionVar188 {
    opr16a: Tableopr16a,
}
impl EMACS_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMACS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a = if let Some((len, table)) =
            Tableopr16a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2934:1, end:2934:2))"]
#[derive(Clone, Debug)]
struct EMAXD_instructionVar189 {
    indexed2_5: Tableindexed2_5,
}
impl EMAXD_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMAXD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2947:1, end:2947:2))"]
#[derive(Clone, Debug)]
struct EMAXM_instructionVar190 {
    indexed2_5: Tableindexed2_5,
}
impl EMAXM_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMAXM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2960:1, end:2960:2))"]
#[derive(Clone, Debug)]
struct EMIND_instructionVar191 {
    indexed2_5: Tableindexed2_5,
}
impl EMIND_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMIND"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2973:1, end:2973:2))"]
#[derive(Clone, Debug)]
struct EMINM_instructionVar192 {
    indexed2_5: Tableindexed2_5,
}
impl EMINM_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMINM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2986:1, end:2986:2))"]
#[derive(Clone, Debug)]
struct EMUL_instructionVar193 {}
impl EMUL_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMUL"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2996:1, end:2996:2))"]
#[derive(Clone, Debug)]
struct EMULS_instructionVar194 {}
impl EMULS_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EMULS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3006:1, end:3006:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar195 {
    iopr8i: Tableiopr8i,
}
impl EORA_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 136 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3015:1, end:3015:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar196 {
    opr8a_8: Tableopr8a_8,
}
impl EORA_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 152 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3024:1, end:3024:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar197 {
    opr16a_8: Tableopr16a_8,
}
impl EORA_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 184 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3033:1, end:3033:2))"]
#[derive(Clone, Debug)]
struct EORA_instructionVar198 {
    indexed1_5: Tableindexed1_5,
}
impl EORA_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 168 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3042:1, end:3042:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar199 {
    iopr8i: Tableiopr8i,
}
impl EORB_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 200 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3051:1, end:3051:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar200 {
    opr8a_8: Tableopr8a_8,
}
impl EORB_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 216 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3060:1, end:3060:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar201 {
    opr16a_8: Tableopr16a_8,
}
impl EORB_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 248 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3069:1, end:3069:2))"]
#[derive(Clone, Debug)]
struct EORB_instructionVar202 {
    indexed1_5: Tableindexed1_5,
}
impl EORB_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("EORB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 232 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3166:1, end:3166:2))"]
#[derive(Clone, Debug)]
struct ETBL_instructionVar203 {
    indexed2_1: Tableindexed2_1,
}
impl ETBL_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ETBL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_1 = if let Some((len, table)) =
            Tableindexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3492:1, end:3492:2))"]
#[derive(Clone, Debug)]
struct FDIV_instructionVar204 {}
impl FDIV_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("FDIV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3577:1, end:3577:2))"]
#[derive(Clone, Debug)]
struct IDIV_instructionVar205 {}
impl IDIV_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IDIV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3588:1, end:3588:2))"]
#[derive(Clone, Debug)]
struct IDIVS_instructionVar206 {}
impl IDIVS_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("IDIVS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3600:1, end:3600:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar207 {
    opr16a_8: Tableopr16a_8,
}
impl INC_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 114 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3610:1, end:3610:2))"]
#[derive(Clone, Debug)]
struct INC_instructionVar208 {
    indexed1_5: Tableindexed1_5,
}
impl INC_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 98 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3620:1, end:3620:2))"]
#[derive(Clone, Debug)]
struct INCA_instructionVar209 {}
impl INCA_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INCA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3629:1, end:3629:2))"]
#[derive(Clone, Debug)]
struct INCB_instructionVar210 {}
impl INCB_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INCB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3689:1, end:3689:2))"]
#[derive(Clone, Debug)]
struct INX_instructionVar211 {}
impl INX_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3695:1, end:3695:2))"]
#[derive(Clone, Debug)]
struct INY_instructionVar212 {}
impl INY_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("INY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3701:1, end:3701:2))"]
#[derive(Clone, Debug)]
struct JMP_instructionVar213 {
    opr16a: Tableopr16a,
}
impl JMP_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c44 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 6 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c44(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a = if let Some((len, table)) =
            Tableopr16a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3706:1, end:3706:2))"]
#[derive(Clone, Debug)]
struct JMP_instructionVar214 {
    indexedA_5: TableindexedA_5,
}
impl JMP_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JMP"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexedA_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 5 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexedA_5 = if let Some((len, table)) =
            TableindexedA_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexedA_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3711:1, end:3711:2))"]
#[derive(Clone, Debug)]
struct JSR_instructionVar215 {
    opr8a: Tableopr8a,
}
impl JSR_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 23 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a = if let Some((len, table)) =
            Tableopr8a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3719:1, end:3719:2))"]
#[derive(Clone, Debug)]
struct JSR_instructionVar216 {
    opr16a: Tableopr16a,
}
impl JSR_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c42 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 22 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c42(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a = if let Some((len, table)) =
            Tableopr16a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3727:1, end:3727:2))"]
#[derive(Clone, Debug)]
struct JSR_instructionVar217 {
    indexedA_5: TableindexedA_5,
}
impl JSR_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("JSR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexedA_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 21 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexedA_5 = if let Some((len, table)) =
            TableindexedA_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexedA_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3735:1, end:3735:2))"]
#[derive(Clone, Debug)]
struct LBCC_instructionVar218 {
    rel16: Tablerel16,
}
impl LBCC_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBCC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3740:1, end:3740:2))"]
#[derive(Clone, Debug)]
struct LBCS_instructionVar219 {
    rel16: Tablerel16,
}
impl LBCS_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBCS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3745:1, end:3745:2))"]
#[derive(Clone, Debug)]
struct LBEQ_instructionVar220 {
    rel16: Tablerel16,
}
impl LBEQ_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBEQ"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3750:1, end:3750:2))"]
#[derive(Clone, Debug)]
struct LBGE_instructionVar221 {
    rel16: Tablerel16,
}
impl LBGE_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBGE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3755:1, end:3755:2))"]
#[derive(Clone, Debug)]
struct LBGT_instructionVar222 {
    rel16: Tablerel16,
}
impl LBGT_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBGT"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3760:1, end:3760:2))"]
#[derive(Clone, Debug)]
struct LBHI_instructionVar223 {
    rel16: Tablerel16,
}
impl LBHI_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBHI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3767:1, end:3767:2))"]
#[derive(Clone, Debug)]
struct LBLE_instructionVar224 {
    rel16: Tablerel16,
}
impl LBLE_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBLE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3774:1, end:3774:2))"]
#[derive(Clone, Debug)]
struct LBLS_instructionVar225 {
    rel16: Tablerel16,
}
impl LBLS_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBLS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3779:1, end:3779:2))"]
#[derive(Clone, Debug)]
struct LBLT_instructionVar226 {
    rel16: Tablerel16,
}
impl LBLT_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBLT"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3784:1, end:3784:2))"]
#[derive(Clone, Debug)]
struct LBMI_instructionVar227 {
    rel16: Tablerel16,
}
impl LBMI_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBMI"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3789:1, end:3789:2))"]
#[derive(Clone, Debug)]
struct LBNE_instructionVar228 {
    rel16: Tablerel16,
}
impl LBNE_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBNE"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3794:1, end:3794:2))"]
#[derive(Clone, Debug)]
struct LBPL_instructionVar229 {
    rel16: Tablerel16,
}
impl LBPL_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBPL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3799:1, end:3799:2))"]
#[derive(Clone, Debug)]
struct LBRA_instructionVar230 {
    rel16: Tablerel16,
}
impl LBRA_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBRA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3805:1, end:3805:2))"]
#[derive(Clone, Debug)]
struct LBRN_instructionVar231 {
    rel16: Tablerel16,
}
impl LBRN_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBRN"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3809:1, end:3809:2))"]
#[derive(Clone, Debug)]
struct LBVC_instructionVar232 {
    rel16: Tablerel16,
}
impl LBVC_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBVC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3814:1, end:3814:2))"]
#[derive(Clone, Debug)]
struct LBVS_instructionVar233 {
    rel16: Tablerel16,
}
impl LBVS_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LBVS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rel16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rel16 = if let Some((len, table)) =
            Tablerel16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3819:1, end:3819:2))"]
#[derive(Clone, Debug)]
struct LDAA_instructionVar234 {
    iopr8i: Tableiopr8i,
}
impl LDAA_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDAA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 134 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3857:1, end:3857:2))"]
#[derive(Clone, Debug)]
struct LDAB_instructionVar235 {
    iopr8i: Tableiopr8i,
}
impl LDAB_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDAB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 198 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3892:1, end:3892:2))"]
#[derive(Clone, Debug)]
struct LDD_instructionVar236 {
    iopr16i: Tableiopr16i,
}
impl LDD_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 204 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3930:1, end:3930:2))"]
#[derive(Clone, Debug)]
struct LDS_instructionVar237 {
    iopr16i: Tableiopr16i,
}
impl LDS_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 207 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3965:1, end:3965:2))"]
#[derive(Clone, Debug)]
struct LDX_instructionVar238 {
    iopr16i: Tableiopr16i,
}
impl LDX_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 206 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4000:1, end:4000:2))"]
#[derive(Clone, Debug)]
struct LDY_instructionVar239 {
    iopr16i: Tableiopr16i,
}
impl LDY_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LDY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 205 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4035:1, end:4035:2))"]
#[derive(Clone, Debug)]
struct LEAS_instructionVar240 {
    indexed0_3: Tableindexed0_3,
}
impl LEAS_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LEAS"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed0_3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 27 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed0_3 = if let Some((len, table)) =
            Tableindexed0_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4040:1, end:4040:2))"]
#[derive(Clone, Debug)]
struct LEAX_instructionVar241 {
    indexed0_3: Tableindexed0_3,
}
impl LEAX_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LEAX"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed0_3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 26 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed0_3 = if let Some((len, table)) =
            Tableindexed0_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4045:1, end:4045:2))"]
#[derive(Clone, Debug)]
struct LEAY_instructionVar242 {
    indexed0_3: Tableindexed0_3,
}
impl LEAY_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LEAY"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed0_3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 25 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed0_3 = if let Some((len, table)) =
            Tableindexed0_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed0_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4060:1, end:4060:2))"]
#[derive(Clone, Debug)]
struct LSR_instructionVar243 {
    opr16a_8: Tableopr16a_8,
}
impl LSR_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LSR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 116 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4071:1, end:4071:2))"]
#[derive(Clone, Debug)]
struct LSR_instructionVar244 {
    indexed1_5: Tableindexed1_5,
}
impl LSR_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LSR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 100 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4082:1, end:4082:2))"]
#[derive(Clone, Debug)]
struct LSRA_instructionVar245 {}
impl LSRA_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LSRA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4091:1, end:4091:2))"]
#[derive(Clone, Debug)]
struct LSRB_instructionVar246 {}
impl LSRB_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LSRB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4100:1, end:4100:2))"]
#[derive(Clone, Debug)]
struct LSRD_instructionVar247 {}
impl LSRD_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("LSRD"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4157:1, end:4157:2))"]
#[derive(Clone, Debug)]
struct MAXA_instructionVar248 {
    indexed1_5: Tableindexed1_5,
}
impl MAXA_instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MAXA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4171:1, end:4171:2))"]
#[derive(Clone, Debug)]
struct MAXM_instructionVar249 {
    indexed1_5: Tableindexed1_5,
}
impl MAXM_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MAXM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4185:1, end:4185:2))"]
#[derive(Clone, Debug)]
struct MEM_instructionVar250 {}
impl MEM_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MEM"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4193:1, end:4193:2))"]
#[derive(Clone, Debug)]
struct MINA_instructionVar251 {
    indexed1_5: Tableindexed1_5,
}
impl MINA_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MINA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4207:1, end:4207:2))"]
#[derive(Clone, Debug)]
struct MINM_instructionVar252 {
    indexed1_5: Tableindexed1_5,
}
impl MINM_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MINM"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4221:1, end:4221:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar253 {
    iopr8i: Tableiopr8i,
    opr16a_8: Tableopr16a_8,
}
impl MOVB_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4232:1, end:4232:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar254 {
    indexed1_1: Tableindexed1_1,
    iopr8i: Tableiopr8i,
}
impl MOVB_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_1 = if let Some((len, table)) =
            Tableindexed1_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_1, iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4238:1, end:4238:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar255 {
    opr16a_8: Tableopr16a_8,
    op2_opr16a_8: Tableop2_opr16a_8,
}
impl MOVB_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.op2_opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let op2_opr16a_8 = if let Some((len, table)) =
            Tableop2_opr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_8,
                op2_opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4252:1, end:4252:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar256 {
    indexed1_1: Tableindexed1_1,
    opr16a_8: Tableopr16a_8,
}
impl MOVB_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_1 = if let Some((len, table)) =
            Tableindexed1_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4264:1, end:4264:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar257 {
    indexed1_1: Tableindexed1_1,
    opr16a_8: Tableopr16a_8,
}
impl MOVB_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_1 = if let Some((len, table)) =
            Tableindexed1_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                opr16a_8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4281:1, end:4281:2))"]
#[derive(Clone, Debug)]
struct MOVB_instructionVar258 {
    indexed1_1: Tableindexed1_1,
    op2_indexed1_1: Tableop2_indexed1_1,
}
impl MOVB_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.op2_indexed1_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_1 = if let Some((len, table)) =
            Tableindexed1_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let op2_indexed1_1 = if let Some((len, table)) =
            Tableop2_indexed1_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed1_1,
                op2_indexed1_1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4292:1, end:4292:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar259 {
    iopr16i: Tableiopr16i,
    opr16a_16: Tableopr16a_16,
}
impl MOVW_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4303:1, end:4303:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar260 {
    indexed2_1: Tableindexed2_1,
    iopr16i: Tableiopr16i,
}
impl MOVW_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_1 = if let Some((len, table)) =
            Tableindexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                iopr16i,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4309:1, end:4309:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar261 {
    opr16a_16: Tableopr16a_16,
    op2_opr16a_16: Tableop2_opr16a_16,
}
impl MOVW_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.op2_opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let op2_opr16a_16 = if let Some((len, table)) =
            Tableop2_opr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                opr16a_16,
                op2_opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4325:1, end:4325:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar262 {
    indexed2_1: Tableindexed2_1,
    opr16a_16: Tableopr16a_16,
}
impl MOVW_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_1 = if let Some((len, table)) =
            Tableindexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4337:1, end:4337:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar263 {
    indexed2_1: Tableindexed2_1,
    opr16a_16: Tableopr16a_16,
}
impl MOVW_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_1 = if let Some((len, table)) =
            Tableindexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                opr16a_16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4354:1, end:4354:2))"]
#[derive(Clone, Debug)]
struct MOVW_instructionVar264 {
    indexed2_1: Tableindexed2_1,
    op2_indexed2_1: Tableop2_indexed2_1,
}
impl MOVW_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MOVW"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.op2_indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_1 = if let Some((len, table)) =
            Tableindexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 1;
        let op2_indexed2_1 = if let Some((len, table)) =
            Tableop2_indexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                indexed2_1,
                op2_indexed2_1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4366:1, end:4366:2))"]
#[derive(Clone, Debug)]
struct MUL_instructionVar265 {}
impl MUL_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("MUL"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4372:1, end:4372:2))"]
#[derive(Clone, Debug)]
struct NEG_instructionVar266 {
    opr16a_8: Tableopr16a_8,
}
impl NEG_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NEG"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 112 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4383:1, end:4383:2))"]
#[derive(Clone, Debug)]
struct NEG_instructionVar267 {
    indexed1_5: Tableindexed1_5,
}
impl NEG_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NEG"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 96 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4394:1, end:4394:2))"]
#[derive(Clone, Debug)]
struct NEGA_instructionVar268 {}
impl NEGA_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NEGA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4404:1, end:4404:2))"]
#[derive(Clone, Debug)]
struct NEGB_instructionVar269 {}
impl NEGB_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NEGB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4464:1, end:4464:2))"]
#[derive(Clone, Debug)]
struct NOP_instructionVar270 {}
impl NOP_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("NOP"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4468:1, end:4468:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar271 {
    iopr8i: Tableiopr8i,
}
impl ORAA_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 138 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4476:1, end:4476:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar272 {
    opr8a_8: Tableopr8a_8,
}
impl ORAA_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 154 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4484:1, end:4484:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar273 {
    opr16a_8: Tableopr16a_8,
}
impl ORAA_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 186 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4492:1, end:4492:2))"]
#[derive(Clone, Debug)]
struct ORAA_instructionVar274 {
    indexed1_5: Tableindexed1_5,
}
impl ORAA_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 170 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4500:1, end:4500:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar275 {
    iopr8i: Tableiopr8i,
}
impl ORAB_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 202 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4508:1, end:4508:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar276 {
    opr8a_8: Tableopr8a_8,
}
impl ORAB_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 218 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4516:1, end:4516:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar277 {
    opr16a_8: Tableopr16a_8,
}
impl ORAB_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 250 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4524:1, end:4524:2))"]
#[derive(Clone, Debug)]
struct ORAB_instructionVar278 {
    indexed1_5: Tableindexed1_5,
}
impl ORAB_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORAB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 234 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4532:1, end:4532:2))"]
#[derive(Clone, Debug)]
struct ORCC_instructionVar279 {
    iopr8i: Tableiopr8i,
}
impl ORCC_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ORCC"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 20 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4617:1, end:4617:2))"]
#[derive(Clone, Debug)]
struct PSHA_instructionVar280 {}
impl PSHA_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PSHA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4622:1, end:4622:2))"]
#[derive(Clone, Debug)]
struct PSHB_instructionVar281 {}
impl PSHB_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PSHB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4627:1, end:4627:2))"]
#[derive(Clone, Debug)]
struct PSHC_instructionVar282 {}
impl PSHC_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PSHC"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4639:1, end:4639:2))"]
#[derive(Clone, Debug)]
struct PSHD_instructionVar283 {}
impl PSHD_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PSHD"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4644:1, end:4644:2))"]
#[derive(Clone, Debug)]
struct PSHX_instructionVar284 {}
impl PSHX_instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PSHX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4649:1, end:4649:2))"]
#[derive(Clone, Debug)]
struct PSHY_instructionVar285 {}
impl PSHY_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PSHY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4654:1, end:4654:2))"]
#[derive(Clone, Debug)]
struct PULA_instructionVar286 {}
impl PULA_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PULA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4659:1, end:4659:2))"]
#[derive(Clone, Debug)]
struct PULB_instructionVar287 {}
impl PULB_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PULB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4664:1, end:4664:2))"]
#[derive(Clone, Debug)]
struct PULC_instructionVar288 {}
impl PULC_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PULC"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4676:1, end:4676:2))"]
#[derive(Clone, Debug)]
struct PULD_instructionVar289 {}
impl PULD_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PULD"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4681:1, end:4681:2))"]
#[derive(Clone, Debug)]
struct PULX_instructionVar290 {}
impl PULX_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PULX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4686:1, end:4686:2))"]
#[derive(Clone, Debug)]
struct PULY_instructionVar291 {}
impl PULY_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("PULY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4691:1, end:4691:2))"]
#[derive(Clone, Debug)]
struct REV_instructionVar292 {}
impl REV_instructionVar292 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("REV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4699:1, end:4699:2))"]
#[derive(Clone, Debug)]
struct REVW_instructionVar293 {}
impl REVW_instructionVar293 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("REVW"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4709:1, end:4709:2))"]
#[derive(Clone, Debug)]
struct ROL_instructionVar294 {
    opr16a_8: Tableopr16a_8,
}
impl ROL_instructionVar294 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ROL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 117 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4722:1, end:4722:2))"]
#[derive(Clone, Debug)]
struct ROL_instructionVar295 {
    indexed1_5: Tableindexed1_5,
}
impl ROL_instructionVar295 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ROL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 101 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4735:1, end:4735:2))"]
#[derive(Clone, Debug)]
struct ROLA_instructionVar296 {}
impl ROLA_instructionVar296 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ROLA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4746:1, end:4746:2))"]
#[derive(Clone, Debug)]
struct ROLB_instructionVar297 {}
impl ROLB_instructionVar297 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ROLB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4813:1, end:4813:2))"]
#[derive(Clone, Debug)]
struct ROR_instructionVar298 {
    opr16a_8: Tableopr16a_8,
}
impl ROR_instructionVar298 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ROR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 118 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4826:1, end:4826:2))"]
#[derive(Clone, Debug)]
struct ROR_instructionVar299 {
    indexed1_5: Tableindexed1_5,
}
impl ROR_instructionVar299 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ROR"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 102 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4839:1, end:4839:2))"]
#[derive(Clone, Debug)]
struct RORA_instructionVar300 {}
impl RORA_instructionVar300 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RORA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4850:1, end:4850:2))"]
#[derive(Clone, Debug)]
struct RORB_instructionVar301 {}
impl RORB_instructionVar301 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RORB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4918:1, end:4918:2))"]
#[derive(Clone, Debug)]
struct RTC_instructionVar302 {}
impl RTC_instructionVar302 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RTC"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4929:1, end:4929:2))"]
#[derive(Clone, Debug)]
struct RTI_instructionVar303 {}
impl RTI_instructionVar303 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RTI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4942:1, end:4942:2))"]
#[derive(Clone, Debug)]
struct RTS_instructionVar304 {}
impl RTS_instructionVar304 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("RTS"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4950:1, end:4950:2))"]
#[derive(Clone, Debug)]
struct SBA_instructionVar305 {}
impl SBA_instructionVar305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c39 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 22 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c39(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4957:1, end:4957:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar306 {
    iopr8i: Tableiopr8i,
}
impl SBCA_instructionVar306 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 130 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4966:1, end:4966:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar307 {
    opr8a_8: Tableopr8a_8,
}
impl SBCA_instructionVar307 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 146 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4975:1, end:4975:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar308 {
    opr16a_8: Tableopr16a_8,
}
impl SBCA_instructionVar308 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 178 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4984:1, end:4984:2))"]
#[derive(Clone, Debug)]
struct SBCA_instructionVar309 {
    indexed1_5: Tableindexed1_5,
}
impl SBCA_instructionVar309 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 162 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4993:1, end:4993:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar310 {
    iopr8i: Tableiopr8i,
}
impl SBCB_instructionVar310 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 194 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5002:1, end:5002:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar311 {
    opr8a_8: Tableopr8a_8,
}
impl SBCB_instructionVar311 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 210 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5011:1, end:5011:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar312 {
    opr16a_8: Tableopr16a_8,
}
impl SBCB_instructionVar312 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 242 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5020:1, end:5020:2))"]
#[derive(Clone, Debug)]
struct SBCB_instructionVar313 {
    indexed1_5: Tableindexed1_5,
}
impl SBCB_instructionVar313 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SBCB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 226 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5320:1, end:5320:2))"]
#[derive(Clone, Debug)]
struct STOP_instructionVar314 {}
impl STOP_instructionVar314 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("STOP"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5415:1, end:5415:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar315 {
    iopr8i: Tableiopr8i,
}
impl SUBA_instructionVar315 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 128 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5424:1, end:5424:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar316 {
    opr8a_8: Tableopr8a_8,
}
impl SUBA_instructionVar316 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 144 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5433:1, end:5433:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar317 {
    opr16a_8: Tableopr16a_8,
}
impl SUBA_instructionVar317 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 176 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5442:1, end:5442:2))"]
#[derive(Clone, Debug)]
struct SUBA_instructionVar318 {
    indexed1_5: Tableindexed1_5,
}
impl SUBA_instructionVar318 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBA"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 160 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5451:1, end:5451:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar319 {
    iopr8i: Tableiopr8i,
}
impl SUBB_instructionVar319 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr8i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c46 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 192 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c46(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let iopr8i = if let Some((len, table)) =
            Tableiopr8i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr8i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5460:1, end:5460:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar320 {
    opr8a_8: Tableopr8a_8,
}
impl SUBB_instructionVar320 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 208 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5469:1, end:5469:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar321 {
    opr16a_8: Tableopr16a_8,
}
impl SUBB_instructionVar321 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 240 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5478:1, end:5478:2))"]
#[derive(Clone, Debug)]
struct SUBB_instructionVar322 {
    indexed1_5: Tableindexed1_5,
}
impl SUBB_instructionVar322 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBB"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 224 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5487:1, end:5487:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar323 {
    iopr16i: Tableiopr16i,
}
impl SUBD_instructionVar323 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.iopr16i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 131 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let iopr16i = if let Some((len, table)) =
            Tableiopr16i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { iopr16i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5496:1, end:5496:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar324 {
    opr8a_16: Tableopr8a_16,
}
impl SUBD_instructionVar324 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c48 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 147 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c48(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5505:1, end:5505:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar325 {
    opr16a_16: Tableopr16a_16,
}
impl SUBD_instructionVar325 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 179 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5514:1, end:5514:2))"]
#[derive(Clone, Debug)]
struct SUBD_instructionVar326 {
    indexed2_5: Tableindexed2_5,
}
impl SUBD_instructionVar326 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SUBD"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c50 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 163 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c50(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5611:1, end:5611:2))"]
#[derive(Clone, Debug)]
struct SWI_instructionVar327 {}
impl SWI_instructionVar327 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("SWI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5627:1, end:5627:2))"]
#[derive(Clone, Debug)]
struct TAB_instructionVar328 {}
impl TAB_instructionVar328 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TAB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5640:1, end:5640:2))"]
#[derive(Clone, Debug)]
struct TBA_instructionVar329 {}
impl TBA_instructionVar329 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TBA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5658:1, end:5658:2))"]
#[derive(Clone, Debug)]
struct TBL_instructionVar330 {
    indexed1_3: Tableindexed1_3,
}
impl TBL_instructionVar330 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TBL"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_3 = if let Some((len, table)) =
            Tableindexed1_3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5817:1, end:5817:2))"]
#[derive(Clone, Debug)]
struct TRAP_instructionVar331 {
    trapnum: u8,
}
impl TRAP_instructionVar331 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TRAP"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.trapnum as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let trapnum = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { trapnum }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5833:1, end:5833:2))"]
#[derive(Clone, Debug)]
struct TST_instructionVar332 {
    opr16a_8: Tableopr16a_8,
}
impl TST_instructionVar332 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TST"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c47 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 247 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c47(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5842:1, end:5842:2))"]
#[derive(Clone, Debug)]
struct TST_instructionVar333 {
    indexed1_5: Tableindexed1_5,
}
impl TST_instructionVar333 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TST"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c49 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 231 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c49(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5851:1, end:5851:2))"]
#[derive(Clone, Debug)]
struct TSTA_instructionVar334 {}
impl TSTA_instructionVar334 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TSTA"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5859:1, end:5859:2))"]
#[derive(Clone, Debug)]
struct TSTB_instructionVar335 {}
impl TSTB_instructionVar335 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TSTB"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5889:1, end:5889:2))"]
#[derive(Clone, Debug)]
struct TSTX_instructionVar336 {}
impl TSTX_instructionVar336 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TSTX"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5897:1, end:5897:2))"]
#[derive(Clone, Debug)]
struct TSTY_instructionVar337 {}
impl TSTY_instructionVar337 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("TSTY"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5924:1, end:5924:2))"]
#[derive(Clone, Debug)]
struct WAI_instructionVar338 {}
impl WAI_instructionVar338 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("WAI"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5937:1, end:5937:2))"]
#[derive(Clone, Debug)]
struct WAV_instructionVar339 {}
impl WAV_instructionVar339 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("WAV"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5950:1, end:5950:2))"]
#[derive(Clone, Debug)]
struct WAVR_instructionVar340 {}
impl WAVR_instructionVar340 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("WAVR"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:930:1, end:930:2))"]
#[derive(Clone, Debug)]
struct instructionVar341 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar341 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_Prefix18(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3830:1, end:3830:2))"]
#[derive(Clone, Debug)]
struct instructionVar342 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar342 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDAA"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 150 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3839:1, end:3839:2))"]
#[derive(Clone, Debug)]
struct instructionVar343 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar343 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDAA"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 182 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3848:1, end:3848:2))"]
#[derive(Clone, Debug)]
struct instructionVar344 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar344 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDAA"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 166 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3865:1, end:3865:2))"]
#[derive(Clone, Debug)]
struct instructionVar345 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar345 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDAB"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 214 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3874:1, end:3874:2))"]
#[derive(Clone, Debug)]
struct instructionVar346 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar346 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDAB"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 246 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3883:1, end:3883:2))"]
#[derive(Clone, Debug)]
struct instructionVar347 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar347 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDAB"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 230 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3900:1, end:3900:2))"]
#[derive(Clone, Debug)]
struct instructionVar348 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar348 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDD"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 220 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3909:1, end:3909:2))"]
#[derive(Clone, Debug)]
struct instructionVar349 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar349 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDD"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 252 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3918:1, end:3918:2))"]
#[derive(Clone, Debug)]
struct instructionVar350 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar350 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDD"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 236 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3938:1, end:3938:2))"]
#[derive(Clone, Debug)]
struct instructionVar351 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar351 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDS"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 223 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3947:1, end:3947:2))"]
#[derive(Clone, Debug)]
struct instructionVar352 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar352 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDS"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 255 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3956:1, end:3956:2))"]
#[derive(Clone, Debug)]
struct instructionVar353 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar353 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDS"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 239 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3973:1, end:3973:2))"]
#[derive(Clone, Debug)]
struct instructionVar354 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar354 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDX"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 222 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3982:1, end:3982:2))"]
#[derive(Clone, Debug)]
struct instructionVar355 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar355 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDX"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 254 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3991:1, end:3991:2))"]
#[derive(Clone, Debug)]
struct instructionVar356 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar356 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDX"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 238 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4008:1, end:4008:2))"]
#[derive(Clone, Debug)]
struct instructionVar357 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar357 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDY"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 221 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4017:1, end:4017:2))"]
#[derive(Clone, Debug)]
struct instructionVar358 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar358 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDY"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 253 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:4026:1, end:4026:2))"]
#[derive(Clone, Debug)]
struct instructionVar359 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar359 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("LDY"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 237 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5239:1, end:5239:2))"]
#[derive(Clone, Debug)]
struct instructionVar360 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar360 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STAA"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 90 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5248:1, end:5248:2))"]
#[derive(Clone, Debug)]
struct instructionVar361 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar361 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STAA"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 122 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5257:1, end:5257:2))"]
#[derive(Clone, Debug)]
struct instructionVar362 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar362 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STAA"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 106 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5266:1, end:5266:2))"]
#[derive(Clone, Debug)]
struct instructionVar363 {
    GPaged: TableGPaged,
    opr8a_8: Tableopr8a_8,
}
impl instructionVar363 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STAB"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 91 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_8 = if let Some((len, table)) =
            Tableopr8a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5275:1, end:5275:2))"]
#[derive(Clone, Debug)]
struct instructionVar364 {
    GPaged: TableGPaged,
    opr16a_8: Tableopr16a_8,
}
impl instructionVar364 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STAB"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 123 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5284:1, end:5284:2))"]
#[derive(Clone, Debug)]
struct instructionVar365 {
    GPaged: TableGPaged,
    indexed1_5: Tableindexed1_5,
}
impl instructionVar365 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STAB"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed1_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c56 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 107 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c56(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed1_5 = if let Some((len, table)) =
            Tableindexed1_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed1_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5293:1, end:5293:2))"]
#[derive(Clone, Debug)]
struct instructionVar366 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar366 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STD"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 92 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5302:1, end:5302:2))"]
#[derive(Clone, Debug)]
struct instructionVar367 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar367 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STD"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 124 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5311:1, end:5311:2))"]
#[derive(Clone, Debug)]
struct instructionVar368 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar368 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STD"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 108 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5334:1, end:5334:2))"]
#[derive(Clone, Debug)]
struct instructionVar369 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar369 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STS"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 95 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5343:1, end:5343:2))"]
#[derive(Clone, Debug)]
struct instructionVar370 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar370 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STS"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 127 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5352:1, end:5352:2))"]
#[derive(Clone, Debug)]
struct instructionVar371 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar371 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STS"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 111 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5361:1, end:5361:2))"]
#[derive(Clone, Debug)]
struct instructionVar372 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar372 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STX"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 94 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5370:1, end:5370:2))"]
#[derive(Clone, Debug)]
struct instructionVar373 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar373 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STX"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 126 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5379:1, end:5379:2))"]
#[derive(Clone, Debug)]
struct instructionVar374 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar374 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STX"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 110 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5388:1, end:5388:2))"]
#[derive(Clone, Debug)]
struct instructionVar375 {
    GPaged: TableGPaged,
    opr8a_16: Tableopr8a_16,
}
impl instructionVar375 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STY"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr8a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c53 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 93 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c53(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let opr8a_16 = if let Some((len, table)) =
            Tableopr8a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr8a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5397:1, end:5397:2))"]
#[derive(Clone, Debug)]
struct instructionVar376 {
    GPaged: TableGPaged,
    opr16a_16: Tableopr16a_16,
}
impl instructionVar376 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STY"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c54 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 125 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c54(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, opr16a_16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:5406:1, end:5406:2))"]
#[derive(Clone, Debug)]
struct instructionVar377 {
    GPaged: TableGPaged,
    indexed2_5: Tableindexed2_5,
}
impl instructionVar377 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.GPaged
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("STY"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.indexed2_5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        context_instance.write_UseGPAGE(
            u8::try_from(i128::try_from(context_instance.read_Prefix18()).unwrap() & 1).unwrap(),
        );
        let GPaged = if let Some((len, table)) =
            TableGPaged::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c55 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_1(tokens) != 109 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c55(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let indexed2_5 = if let Some((len, table)) =
            Tableindexed2_5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { GPaged, indexed2_5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(ABX_instructionVar0),
    Var1(ABY_instructionVar1),
    Var2(CLC_instructionVar2),
    Var3(CLI_instructionVar3),
    Var4(CLV_instructionVar4),
    Var5(DES_instructionVar5),
    Var6(EXG_instructionVar6),
    Var7(EXG_instructionVar7),
    Var8(EXG_instructionVar8),
    Var9(EXG_instructionVar9),
    Var10(EXG_instructionVar10),
    Var11(EXG_instructionVar11),
    Var12(EXG_instructionVar12),
    Var13(EXG_instructionVar13),
    Var14(EXG_instructionVar14),
    Var15(EXG_instructionVar15),
    Var16(EXG_instructionVar16),
    Var17(EXG_instructionVar17),
    Var18(EXG_instructionVar18),
    Var19(EXG_instructionVar19),
    Var20(EXG_instructionVar20),
    Var21(EXG_instructionVar21),
    Var22(EXG_instructionVar22),
    Var23(EXG_instructionVar23),
    Var24(EXG_instructionVar24),
    Var25(EXG_instructionVar25),
    Var26(EXG_instructionVar26),
    Var27(EXG_instructionVar27),
    Var28(EXG_instructionVar28),
    Var29(EXG_instructionVar29),
    Var30(INS_instructionVar30),
    Var31(SEC_instructionVar31),
    Var32(SEI_instructionVar32),
    Var33(SEV_instructionVar33),
    Var34(SEX_instructionVar34),
    Var35(TAP_instructionVar35),
    Var36(TFR_instructionVar36),
    Var37(TFR_instructionVar37),
    Var38(TFR_instructionVar38),
    Var39(TFR_instructionVar39),
    Var40(TFR_instructionVar40),
    Var41(TFR_instructionVar41),
    Var42(TFR_instructionVar42),
    Var43(TFR_instructionVar43),
    Var44(TFR_instructionVar44),
    Var45(TFR_instructionVar45),
    Var46(TFR_instructionVar46),
    Var47(TPA_instructionVar47),
    Var48(TSX_instructionVar48),
    Var49(TSY_instructionVar49),
    Var50(TXS_instructionVar50),
    Var51(TYS_instructionVar51),
    Var52(XGDX_instructionVar52),
    Var53(XGDY_instructionVar53),
    Var54(DBEQ_instructionVar54),
    Var55(DBEQ_instructionVar55),
    Var56(DBNE_instructionVar56),
    Var57(DBNE_instructionVar57),
    Var58(IBEQ_instructionVar58),
    Var59(IBEQ_instructionVar59),
    Var60(IBNE_instructionVar60),
    Var61(IBNE_instructionVar61),
    Var62(TBEQ_instructionVar62),
    Var63(TBEQ_instructionVar63),
    Var64(TBNE_instructionVar64),
    Var65(TBNE_instructionVar65),
    Var66(ABA_instructionVar66),
    Var67(ADCA_instructionVar67),
    Var68(ADCA_instructionVar68),
    Var69(ADCA_instructionVar69),
    Var70(ADCA_instructionVar70),
    Var71(ADCB_instructionVar71),
    Var72(ADCB_instructionVar72),
    Var73(ADCB_instructionVar73),
    Var74(ADCB_instructionVar74),
    Var75(ADDA_instructionVar75),
    Var76(ADDA_instructionVar76),
    Var77(ADDA_instructionVar77),
    Var78(ADDA_instructionVar78),
    Var79(ADDB_instructionVar79),
    Var80(ADDB_instructionVar80),
    Var81(ADDB_instructionVar81),
    Var82(ADDB_instructionVar82),
    Var83(ADDD_instructionVar83),
    Var84(ADDD_instructionVar84),
    Var85(ADDD_instructionVar85),
    Var86(ADDD_instructionVar86),
    Var87(ANDA_instructionVar87),
    Var88(ANDA_instructionVar88),
    Var89(ANDA_instructionVar89),
    Var90(ANDA_instructionVar90),
    Var91(ANDB_instructionVar91),
    Var92(ANDB_instructionVar92),
    Var93(ANDB_instructionVar93),
    Var94(ANDB_instructionVar94),
    Var95(ANDCC_instructionVar95),
    Var96(ASL_instructionVar96),
    Var97(ASL_instructionVar97),
    Var98(ASLA_instructionVar98),
    Var99(ASLB_instructionVar99),
    Var100(ASLD_instructionVar100),
    Var101(ASR_instructionVar101),
    Var102(ASR_instructionVar102),
    Var103(ASRA_instructionVar103),
    Var104(ASRB_instructionVar104),
    Var105(BCC_instructionVar105),
    Var106(BCLR_instructionVar106),
    Var107(BCLR_instructionVar107),
    Var108(BCLR_instructionVar108),
    Var109(BCS_instructionVar109),
    Var110(BEQ_instructionVar110),
    Var111(BGE_instructionVar111),
    Var112(BGND_instructionVar112),
    Var113(BGT_instructionVar113),
    Var114(BHI_instructionVar114),
    Var115(BITA_instructionVar115),
    Var116(BITA_instructionVar116),
    Var117(BITA_instructionVar117),
    Var118(BITA_instructionVar118),
    Var119(BITB_instructionVar119),
    Var120(BITB_instructionVar120),
    Var121(BITB_instructionVar121),
    Var122(BITB_instructionVar122),
    Var123(BLE_instructionVar123),
    Var124(BLS_instructionVar124),
    Var125(BLT_instructionVar125),
    Var126(BMI_instructionVar126),
    Var127(BNE_instructionVar127),
    Var128(BPL_instructionVar128),
    Var129(BRA_instructionVar129),
    Var130(BRCLR_instructionVar130),
    Var131(BRCLR_instructionVar131),
    Var132(BRCLR_instructionVar132),
    Var133(BRN_instructionVar133),
    Var134(BRSET_instructionVar134),
    Var135(BRSET_instructionVar135),
    Var136(BRSET_instructionVar136),
    Var137(BSET_instructionVar137),
    Var138(BSET_instructionVar138),
    Var139(BSET_instructionVar139),
    Var140(BSR_instructionVar140),
    Var141(BVC_instructionVar141),
    Var142(BVS_instructionVar142),
    Var143(CALL_instructionVar143),
    Var144(CALL_instructionVar144),
    Var145(CALL_instructionVar145),
    Var146(CBA_instructionVar146),
    Var147(CLR_instructionVar147),
    Var148(CLR_instructionVar148),
    Var149(CLRA_instructionVar149),
    Var150(CLRB_instructionVar150),
    Var151(CMPA_instructionVar151),
    Var152(CMPA_instructionVar152),
    Var153(CMPA_instructionVar153),
    Var154(CMPA_instructionVar154),
    Var155(CMPB_instructionVar155),
    Var156(CMPB_instructionVar156),
    Var157(CMPB_instructionVar157),
    Var158(CMPB_instructionVar158),
    Var159(COM_instructionVar159),
    Var160(COM_instructionVar160),
    Var161(COMA_instructionVar161),
    Var162(COMB_instructionVar162),
    Var163(CPD_instructionVar163),
    Var164(CPD_instructionVar164),
    Var165(CPD_instructionVar165),
    Var166(CPD_instructionVar166),
    Var167(CPS_instructionVar167),
    Var168(CPS_instructionVar168),
    Var169(CPS_instructionVar169),
    Var170(CPS_instructionVar170),
    Var171(CPX_instructionVar171),
    Var172(CPX_instructionVar172),
    Var173(CPX_instructionVar173),
    Var174(CPX_instructionVar174),
    Var175(CPY_instructionVar175),
    Var176(CPY_instructionVar176),
    Var177(CPY_instructionVar177),
    Var178(CPY_instructionVar178),
    Var179(DAA_instructionVar179),
    Var180(DEC_instructionVar180),
    Var181(DEC_instructionVar181),
    Var182(DECA_instructionVar182),
    Var183(DECB_instructionVar183),
    Var184(DEX_instructionVar184),
    Var185(DEY_instructionVar185),
    Var186(EDIV_instructionVar186),
    Var187(EDIVS_instructionVar187),
    Var188(EMACS_instructionVar188),
    Var189(EMAXD_instructionVar189),
    Var190(EMAXM_instructionVar190),
    Var191(EMIND_instructionVar191),
    Var192(EMINM_instructionVar192),
    Var193(EMUL_instructionVar193),
    Var194(EMULS_instructionVar194),
    Var195(EORA_instructionVar195),
    Var196(EORA_instructionVar196),
    Var197(EORA_instructionVar197),
    Var198(EORA_instructionVar198),
    Var199(EORB_instructionVar199),
    Var200(EORB_instructionVar200),
    Var201(EORB_instructionVar201),
    Var202(EORB_instructionVar202),
    Var203(ETBL_instructionVar203),
    Var204(FDIV_instructionVar204),
    Var205(IDIV_instructionVar205),
    Var206(IDIVS_instructionVar206),
    Var207(INC_instructionVar207),
    Var208(INC_instructionVar208),
    Var209(INCA_instructionVar209),
    Var210(INCB_instructionVar210),
    Var211(INX_instructionVar211),
    Var212(INY_instructionVar212),
    Var213(JMP_instructionVar213),
    Var214(JMP_instructionVar214),
    Var215(JSR_instructionVar215),
    Var216(JSR_instructionVar216),
    Var217(JSR_instructionVar217),
    Var218(LBCC_instructionVar218),
    Var219(LBCS_instructionVar219),
    Var220(LBEQ_instructionVar220),
    Var221(LBGE_instructionVar221),
    Var222(LBGT_instructionVar222),
    Var223(LBHI_instructionVar223),
    Var224(LBLE_instructionVar224),
    Var225(LBLS_instructionVar225),
    Var226(LBLT_instructionVar226),
    Var227(LBMI_instructionVar227),
    Var228(LBNE_instructionVar228),
    Var229(LBPL_instructionVar229),
    Var230(LBRA_instructionVar230),
    Var231(LBRN_instructionVar231),
    Var232(LBVC_instructionVar232),
    Var233(LBVS_instructionVar233),
    Var234(LDAA_instructionVar234),
    Var235(LDAB_instructionVar235),
    Var236(LDD_instructionVar236),
    Var237(LDS_instructionVar237),
    Var238(LDX_instructionVar238),
    Var239(LDY_instructionVar239),
    Var240(LEAS_instructionVar240),
    Var241(LEAX_instructionVar241),
    Var242(LEAY_instructionVar242),
    Var243(LSR_instructionVar243),
    Var244(LSR_instructionVar244),
    Var245(LSRA_instructionVar245),
    Var246(LSRB_instructionVar246),
    Var247(LSRD_instructionVar247),
    Var248(MAXA_instructionVar248),
    Var249(MAXM_instructionVar249),
    Var250(MEM_instructionVar250),
    Var251(MINA_instructionVar251),
    Var252(MINM_instructionVar252),
    Var253(MOVB_instructionVar253),
    Var254(MOVB_instructionVar254),
    Var255(MOVB_instructionVar255),
    Var256(MOVB_instructionVar256),
    Var257(MOVB_instructionVar257),
    Var258(MOVB_instructionVar258),
    Var259(MOVW_instructionVar259),
    Var260(MOVW_instructionVar260),
    Var261(MOVW_instructionVar261),
    Var262(MOVW_instructionVar262),
    Var263(MOVW_instructionVar263),
    Var264(MOVW_instructionVar264),
    Var265(MUL_instructionVar265),
    Var266(NEG_instructionVar266),
    Var267(NEG_instructionVar267),
    Var268(NEGA_instructionVar268),
    Var269(NEGB_instructionVar269),
    Var270(NOP_instructionVar270),
    Var271(ORAA_instructionVar271),
    Var272(ORAA_instructionVar272),
    Var273(ORAA_instructionVar273),
    Var274(ORAA_instructionVar274),
    Var275(ORAB_instructionVar275),
    Var276(ORAB_instructionVar276),
    Var277(ORAB_instructionVar277),
    Var278(ORAB_instructionVar278),
    Var279(ORCC_instructionVar279),
    Var280(PSHA_instructionVar280),
    Var281(PSHB_instructionVar281),
    Var282(PSHC_instructionVar282),
    Var283(PSHD_instructionVar283),
    Var284(PSHX_instructionVar284),
    Var285(PSHY_instructionVar285),
    Var286(PULA_instructionVar286),
    Var287(PULB_instructionVar287),
    Var288(PULC_instructionVar288),
    Var289(PULD_instructionVar289),
    Var290(PULX_instructionVar290),
    Var291(PULY_instructionVar291),
    Var292(REV_instructionVar292),
    Var293(REVW_instructionVar293),
    Var294(ROL_instructionVar294),
    Var295(ROL_instructionVar295),
    Var296(ROLA_instructionVar296),
    Var297(ROLB_instructionVar297),
    Var298(ROR_instructionVar298),
    Var299(ROR_instructionVar299),
    Var300(RORA_instructionVar300),
    Var301(RORB_instructionVar301),
    Var302(RTC_instructionVar302),
    Var303(RTI_instructionVar303),
    Var304(RTS_instructionVar304),
    Var305(SBA_instructionVar305),
    Var306(SBCA_instructionVar306),
    Var307(SBCA_instructionVar307),
    Var308(SBCA_instructionVar308),
    Var309(SBCA_instructionVar309),
    Var310(SBCB_instructionVar310),
    Var311(SBCB_instructionVar311),
    Var312(SBCB_instructionVar312),
    Var313(SBCB_instructionVar313),
    Var314(STOP_instructionVar314),
    Var315(SUBA_instructionVar315),
    Var316(SUBA_instructionVar316),
    Var317(SUBA_instructionVar317),
    Var318(SUBA_instructionVar318),
    Var319(SUBB_instructionVar319),
    Var320(SUBB_instructionVar320),
    Var321(SUBB_instructionVar321),
    Var322(SUBB_instructionVar322),
    Var323(SUBD_instructionVar323),
    Var324(SUBD_instructionVar324),
    Var325(SUBD_instructionVar325),
    Var326(SUBD_instructionVar326),
    Var327(SWI_instructionVar327),
    Var328(TAB_instructionVar328),
    Var329(TBA_instructionVar329),
    Var330(TBL_instructionVar330),
    Var331(TRAP_instructionVar331),
    Var332(TST_instructionVar332),
    Var333(TST_instructionVar333),
    Var334(TSTA_instructionVar334),
    Var335(TSTB_instructionVar335),
    Var336(TSTX_instructionVar336),
    Var337(TSTY_instructionVar337),
    Var338(WAI_instructionVar338),
    Var339(WAV_instructionVar339),
    Var340(WAVR_instructionVar340),
    Var341(instructionVar341),
    Var342(instructionVar342),
    Var343(instructionVar343),
    Var344(instructionVar344),
    Var345(instructionVar345),
    Var346(instructionVar346),
    Var347(instructionVar347),
    Var348(instructionVar348),
    Var349(instructionVar349),
    Var350(instructionVar350),
    Var351(instructionVar351),
    Var352(instructionVar352),
    Var353(instructionVar353),
    Var354(instructionVar354),
    Var355(instructionVar355),
    Var356(instructionVar356),
    Var357(instructionVar357),
    Var358(instructionVar358),
    Var359(instructionVar359),
    Var360(instructionVar360),
    Var361(instructionVar361),
    Var362(instructionVar362),
    Var363(instructionVar363),
    Var364(instructionVar364),
    Var365(instructionVar365),
    Var366(instructionVar366),
    Var367(instructionVar367),
    Var368(instructionVar368),
    Var369(instructionVar369),
    Var370(instructionVar370),
    Var371(instructionVar371),
    Var372(instructionVar372),
    Var373(instructionVar373),
    Var374(instructionVar374),
    Var375(instructionVar375),
    Var376(instructionVar376),
    Var377(instructionVar377),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var292(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var293(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var294(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var295(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var296(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var297(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var298(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var299(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var300(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var301(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var302(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var303(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var304(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var305(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var306(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var307(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var308(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var309(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var310(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var311(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var312(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var313(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var314(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var315(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var316(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var317(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var318(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var319(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var320(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var321(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var322(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var323(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var324(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var325(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var326(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var327(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var328(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var329(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var330(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var331(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var332(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var333(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var334(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var335(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var336(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var337(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var338(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var339(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var340(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var341(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var342(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var343(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var344(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var345(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var346(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var347(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var348(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var349(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var350(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var351(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var352(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var353(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var354(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var355(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var356(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var357(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var358(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var359(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var360(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var361(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var362(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var363(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var364(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var365(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var366(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var367(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var368(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var369(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var370(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var371(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var372(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var373(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var374(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var375(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var376(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var377(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 26
            && (tokens_param[1] & 255) == 229
        {
            if let Some((inst_len, parsed)) =
                ABX_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 255) == 237
        {
            if let Some((inst_len, parsed)) =
                ABY_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 255) == 254
        {
            if let Some((inst_len, parsed)) =
                CLC_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 255) == 239
        {
            if let Some((inst_len, parsed)) =
                CLI_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 255) == 253
        {
            if let Some((inst_len, parsed)) =
                CLV_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 27
            && (tokens_param[1] & 255) == 159
        {
            if let Some((inst_len, parsed)) =
                DES_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 247) == 192
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 247) == 193
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 247) == 132
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 247) == 148
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 168
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 138
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 170
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 230) == 128
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 231) == 130
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 244) == 160
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 128
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 136
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 129
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 137
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 130
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 138
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 203
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 188
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 232) == 128
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                EXG_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 27
            && (tokens_param[1] & 255) == 129
        {
            if let Some((inst_len, parsed)) =
                INS_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 255) == 1
        {
            if let Some((inst_len, parsed)) =
                SEC_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                SEI_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                SEV_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 200) == 0
        {
            if let Some((inst_len, parsed)) =
                SEX_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 2
        {
            if let Some((inst_len, parsed)) =
                TAP_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 134) == 0
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 135) == 2
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 8
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 10
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 143) == 10
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 75
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 60
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 40
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 248) == 24
        {
            if let Some((inst_len, parsed)) =
                TFR_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 32
        {
            if let Some((inst_len, parsed)) =
                TPA_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 117
        {
            if let Some((inst_len, parsed)) =
                TSX_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 118
        {
            if let Some((inst_len, parsed)) =
                TSY_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 87
        {
            if let Some((inst_len, parsed)) =
                TXS_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 103
        {
            if let Some((inst_len, parsed)) =
                TYS_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 197
        {
            if let Some((inst_len, parsed)) =
                XGDX_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 183
            && (tokens_param[1] & 255) == 198
        {
            if let Some((inst_len, parsed)) =
                XGDY_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 0
        {
            if let Some((inst_len, parsed)) =
                DBEQ_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 4
        {
            if let Some((inst_len, parsed)) =
                DBEQ_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 32
        {
            if let Some((inst_len, parsed)) =
                DBNE_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 36
        {
            if let Some((inst_len, parsed)) =
                DBNE_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 128
        {
            if let Some((inst_len, parsed)) =
                IBEQ_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 132
        {
            if let Some((inst_len, parsed)) =
                IBEQ_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 160
        {
            if let Some((inst_len, parsed)) =
                IBNE_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 164
        {
            if let Some((inst_len, parsed)) =
                IBNE_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 64
        {
            if let Some((inst_len, parsed)) =
                TBEQ_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 68
        {
            if let Some((inst_len, parsed)) =
                TBEQ_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 96
        {
            if let Some((inst_len, parsed)) =
                TBNE_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 3
            && context_param.0 & 5 == 0
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 228) == 100
        {
            if let Some((inst_len, parsed)) =
                TBNE_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 6 {
            if let Some((inst_len, parsed)) =
                ABA_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 137 {
            if let Some((inst_len, parsed)) =
                ADCA_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 153 {
            if let Some((inst_len, parsed)) =
                ADCA_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 185 {
            if let Some((inst_len, parsed)) =
                ADCA_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 169 {
            if let Some((inst_len, parsed)) =
                ADCA_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 201 {
            if let Some((inst_len, parsed)) =
                ADCB_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 217 {
            if let Some((inst_len, parsed)) =
                ADCB_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 249 {
            if let Some((inst_len, parsed)) =
                ADCB_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 233 {
            if let Some((inst_len, parsed)) =
                ADCB_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 139 {
            if let Some((inst_len, parsed)) =
                ADDA_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 155 {
            if let Some((inst_len, parsed)) =
                ADDA_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 187 {
            if let Some((inst_len, parsed)) =
                ADDA_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 171 {
            if let Some((inst_len, parsed)) =
                ADDA_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 203 {
            if let Some((inst_len, parsed)) =
                ADDB_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 219 {
            if let Some((inst_len, parsed)) =
                ADDB_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 251 {
            if let Some((inst_len, parsed)) =
                ADDB_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 235 {
            if let Some((inst_len, parsed)) =
                ADDB_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 195 {
            if let Some((inst_len, parsed)) =
                ADDD_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 211 {
            if let Some((inst_len, parsed)) =
                ADDD_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 243 {
            if let Some((inst_len, parsed)) =
                ADDD_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 227 {
            if let Some((inst_len, parsed)) =
                ADDD_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 132 {
            if let Some((inst_len, parsed)) =
                ANDA_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 148 {
            if let Some((inst_len, parsed)) =
                ANDA_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 180 {
            if let Some((inst_len, parsed)) =
                ANDA_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 164 {
            if let Some((inst_len, parsed)) =
                ANDA_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 196 {
            if let Some((inst_len, parsed)) =
                ANDB_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 212 {
            if let Some((inst_len, parsed)) =
                ANDB_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 244 {
            if let Some((inst_len, parsed)) =
                ANDB_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 228 {
            if let Some((inst_len, parsed)) =
                ANDB_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 16 {
            if let Some((inst_len, parsed)) =
                ANDCC_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 120 {
            if let Some((inst_len, parsed)) =
                ASL_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 104 {
            if let Some((inst_len, parsed)) =
                ASL_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 72 {
            if let Some((inst_len, parsed)) =
                ASLA_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 88 {
            if let Some((inst_len, parsed)) =
                ASLB_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 89 {
            if let Some((inst_len, parsed)) =
                ASLD_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 119 {
            if let Some((inst_len, parsed)) =
                ASR_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 103 {
            if let Some((inst_len, parsed)) =
                ASR_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 71 {
            if let Some((inst_len, parsed)) =
                ASRA_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 87 {
            if let Some((inst_len, parsed)) =
                ASRB_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 36 {
            if let Some((inst_len, parsed)) =
                BCC_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 77 {
            if let Some((inst_len, parsed)) =
                BCLR_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 29 {
            if let Some((inst_len, parsed)) =
                BCLR_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 13 {
            if let Some((inst_len, parsed)) =
                BCLR_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 37 {
            if let Some((inst_len, parsed)) =
                BCS_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 39 {
            if let Some((inst_len, parsed)) =
                BEQ_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 44 {
            if let Some((inst_len, parsed)) =
                BGE_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                BGND_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 46 {
            if let Some((inst_len, parsed)) =
                BGT_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 34 {
            if let Some((inst_len, parsed)) =
                BHI_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 133 {
            if let Some((inst_len, parsed)) =
                BITA_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 149 {
            if let Some((inst_len, parsed)) =
                BITA_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 181 {
            if let Some((inst_len, parsed)) =
                BITA_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 165 {
            if let Some((inst_len, parsed)) =
                BITA_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 197 {
            if let Some((inst_len, parsed)) =
                BITB_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 213 {
            if let Some((inst_len, parsed)) =
                BITB_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 245 {
            if let Some((inst_len, parsed)) =
                BITB_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 229 {
            if let Some((inst_len, parsed)) =
                BITB_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 47 {
            if let Some((inst_len, parsed)) =
                BLE_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 35 {
            if let Some((inst_len, parsed)) =
                BLS_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 45 {
            if let Some((inst_len, parsed)) =
                BLT_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 43 {
            if let Some((inst_len, parsed)) =
                BMI_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 38 {
            if let Some((inst_len, parsed)) =
                BNE_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 42 {
            if let Some((inst_len, parsed)) =
                BPL_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 32 {
            if let Some((inst_len, parsed)) =
                BRA_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 79 {
            if let Some((inst_len, parsed)) =
                BRCLR_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 5 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 31 {
            if let Some((inst_len, parsed)) =
                BRCLR_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 15 {
            if let Some((inst_len, parsed)) =
                BRCLR_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 33 {
            if let Some((inst_len, parsed)) =
                BRN_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 78 {
            if let Some((inst_len, parsed)) =
                BRSET_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 5 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 30 {
            if let Some((inst_len, parsed)) =
                BRSET_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 14 {
            if let Some((inst_len, parsed)) =
                BRSET_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 76 {
            if let Some((inst_len, parsed)) =
                BSET_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 28 {
            if let Some((inst_len, parsed)) =
                BSET_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 12 {
            if let Some((inst_len, parsed)) =
                BSET_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 7 {
            if let Some((inst_len, parsed)) =
                BSR_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 40 {
            if let Some((inst_len, parsed)) =
                BVC_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 41 {
            if let Some((inst_len, parsed)) =
                BVS_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 74 {
            if let Some((inst_len, parsed)) =
                CALL_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 75 {
            if let Some((inst_len, parsed)) =
                CALL_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 75 {
            if let Some((inst_len, parsed)) =
                CALL_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 23 {
            if let Some((inst_len, parsed)) =
                CBA_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 121 {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 105 {
            if let Some((inst_len, parsed)) =
                CLR_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 135 {
            if let Some((inst_len, parsed)) =
                CLRA_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 199 {
            if let Some((inst_len, parsed)) =
                CLRB_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 129 {
            if let Some((inst_len, parsed)) =
                CMPA_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 145 {
            if let Some((inst_len, parsed)) =
                CMPA_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 177 {
            if let Some((inst_len, parsed)) =
                CMPA_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 161 {
            if let Some((inst_len, parsed)) =
                CMPA_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 193 {
            if let Some((inst_len, parsed)) =
                CMPB_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 209 {
            if let Some((inst_len, parsed)) =
                CMPB_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 241 {
            if let Some((inst_len, parsed)) =
                CMPB_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 225 {
            if let Some((inst_len, parsed)) =
                CMPB_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 113 {
            if let Some((inst_len, parsed)) =
                COM_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 97 {
            if let Some((inst_len, parsed)) =
                COM_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 65 {
            if let Some((inst_len, parsed)) =
                COMA_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 81 {
            if let Some((inst_len, parsed)) =
                COMB_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 140 {
            if let Some((inst_len, parsed)) =
                CPD_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 156 {
            if let Some((inst_len, parsed)) =
                CPD_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 188 {
            if let Some((inst_len, parsed)) =
                CPD_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 172 {
            if let Some((inst_len, parsed)) =
                CPD_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 143 {
            if let Some((inst_len, parsed)) =
                CPS_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 159 {
            if let Some((inst_len, parsed)) =
                CPS_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 191 {
            if let Some((inst_len, parsed)) =
                CPS_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 175 {
            if let Some((inst_len, parsed)) =
                CPS_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 142 {
            if let Some((inst_len, parsed)) =
                CPX_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 158 {
            if let Some((inst_len, parsed)) =
                CPX_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 190 {
            if let Some((inst_len, parsed)) =
                CPX_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 174 {
            if let Some((inst_len, parsed)) =
                CPX_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 141 {
            if let Some((inst_len, parsed)) =
                CPY_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 157 {
            if let Some((inst_len, parsed)) =
                CPY_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 189 {
            if let Some((inst_len, parsed)) =
                CPY_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 173 {
            if let Some((inst_len, parsed)) =
                CPY_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 7 {
            if let Some((inst_len, parsed)) =
                DAA_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 115 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 99 {
            if let Some((inst_len, parsed)) =
                DEC_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 67 {
            if let Some((inst_len, parsed)) =
                DECA_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 83 {
            if let Some((inst_len, parsed)) =
                DECB_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 9 {
            if let Some((inst_len, parsed)) =
                DEX_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 3 {
            if let Some((inst_len, parsed)) =
                DEY_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 17 {
            if let Some((inst_len, parsed)) =
                EDIV_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 20 {
            if let Some((inst_len, parsed)) =
                EDIVS_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 18 {
            if let Some((inst_len, parsed)) =
                EMACS_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 26 {
            if let Some((inst_len, parsed)) =
                EMAXD_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 30 {
            if let Some((inst_len, parsed)) =
                EMAXM_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 27 {
            if let Some((inst_len, parsed)) =
                EMIND_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 31 {
            if let Some((inst_len, parsed)) =
                EMINM_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 19 {
            if let Some((inst_len, parsed)) =
                EMUL_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 19 {
            if let Some((inst_len, parsed)) =
                EMULS_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 136 {
            if let Some((inst_len, parsed)) =
                EORA_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 152 {
            if let Some((inst_len, parsed)) =
                EORA_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 184 {
            if let Some((inst_len, parsed)) =
                EORA_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 168 {
            if let Some((inst_len, parsed)) =
                EORA_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 200 {
            if let Some((inst_len, parsed)) =
                EORB_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 216 {
            if let Some((inst_len, parsed)) =
                EORB_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 248 {
            if let Some((inst_len, parsed)) =
                EORB_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 232 {
            if let Some((inst_len, parsed)) =
                EORB_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 63 {
            if let Some((inst_len, parsed)) =
                ETBL_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 17 {
            if let Some((inst_len, parsed)) =
                FDIV_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 16 {
            if let Some((inst_len, parsed)) =
                IDIV_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 21 {
            if let Some((inst_len, parsed)) =
                IDIVS_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 114 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 98 {
            if let Some((inst_len, parsed)) =
                INC_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 66 {
            if let Some((inst_len, parsed)) =
                INCA_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 82 {
            if let Some((inst_len, parsed)) =
                INCB_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 8 {
            if let Some((inst_len, parsed)) =
                INX_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 2 {
            if let Some((inst_len, parsed)) =
                INY_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 6 {
            if let Some((inst_len, parsed)) =
                JMP_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 5 {
            if let Some((inst_len, parsed)) =
                JMP_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 23 {
            if let Some((inst_len, parsed)) =
                JSR_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 22 {
            if let Some((inst_len, parsed)) =
                JSR_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 21 {
            if let Some((inst_len, parsed)) =
                JSR_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 36 {
            if let Some((inst_len, parsed)) =
                LBCC_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 37 {
            if let Some((inst_len, parsed)) =
                LBCS_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 39 {
            if let Some((inst_len, parsed)) =
                LBEQ_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 44 {
            if let Some((inst_len, parsed)) =
                LBGE_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 46 {
            if let Some((inst_len, parsed)) =
                LBGT_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 34 {
            if let Some((inst_len, parsed)) =
                LBHI_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 47 {
            if let Some((inst_len, parsed)) =
                LBLE_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 35 {
            if let Some((inst_len, parsed)) =
                LBLS_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 45 {
            if let Some((inst_len, parsed)) =
                LBLT_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 43 {
            if let Some((inst_len, parsed)) =
                LBMI_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 38 {
            if let Some((inst_len, parsed)) =
                LBNE_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 42 {
            if let Some((inst_len, parsed)) =
                LBPL_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 32 {
            if let Some((inst_len, parsed)) =
                LBRA_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 33 {
            if let Some((inst_len, parsed)) =
                LBRN_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 40 {
            if let Some((inst_len, parsed)) =
                LBVC_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 41 {
            if let Some((inst_len, parsed)) =
                LBVS_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 134 {
            if let Some((inst_len, parsed)) =
                LDAA_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 198 {
            if let Some((inst_len, parsed)) =
                LDAB_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 204 {
            if let Some((inst_len, parsed)) =
                LDD_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 207 {
            if let Some((inst_len, parsed)) =
                LDS_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 206 {
            if let Some((inst_len, parsed)) =
                LDX_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 205 {
            if let Some((inst_len, parsed)) =
                LDY_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 27 {
            if let Some((inst_len, parsed)) =
                LEAS_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 26 {
            if let Some((inst_len, parsed)) =
                LEAX_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 25 {
            if let Some((inst_len, parsed)) =
                LEAY_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 116 {
            if let Some((inst_len, parsed)) =
                LSR_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 100 {
            if let Some((inst_len, parsed)) =
                LSR_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 68 {
            if let Some((inst_len, parsed)) =
                LSRA_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 84 {
            if let Some((inst_len, parsed)) =
                LSRB_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 73 {
            if let Some((inst_len, parsed)) =
                LSRD_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 24 {
            if let Some((inst_len, parsed)) =
                MAXA_instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 28 {
            if let Some((inst_len, parsed)) =
                MAXM_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                MEM_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 25 {
            if let Some((inst_len, parsed)) =
                MINA_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 29 {
            if let Some((inst_len, parsed)) =
                MINM_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 11 {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 8 {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 5 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 12 {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 9 {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 13 {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 10 {
            if let Some((inst_len, parsed)) =
                MOVB_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 5 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 3 {
            if let Some((inst_len, parsed)) =
                MOVW_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                MOVW_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 5 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 4 {
            if let Some((inst_len, parsed)) =
                MOVW_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                MOVW_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 5 {
            if let Some((inst_len, parsed)) =
                MOVW_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 2 {
            if let Some((inst_len, parsed)) =
                MOVW_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 18 {
            if let Some((inst_len, parsed)) =
                MUL_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 112 {
            if let Some((inst_len, parsed)) =
                NEG_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 96 {
            if let Some((inst_len, parsed)) =
                NEG_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 64 {
            if let Some((inst_len, parsed)) =
                NEGA_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 80 {
            if let Some((inst_len, parsed)) =
                NEGB_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 167 {
            if let Some((inst_len, parsed)) =
                NOP_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 138 {
            if let Some((inst_len, parsed)) =
                ORAA_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 154 {
            if let Some((inst_len, parsed)) =
                ORAA_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 186 {
            if let Some((inst_len, parsed)) =
                ORAA_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 170 {
            if let Some((inst_len, parsed)) =
                ORAA_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 202 {
            if let Some((inst_len, parsed)) =
                ORAB_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 218 {
            if let Some((inst_len, parsed)) =
                ORAB_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 250 {
            if let Some((inst_len, parsed)) =
                ORAB_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 234 {
            if let Some((inst_len, parsed)) =
                ORAB_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 20 {
            if let Some((inst_len, parsed)) =
                ORCC_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 54 {
            if let Some((inst_len, parsed)) =
                PSHA_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 55 {
            if let Some((inst_len, parsed)) =
                PSHB_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 57 {
            if let Some((inst_len, parsed)) =
                PSHC_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 59 {
            if let Some((inst_len, parsed)) =
                PSHD_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 52 {
            if let Some((inst_len, parsed)) =
                PSHX_instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 53 {
            if let Some((inst_len, parsed)) =
                PSHY_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 50 {
            if let Some((inst_len, parsed)) =
                PULA_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 51 {
            if let Some((inst_len, parsed)) =
                PULB_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 56 {
            if let Some((inst_len, parsed)) =
                PULC_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 58 {
            if let Some((inst_len, parsed)) =
                PULD_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 48 {
            if let Some((inst_len, parsed)) =
                PULX_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 49 {
            if let Some((inst_len, parsed)) =
                PULY_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 58 {
            if let Some((inst_len, parsed)) =
                REV_instructionVar292::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var292(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 59 {
            if let Some((inst_len, parsed)) =
                REVW_instructionVar293::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var293(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 117 {
            if let Some((inst_len, parsed)) =
                ROL_instructionVar294::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var294(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 101 {
            if let Some((inst_len, parsed)) =
                ROL_instructionVar295::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var295(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 69 {
            if let Some((inst_len, parsed)) =
                ROLA_instructionVar296::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var296(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 85 {
            if let Some((inst_len, parsed)) =
                ROLB_instructionVar297::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var297(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 118 {
            if let Some((inst_len, parsed)) =
                ROR_instructionVar298::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var298(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 102 {
            if let Some((inst_len, parsed)) =
                ROR_instructionVar299::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var299(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 70 {
            if let Some((inst_len, parsed)) =
                RORA_instructionVar300::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var300(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 86 {
            if let Some((inst_len, parsed)) =
                RORB_instructionVar301::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var301(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 10 {
            if let Some((inst_len, parsed)) =
                RTC_instructionVar302::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var302(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 11 {
            if let Some((inst_len, parsed)) =
                RTI_instructionVar303::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var303(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 61 {
            if let Some((inst_len, parsed)) =
                RTS_instructionVar304::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var304(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 22 {
            if let Some((inst_len, parsed)) =
                SBA_instructionVar305::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var305(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 130 {
            if let Some((inst_len, parsed)) =
                SBCA_instructionVar306::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var306(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 146 {
            if let Some((inst_len, parsed)) =
                SBCA_instructionVar307::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var307(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 178 {
            if let Some((inst_len, parsed)) =
                SBCA_instructionVar308::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var308(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 162 {
            if let Some((inst_len, parsed)) =
                SBCA_instructionVar309::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var309(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 194 {
            if let Some((inst_len, parsed)) =
                SBCB_instructionVar310::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var310(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 210 {
            if let Some((inst_len, parsed)) =
                SBCB_instructionVar311::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var311(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 242 {
            if let Some((inst_len, parsed)) =
                SBCB_instructionVar312::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var312(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 226 {
            if let Some((inst_len, parsed)) =
                SBCB_instructionVar313::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var313(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 62 {
            if let Some((inst_len, parsed)) =
                STOP_instructionVar314::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var314(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 128 {
            if let Some((inst_len, parsed)) =
                SUBA_instructionVar315::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var315(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 144 {
            if let Some((inst_len, parsed)) =
                SUBA_instructionVar316::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var316(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 176 {
            if let Some((inst_len, parsed)) =
                SUBA_instructionVar317::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var317(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 160 {
            if let Some((inst_len, parsed)) =
                SUBA_instructionVar318::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var318(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 192 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar319::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var319(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 208 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar320::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var320(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 240 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar321::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var321(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 224 {
            if let Some((inst_len, parsed)) =
                SUBB_instructionVar322::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var322(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 131 {
            if let Some((inst_len, parsed)) =
                SUBD_instructionVar323::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var323(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 147 {
            if let Some((inst_len, parsed)) =
                SUBD_instructionVar324::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var324(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 179 {
            if let Some((inst_len, parsed)) =
                SUBD_instructionVar325::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var325(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 163 {
            if let Some((inst_len, parsed)) =
                SUBD_instructionVar326::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var326(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 63 {
            if let Some((inst_len, parsed)) =
                SWI_instructionVar327::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var327(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 14 {
            if let Some((inst_len, parsed)) =
                TAB_instructionVar328::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var328(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 15 {
            if let Some((inst_len, parsed)) =
                TBA_instructionVar329::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var329(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 61 {
            if let Some((inst_len, parsed)) =
                TBL_instructionVar330::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var330(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 48 {
            if let Some((inst_len, parsed)) =
                TRAP_instructionVar331::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var331(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 247 {
            if let Some((inst_len, parsed)) =
                TST_instructionVar332::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var332(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 231 {
            if let Some((inst_len, parsed)) =
                TST_instructionVar333::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var333(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 151 {
            if let Some((inst_len, parsed)) =
                TSTA_instructionVar334::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var334(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 215 {
            if let Some((inst_len, parsed)) =
                TSTB_instructionVar335::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var335(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 151 {
            if let Some((inst_len, parsed)) =
                TSTX_instructionVar336::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var336(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 215 {
            if let Some((inst_len, parsed)) =
                TSTY_instructionVar337::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var337(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 62 {
            if let Some((inst_len, parsed)) =
                WAI_instructionVar338::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var338(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 1 && (tokens_param[0] & 255) == 60 {
            if let Some((inst_len, parsed)) =
                WAV_instructionVar339::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var339(parsed)));
            }
        }
        if tokens_param.len() >= 1 && context_param.0 & 5 == 0 && (tokens_param[0] & 255) == 60 {
            if let Some((inst_len, parsed)) =
                WAVR_instructionVar340::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var340(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 24 {
            if let Some((inst_len, parsed)) =
                instructionVar341::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var341(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 150 {
            if let Some((inst_len, parsed)) =
                instructionVar342::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var342(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 182 {
            if let Some((inst_len, parsed)) =
                instructionVar343::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var343(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 166 {
            if let Some((inst_len, parsed)) =
                instructionVar344::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var344(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 214 {
            if let Some((inst_len, parsed)) =
                instructionVar345::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var345(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 246 {
            if let Some((inst_len, parsed)) =
                instructionVar346::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var346(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 230 {
            if let Some((inst_len, parsed)) =
                instructionVar347::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var347(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 220 {
            if let Some((inst_len, parsed)) =
                instructionVar348::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var348(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 252 {
            if let Some((inst_len, parsed)) =
                instructionVar349::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var349(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 236 {
            if let Some((inst_len, parsed)) =
                instructionVar350::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var350(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 223 {
            if let Some((inst_len, parsed)) =
                instructionVar351::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var351(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 255 {
            if let Some((inst_len, parsed)) =
                instructionVar352::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var352(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 239 {
            if let Some((inst_len, parsed)) =
                instructionVar353::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var353(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 222 {
            if let Some((inst_len, parsed)) =
                instructionVar354::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var354(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 254 {
            if let Some((inst_len, parsed)) =
                instructionVar355::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var355(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 238 {
            if let Some((inst_len, parsed)) =
                instructionVar356::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var356(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 221 {
            if let Some((inst_len, parsed)) =
                instructionVar357::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var357(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 253 {
            if let Some((inst_len, parsed)) =
                instructionVar358::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var358(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 237 {
            if let Some((inst_len, parsed)) =
                instructionVar359::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var359(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 90 {
            if let Some((inst_len, parsed)) =
                instructionVar360::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var360(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 122 {
            if let Some((inst_len, parsed)) =
                instructionVar361::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var361(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 106 {
            if let Some((inst_len, parsed)) =
                instructionVar362::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var362(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 91 {
            if let Some((inst_len, parsed)) =
                instructionVar363::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var363(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 123 {
            if let Some((inst_len, parsed)) =
                instructionVar364::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var364(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 107 {
            if let Some((inst_len, parsed)) =
                instructionVar365::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var365(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 92 {
            if let Some((inst_len, parsed)) =
                instructionVar366::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var366(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 124 {
            if let Some((inst_len, parsed)) =
                instructionVar367::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var367(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 108 {
            if let Some((inst_len, parsed)) =
                instructionVar368::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var368(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 95 {
            if let Some((inst_len, parsed)) =
                instructionVar369::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var369(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 127 {
            if let Some((inst_len, parsed)) =
                instructionVar370::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var370(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 111 {
            if let Some((inst_len, parsed)) =
                instructionVar371::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var371(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 94 {
            if let Some((inst_len, parsed)) =
                instructionVar372::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var372(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 126 {
            if let Some((inst_len, parsed)) =
                instructionVar373::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var373(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 110 {
            if let Some((inst_len, parsed)) =
                instructionVar374::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var374(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 93 {
            if let Some((inst_len, parsed)) =
                instructionVar375::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var375(parsed)));
            }
        }
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 125 {
            if let Some((inst_len, parsed)) =
                instructionVar376::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var376(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 4 == 0 && (tokens_param[0] & 255) == 109 {
            if let Some((inst_len, parsed)) =
                instructionVar377::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var377(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:409:1, end:409:7))"]
#[derive(Clone, Debug)]
struct opr16aVar0 {
    imm16: u16,
}
impl opr16aVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16pv = token_32(tokens_current);
        let imm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:410:1, end:410:7))"]
#[derive(Clone, Debug)]
struct opr16aVar1 {
    imm16: u16,
}
impl opr16aVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:411:1, end:411:7))"]
#[derive(Clone, Debug)]
struct opr16aVar2 {
    imm16: u16,
}
impl opr16aVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:412:1, end:412:7))"]
#[derive(Clone, Debug)]
struct opr16aVar3 {
    imm16: u16,
}
impl opr16aVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:414:1, end:414:7))"]
#[derive(Clone, Debug)]
struct opr16aVar4 {
    imm16: u16,
}
impl opr16aVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:415:1, end:415:7))"]
#[derive(Clone, Debug)]
struct opr16aVar5 {
    imm16: u16,
}
impl opr16aVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:416:1, end:416:7))"]
#[derive(Clone, Debug)]
struct opr16aVar6 {
    imm16: u16,
}
impl opr16aVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:417:1, end:417:7))"]
#[derive(Clone, Debug)]
struct opr16aVar7 {
    imm16: u16,
}
impl opr16aVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16pv = token_32(tokens_current);
        let imm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:419:1, end:419:7))"]
#[derive(Clone, Debug)]
struct opr16aVar8 {
    imm16: u16,
}
impl opr16aVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:420:1, end:420:7))"]
#[derive(Clone, Debug)]
struct opr16aVar9 {
    imm16: u16,
}
impl opr16aVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:421:1, end:421:7))"]
#[derive(Clone, Debug)]
struct opr16aVar10 {
    imm16: u16,
}
impl opr16aVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:422:1, end:422:7))"]
#[derive(Clone, Debug)]
struct opr16aVar11 {
    imm16: u16,
}
impl opr16aVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:424:1, end:424:7))"]
#[derive(Clone, Debug)]
struct opr16aVar12 {
    imm16: u16,
}
impl opr16aVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16pv = token_32(tokens_current);
        let imm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:425:1, end:425:7))"]
#[derive(Clone, Debug)]
struct opr16aVar13 {
    imm16: u16,
}
impl opr16aVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:426:1, end:426:7))"]
#[derive(Clone, Debug)]
struct opr16aVar14 {
    imm16: u16,
}
impl opr16aVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16pv = token_32(tokens_current);
        let imm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:427:1, end:427:7))"]
#[derive(Clone, Debug)]
struct opr16aVar15 {
    imm16: u16,
}
impl opr16aVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm16 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        let imm16pv = token_32(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a {
    Var0(opr16aVar0),
    Var1(opr16aVar1),
    Var2(opr16aVar2),
    Var3(opr16aVar3),
    Var4(opr16aVar4),
    Var5(opr16aVar5),
    Var6(opr16aVar6),
    Var7(opr16aVar7),
    Var8(opr16aVar8),
    Var9(opr16aVar9),
    Var10(opr16aVar10),
    Var11(opr16aVar11),
    Var12(opr16aVar12),
    Var13(opr16aVar13),
    Var14(opr16aVar14),
    Var15(opr16aVar15),
}
impl Tableopr16a {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                opr16aVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                opr16aVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                opr16aVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                opr16aVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                opr16aVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                opr16aVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 96 {
            if let Some((inst_len, parsed)) =
                opr16aVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                opr16aVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                opr16aVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                opr16aVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                opr16aVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                opr16aVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                opr16aVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                opr16aVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 224 {
            if let Some((inst_len, parsed)) =
                opr16aVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 240) == 240 {
            if let Some((inst_len, parsed)) =
                opr16aVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:429:1, end:429:5))"]
#[derive(Clone, Debug)]
struct pageVar0 {
    imm8: u8,
}
impl pageVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm8 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablepage {
    Var0(pageVar0),
}
impl Tablepage {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                pageVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:431:1, end:431:9))"]
#[derive(Clone, Debug)]
struct PageDestVar0 {
    opr16a: Tableopr16a,
    page: Tablepage,
}
impl PageDestVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.opr16a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let opr16a = if let Some((len, table)) =
            Tableopr16a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let page = if let Some((len, table)) =
            Tablepage::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a, page }))
    }
}
#[derive(Clone, Debug)]
enum TablePageDest {
    Var0(PageDestVar0),
}
impl TablePageDest {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                PageDestVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:437:1, end:437:6))"]
#[derive(Clone, Debug)]
struct opr8aVar0 {
    imm8: u8,
}
impl opr8aVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm8 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a {
    Var0(opr8aVar0),
}
impl Tableopr8a {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                opr8aVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:439:1, end:439:8))"]
#[derive(Clone, Debug)]
struct opr8a_8Var0 {
    imm8: u8,
}
impl opr8a_8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm8 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a_8 {
    Var0(opr8a_8Var0),
}
impl Tableopr8a_8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && context_param.0 & 2 == 0 {
            if let Some((inst_len, parsed)) =
                opr8a_8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:440:1, end:440:9))"]
#[derive(Clone, Debug)]
struct opr8a_16Var0 {
    imm8: u8,
}
impl opr8a_16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm8 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr8a_16 {
    Var0(opr8a_16Var0),
}
impl Tableopr8a_16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && context_param.0 & 2 == 0 {
            if let Some((inst_len, parsed)) =
                opr8a_16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:442:1, end:442:9))"]
#[derive(Clone, Debug)]
struct opr16a_8Var0 {
    opr16a: Tableopr16a,
}
impl opr16a_8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.opr16a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let opr16a = if let Some((len, table)) =
            Tableopr16a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a_8 {
    Var0(opr16a_8Var0),
}
impl Tableopr16a_8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                opr16a_8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:443:1, end:443:10))"]
#[derive(Clone, Debug)]
struct opr16a_16Var0 {
    opr16a: Tableopr16a,
}
impl opr16a_16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.opr16a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let opr16a = if let Some((len, table)) =
            Tableopr16a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a }))
    }
}
#[derive(Clone, Debug)]
enum Tableopr16a_16 {
    Var0(opr16a_16Var0),
}
impl Tableopr16a_16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                opr16a_16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:445:1, end:445:7))"]
#[derive(Clone, Debug)]
struct iopr8iVar0 {
    imm8: u8,
}
impl iopr8iVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.imm8 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableiopr8i {
    Var0(iopr8iVar0),
}
impl Tableiopr8i {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                iopr8iVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:446:1, end:446:8))"]
#[derive(Clone, Debug)]
struct iopr16iVar0 {
    imm16: u16,
}
impl iopr16iVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.imm16 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let imm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableiopr16i {
    Var0(iopr16iVar0),
}
impl Tableiopr16i {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                iopr16iVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:447:1, end:447:5))"]
#[derive(Clone, Debug)]
struct msk8Var0 {
    imm8: u8,
}
impl msk8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.imm8 as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { imm8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablemsk8 {
    Var0(msk8Var0),
}
impl Tablemsk8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                msk8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:467:1, end:467:6))"]
#[derive(Clone, Debug)]
struct IDX_aVar0 {
    rr7_6: u8,
}
impl IDX_aVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("0,"),
            meaning_0_display(self.rr7_6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let rr7_6 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr7_6 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_a {
    Var0(IDX_aVar0),
}
impl TableIDX_a {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 63) == 0 {
            if let Some((inst_len, parsed)) =
                IDX_aVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:471:1, end:471:6))"]
#[derive(Clone, Debug)]
struct IDX_bVar0 {
    nn4_0: u8,
    rr7_6: u8,
}
impl IDX_bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(
                true,
                (if self.nn4_0 & 16 != 0 { -1 & !15 } else { 0 } | self.nn4_0 as i8).is_negative(),
                (if self.nn4_0 & 16 != 0 { -1 & !15 } else { 0 } | self.nn4_0 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr7_6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let nn4_0 = token_8(tokens_current);
        let rr7_6 = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { nn4_0, rr7_6 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_b {
    Var0(IDX_bVar0),
}
impl TableIDX_b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                IDX_bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:479:1, end:479:6))"]
#[derive(Clone, Debug)]
struct IDX_cVar0 {
    nn3_0: u8,
    rr7_6a: u8,
}
impl IDX_cVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            meaning_22_display(true, self.nn3_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("-"),
            meaning_1_display(self.rr7_6a),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_9(tokens_param) == 1 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 3 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 5 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let rr7_6a = token_6(tokens_current);
        let nn3_0 = token_17(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { nn3_0, rr7_6a }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_c {
    Var0(IDX_cVar0),
}
impl TableIDX_c {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 56) == 40 {
            if let Some((inst_len, parsed)) =
                IDX_cVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:483:1, end:483:6))"]
#[derive(Clone, Debug)]
struct IDX_dVar0 {
    nn3_0: u8,
    rr7_6a: u8,
}
impl IDX_dVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            meaning_22_display(true, self.nn3_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("+"),
            meaning_1_display(self.rr7_6a),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_9(tokens_param) == 1 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 3 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 5 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let nn3_0 = token_17(tokens_current);
        let rr7_6a = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { nn3_0, rr7_6a }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_d {
    Var0(IDX_dVar0),
}
impl TableIDX_d {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                IDX_dVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:487:1, end:487:6))"]
#[derive(Clone, Debug)]
struct IDX_eVar0 {
    nn3_0: u8,
    rr7_6a: u8,
}
impl IDX_eVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            meaning_22_display(true, self.nn3_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.rr7_6a),
            <DisplayElement>::Literal("-"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_9(tokens_param) == 1 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 3 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 5 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let nn3_0 = token_17(tokens_current);
        let rr7_6a = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { nn3_0, rr7_6a }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_e {
    Var0(IDX_eVar0),
}
impl TableIDX_e {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 56) == 56 {
            if let Some((inst_len, parsed)) =
                IDX_eVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:491:1, end:491:6))"]
#[derive(Clone, Debug)]
struct IDX_fVar0 {
    nn3_0: u8,
    rr7_6a: u8,
}
impl IDX_fVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            meaning_22_display(true, self.nn3_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.rr7_6a),
            <DisplayElement>::Literal("+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_9(tokens_param) == 1 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 3 {
                    return Some(((), (), 1));
                }
                if token_9(tokens_param) == 5 {
                    return Some(((), (), 1));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let nn3_0 = token_17(tokens_current);
        let rr7_6a = token_6(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { nn3_0, rr7_6a }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_f {
    Var0(IDX_fVar0),
}
impl TableIDX_f {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                IDX_fVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:499:1, end:499:6))"]
#[derive(Clone, Debug)]
struct IDX_gVar0 {
    aa0_0: u8,
}
impl IDX_gVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            meaning_2_display(self.aa0_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let aa0_0 = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { aa0_0 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:497:1, end:497:6))"]
#[derive(Clone, Debug)]
struct IDX_gVar1 {
    aa0_0: u8,
    rr4_3: u8,
}
impl IDX_gVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            meaning_2_display(self.aa0_0),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr4_3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let aa0_0 = token_5(tokens_current);
        let rr4_3 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { aa0_0, rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_g {
    Var0(IDX_gVar0),
    Var1(IDX_gVar1),
}
impl TableIDX_g {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 254) == 252 {
            if let Some((inst_len, parsed)) =
                IDX_gVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 230) == 228 {
            if let Some((inst_len, parsed)) =
                IDX_gVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:505:1, end:505:6))"]
#[derive(Clone, Debug)]
struct IDX_hVar0 {}
impl IDX_hVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:503:1, end:503:6))"]
#[derive(Clone, Debug)]
struct IDX_hVar1 {
    rr4_3: u8,
}
impl IDX_hVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr4_3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let rr4_3 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_h {
    Var0(IDX_hVar0),
    Var1(IDX_hVar1),
}
impl TableIDX_h {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 254 {
            if let Some((inst_len, parsed)) =
                IDX_hVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 231) == 230 {
            if let Some((inst_len, parsed)) =
                IDX_hVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:519:1, end:519:6))"]
#[derive(Clone, Debug)]
struct IDX_iVar0 {
    ss0_0: u8,
    imm8: u8,
    IDX_i_PCRel: TableIDX_i_PCRel,
}
impl IDX_iVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_opr9: i128 = 0;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .and_then(|shl| {
                i128::try_from((if self.ss0_0 & 1 != 0 { -1 & !0 } else { 0 } | self.ss0_0 as i8))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.imm8).unwrap());
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_opr9.is_negative(), calc_opr9.abs() as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_opr9: i128 = 0;
        let mut block_0_len = 2;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_5(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_1(tokens_current)).unwrap());
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 1;
            if token_9(tokens) != 7 {
                return None;
            }
            if token_10(tokens) != 3 {
                return None;
            }
            if token_11(tokens) != 0 {
                return None;
            }
            if token_13(tokens) != 0 {
                return None;
            }
            let ss0_0 = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let imm8 = token_1(tokens);
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (ss0_0, imm8), pattern_len))
        };
        let ((), (ss0_0, imm8), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let IDX_i_PCRel = if let Some((len, table)) =
            TableIDX_i_PCRel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_i_PCRel,
                ss0_0,
                imm8,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:515:1, end:515:6))"]
#[derive(Clone, Debug)]
struct IDX_iVar1 {
    rr4_3: u8,
    ss0_0: u8,
    imm8: u8,
}
impl IDX_iVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_opr9: i128 = 0;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .and_then(|shl| {
                i128::try_from((if self.ss0_0 & 1 != 0 { -1 & !0 } else { 0 } | self.ss0_0 as i8))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(self.imm8).unwrap());
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_opr9.is_negative(), calc_opr9.abs() as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr4_3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_opr9: i128 = 0;
        let mut block_0_len = 1;
        let ss0_0 = token_5(tokens_current);
        let rr4_3 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        calc_opr9 = (u32::try_from(8i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_5(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_1(tokens_current)).unwrap());
        let imm8 = token_1(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3, ss0_0, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_i {
    Var0(IDX_iVar0),
    Var1(IDX_iVar1),
}
impl TableIDX_i {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 254) == 248 {
            if let Some((inst_len, parsed)) =
                IDX_iVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 230) == 224 {
            if let Some((inst_len, parsed)) =
                IDX_iVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:518:1, end:518:12))"]
#[derive(Clone, Debug)]
struct IDX_i_PCRelVar0 {
    ss0_0: u8,
    imm8: u8,
}
impl IDX_i_PCRelVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_next).unwrap().wrapping_add(
            (u32::try_from(8i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(
                        (if self.ss0_0 & 1 != 0 { -1 & !0 } else { 0 } | self.ss0_0 as i8),
                    )
                    .unwrap()
                    .checked_shl(shl)
                })
                .unwrap_or(0)
                | i128::try_from(self.imm8).unwrap()),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 1;
        let ss0_0 = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 1;
        let imm8 = token_1(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ss0_0, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_i_PCRel {
    Var0(IDX_i_PCRelVar0),
}
impl TableIDX_i_PCRel {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                IDX_i_PCRelVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:533:1, end:533:6))"]
#[derive(Clone, Debug)]
struct IDX_kVar0 {
    simm16: u16,
    IDX_k_PCRel: TableIDX_k_PCRel,
}
impl IDX_kVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(
                true,
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .is_negative(),
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::PC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let IDX_k_PCRel = if let Some((len, table)) =
            TableIDX_k_PCRel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simm16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_k_PCRel,
                simm16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:529:1, end:529:6))"]
#[derive(Clone, Debug)]
struct IDX_kVar1 {
    simm16: u16,
    rr4_3: u8,
}
impl IDX_kVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(
                true,
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .is_negative(),
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr4_3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let rr4_3 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let simm16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16, rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_k {
    Var0(IDX_kVar0),
    Var1(IDX_kVar1),
}
impl TableIDX_k {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 250 {
            if let Some((inst_len, parsed)) =
                IDX_kVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 231) == 226 {
            if let Some((inst_len, parsed)) =
                IDX_kVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:532:1, end:532:12))"]
#[derive(Clone, Debug)]
struct IDX_k_PCRelVar0 {
    simm16: u16,
}
impl IDX_k_PCRelVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_next).unwrap().wrapping_add(
            i128::try_from(
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16),
            )
            .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 2;
        let simm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_k_PCRel {
    Var0(IDX_k_PCRelVar0),
}
impl TableIDX_k_PCRel {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                IDX_k_PCRelVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:548:1, end:548:6))"]
#[derive(Clone, Debug)]
struct IDX_lVar0 {
    simm16: u16,
    IDX_l_PCRel: TableIDX_l_PCRel,
}
impl IDX_lVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .is_negative(),
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let IDX_l_PCRel = if let Some((len, table)) =
            TableIDX_l_PCRel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let simm16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                IDX_l_PCRel,
                simm16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:544:1, end:544:6))"]
#[derive(Clone, Debug)]
struct IDX_lVar1 {
    simm16: u16,
    rr4_3: u8,
}
impl IDX_lVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .is_negative(),
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr4_3),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let rr4_3 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let simm16 = token_21(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16, rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_l {
    Var0(IDX_lVar0),
    Var1(IDX_lVar1),
}
impl TableIDX_l {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 && (tokens_param[0] & 255) == 251 {
            if let Some((inst_len, parsed)) =
                IDX_lVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 3 && (tokens_param[0] & 231) == 227 {
            if let Some((inst_len, parsed)) =
                IDX_lVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:547:1, end:547:12))"]
#[derive(Clone, Debug)]
struct IDX_l_PCRelVar0 {
    simm16: u16,
}
impl IDX_l_PCRelVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_target: i128 = 0;
        calc_target = i128::try_from(inst_next).unwrap().wrapping_add(
            i128::try_from(
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16),
            )
            .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_target.is_negative(),
            calc_target.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_target: i128 = 0;
        let mut block_0_len = 2;
        let simm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_l_PCRel {
    Var0(IDX_l_PCRelVar0),
}
impl TableIDX_l_PCRel {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                IDX_l_PCRelVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:561:1, end:561:6))"]
#[derive(Clone, Debug)]
struct IDX_mVar0 {}
impl IDX_mVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:558:1, end:558:6))"]
#[derive(Clone, Debug)]
struct IDX_mVar1 {
    rr4_3: u8,
}
impl IDX_mVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Register(Register::D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.rr4_3),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let rr4_3 = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rr4_3 }))
    }
}
#[derive(Clone, Debug)]
enum TableIDX_m {
    Var0(IDX_mVar0),
    Var1(IDX_mVar1),
}
impl TableIDX_m {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && (tokens_param[0] & 255) == 255 {
            if let Some((inst_len, parsed)) =
                IDX_mVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 && (tokens_param[0] & 231) == 231 {
            if let Some((inst_len, parsed)) =
                IDX_mVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:569:1, end:569:9))"]
#[derive(Clone, Debug)]
struct indexed3Var0 {
    IDX_a: TableIDX_a,
}
impl indexed3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:570:1, end:570:9))"]
#[derive(Clone, Debug)]
struct indexed3Var1 {
    IDX_b: TableIDX_b,
}
impl indexed3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:571:1, end:571:9))"]
#[derive(Clone, Debug)]
struct indexed3Var2 {
    IDX_c: TableIDX_c,
}
impl indexed3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_c
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:572:1, end:572:9))"]
#[derive(Clone, Debug)]
struct indexed3Var3 {
    IDX_d: TableIDX_d,
}
impl indexed3Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:573:1, end:573:9))"]
#[derive(Clone, Debug)]
struct indexed3Var4 {
    IDX_e: TableIDX_e,
}
impl indexed3Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_e
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:574:1, end:574:9))"]
#[derive(Clone, Debug)]
struct indexed3Var5 {
    IDX_f: TableIDX_f,
}
impl indexed3Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_f
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:575:1, end:575:9))"]
#[derive(Clone, Debug)]
struct indexed3Var6 {
    IDX_g: TableIDX_g,
}
impl indexed3Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_g
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:576:1, end:576:9))"]
#[derive(Clone, Debug)]
struct indexed3Var7 {
    IDX_h: TableIDX_h,
}
impl indexed3Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_h
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:577:1, end:577:9))"]
#[derive(Clone, Debug)]
struct indexed3Var8 {
    IDX_i: TableIDX_i,
}
impl indexed3Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let IDX_i = if let Some((len, table)) =
            TableIDX_i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:578:1, end:578:9))"]
#[derive(Clone, Debug)]
struct indexed3Var9 {
    IDX_k: TableIDX_k,
}
impl indexed3Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_k
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 3;
        let IDX_k = if let Some((len, table)) =
            TableIDX_k::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_k }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed3 {
    Var0(indexed3Var0),
    Var1(indexed3Var1),
    Var2(indexed3Var2),
    Var3(indexed3Var3),
    Var4(indexed3Var4),
    Var5(indexed3Var5),
    Var6(indexed3Var6),
    Var7(indexed3Var7),
    Var8(indexed3Var8),
    Var9(indexed3Var9),
}
impl Tableindexed3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed3Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                indexed3Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                indexed3Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:596:1, end:596:9))"]
#[derive(Clone, Debug)]
struct indexed2Var0 {
    IDX_l: TableIDX_l,
}
impl indexed2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 3;
        let IDX_l = if let Some((len, table)) =
            TableIDX_l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:597:1, end:597:9))"]
#[derive(Clone, Debug)]
struct indexed2Var1 {
    IDX_m: TableIDX_m,
}
impl indexed2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_m
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_m = if let Some((len, table)) =
            TableIDX_m::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_m }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2 {
    Var0(indexed2Var0),
    Var1(indexed2Var1),
}
impl Tableindexed2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                indexed2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:603:1, end:603:9))"]
#[derive(Clone, Debug)]
struct indexed5Var0 {
    IDX_a: TableIDX_a,
}
impl indexed5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:604:1, end:604:9))"]
#[derive(Clone, Debug)]
struct indexed5Var1 {
    IDX_b: TableIDX_b,
}
impl indexed5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:605:1, end:605:9))"]
#[derive(Clone, Debug)]
struct indexed5Var2 {
    IDX_c: TableIDX_c,
}
impl indexed5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_c
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:606:1, end:606:9))"]
#[derive(Clone, Debug)]
struct indexed5Var3 {
    IDX_d: TableIDX_d,
}
impl indexed5Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:607:1, end:607:9))"]
#[derive(Clone, Debug)]
struct indexed5Var4 {
    IDX_e: TableIDX_e,
}
impl indexed5Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_e
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:608:1, end:608:9))"]
#[derive(Clone, Debug)]
struct indexed5Var5 {
    IDX_f: TableIDX_f,
}
impl indexed5Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_f
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:609:1, end:609:9))"]
#[derive(Clone, Debug)]
struct indexed5Var6 {
    IDX_g: TableIDX_g,
}
impl indexed5Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_g
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:610:1, end:610:9))"]
#[derive(Clone, Debug)]
struct indexed5Var7 {
    IDX_h: TableIDX_h,
}
impl indexed5Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_h
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:611:1, end:611:9))"]
#[derive(Clone, Debug)]
struct indexed5Var8 {
    IDX_i: TableIDX_i,
}
impl indexed5Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_i
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let IDX_i = if let Some((len, table)) =
            TableIDX_i::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_i }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:612:1, end:612:9))"]
#[derive(Clone, Debug)]
struct indexed5Var9 {
    IDX_k: TableIDX_k,
}
impl indexed5Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_k
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 3;
        let IDX_k = if let Some((len, table)) =
            TableIDX_k::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_k }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:613:1, end:613:9))"]
#[derive(Clone, Debug)]
struct indexed5Var10 {
    IDX_l: TableIDX_l,
}
impl indexed5Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 3;
        let IDX_l = if let Some((len, table)) =
            TableIDX_l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:614:1, end:614:9))"]
#[derive(Clone, Debug)]
struct indexed5Var11 {
    IDX_m: TableIDX_m,
}
impl indexed5Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_m
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_m = if let Some((len, table)) =
            TableIDX_m::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_m }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed5 {
    Var0(indexed5Var0),
    Var1(indexed5Var1),
    Var2(indexed5Var2),
    Var3(indexed5Var3),
    Var4(indexed5Var4),
    Var5(indexed5Var5),
    Var6(indexed5Var6),
    Var7(indexed5Var7),
    Var8(indexed5Var8),
    Var9(indexed5Var9),
    Var10(indexed5Var10),
    Var11(indexed5Var11),
}
impl Tableindexed5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                indexed5Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                indexed5Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 3 {
            if let Some((inst_len, parsed)) =
                indexed5Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed5Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:619:1, end:619:9))"]
#[derive(Clone, Debug)]
struct indexed1Var0 {
    IDX_a: TableIDX_a,
}
impl indexed1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_a
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_a = if let Some((len, table)) =
            TableIDX_a::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_a }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:620:1, end:620:9))"]
#[derive(Clone, Debug)]
struct indexed1Var1 {
    IDX_b: TableIDX_b,
}
impl indexed1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_b = if let Some((len, table)) =
            TableIDX_b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:621:1, end:621:9))"]
#[derive(Clone, Debug)]
struct indexed1Var2 {
    IDX_c: TableIDX_c,
}
impl indexed1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_c
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_c = if let Some((len, table)) =
            TableIDX_c::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_c }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:622:1, end:622:9))"]
#[derive(Clone, Debug)]
struct indexed1Var3 {
    IDX_d: TableIDX_d,
}
impl indexed1Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_d = if let Some((len, table)) =
            TableIDX_d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:623:1, end:623:9))"]
#[derive(Clone, Debug)]
struct indexed1Var4 {
    IDX_e: TableIDX_e,
}
impl indexed1Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_e
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_e = if let Some((len, table)) =
            TableIDX_e::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_e }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:624:1, end:624:9))"]
#[derive(Clone, Debug)]
struct indexed1Var5 {
    IDX_f: TableIDX_f,
}
impl indexed1Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_f
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_f = if let Some((len, table)) =
            TableIDX_f::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_f }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:625:1, end:625:9))"]
#[derive(Clone, Debug)]
struct indexed1Var6 {
    IDX_g: TableIDX_g,
}
impl indexed1Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_g
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_g = if let Some((len, table)) =
            TableIDX_g::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_g }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:626:1, end:626:9))"]
#[derive(Clone, Debug)]
struct indexed1Var7 {
    IDX_h: TableIDX_h,
}
impl indexed1Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.IDX_h
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let IDX_h = if let Some((len, table)) =
            TableIDX_h::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { IDX_h }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1 {
    Var0(indexed1Var0),
    Var1(indexed1Var1),
    Var2(indexed1Var2),
    Var3(indexed1Var3),
    Var4(indexed1Var4),
    Var5(indexed1Var5),
    Var6(indexed1Var6),
    Var7(indexed1Var7),
}
impl Tableindexed1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:640:1, end:640:11))"]
#[derive(Clone, Debug)]
struct indexed1_1Var0 {
    indexed1: Tableindexed1,
}
impl indexed1_1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed1 = if let Some((len, table)) =
            Tableindexed1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_1 {
    Var0(indexed1_1Var0),
}
impl Tableindexed1_1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1_1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:648:1, end:648:11))"]
#[derive(Clone, Debug)]
struct indexed2_1Var0 {
    indexed1: Tableindexed1,
}
impl indexed2_1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed1 = if let Some((len, table)) =
            Tableindexed1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_1 {
    Var0(indexed2_1Var0),
}
impl Tableindexed2_1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed2_1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:660:1, end:660:11))"]
#[derive(Clone, Debug)]
struct indexed0_2Var0 {
    indexed2: Tableindexed2,
}
impl indexed0_2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed2 = if let Some((len, table)) =
            Tableindexed2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed0_2 {
    Var0(indexed0_2Var0),
}
impl Tableindexed0_2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed0_2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:666:1, end:666:11))"]
#[derive(Clone, Debug)]
struct indexed0_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed0_3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed3 = if let Some((len, table)) =
            Tableindexed3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed0_3 {
    Var0(indexed0_3Var0),
}
impl Tableindexed0_3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed0_3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:670:1, end:670:11))"]
#[derive(Clone, Debug)]
struct indexed1_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed1_3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed3 = if let Some((len, table)) =
            Tableindexed3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_3 {
    Var0(indexed1_3Var0),
}
impl Tableindexed1_3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed1_3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:682:1, end:682:11))"]
#[derive(Clone, Debug)]
struct indexed2_3Var0 {
    indexed3: Tableindexed3,
}
impl indexed2_3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed3 = if let Some((len, table)) =
            Tableindexed3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_3 {
    Var0(indexed2_3Var0),
}
impl Tableindexed2_3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                indexed2_3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:690:1, end:690:11))"]
#[derive(Clone, Debug)]
struct indexedA_5Var0 {
    indexed5: Tableindexed5,
}
impl indexedA_5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed5 = if let Some((len, table)) =
            Tableindexed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum TableindexedA_5 {
    Var0(indexedA_5Var0),
}
impl TableindexedA_5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && context_param.0 & 2 == 0 {
            if let Some((inst_len, parsed)) =
                indexedA_5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:709:1, end:709:11))"]
#[derive(Clone, Debug)]
struct indexed1_5Var0 {
    indexed5: Tableindexed5,
}
impl indexed1_5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed5 = if let Some((len, table)) =
            Tableindexed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed1_5 {
    Var0(indexed1_5Var0),
}
impl Tableindexed1_5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && context_param.0 & 2 == 0 {
            if let Some((inst_len, parsed)) =
                indexed1_5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:728:1, end:728:11))"]
#[derive(Clone, Debug)]
struct indexed2_5Var0 {
    indexed5: Tableindexed5,
}
impl indexed2_5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed5 = if let Some((len, table)) =
            Tableindexed5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableindexed2_5 {
    Var0(indexed2_5Var0),
}
impl Tableindexed2_5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 && context_param.0 & 2 == 0 {
            if let Some((inst_len, parsed)) =
                indexed2_5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:747:1, end:747:5))"]
#[derive(Clone, Debug)]
struct rel8Var0 {
    rel: u8,
}
impl rel8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next).unwrap().wrapping_add(
            i128::try_from((if self.rel & 128 != 0 { -1 & !127 } else { 0 } | self.rel as i8))
                .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 1;
        let rel = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rel }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel8 {
    Var0(rel8Var0),
}
impl Tablerel8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                rel8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:750:1, end:750:5))"]
#[derive(Clone, Debug)]
struct rel9Var0 {
    sign12_12: u8,
    rr7_0: u8,
}
impl rel9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next).unwrap().wrapping_add(
            (u32::try_from(8i128)
                .ok()
                .and_then(|shl| {
                    i128::try_from(
                        (if self.sign12_12 & 1 != 0 { -1 & !0 } else { 0 } | self.sign12_12 as i8),
                    )
                    .unwrap()
                    .checked_shl(shl)
                })
                .unwrap_or(0)
                | i128::try_from(self.rr7_0).unwrap()),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        let sign12_12 = token_23(tokens_current);
        let rr7_0 = token_27(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sign12_12, rr7_0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel9 {
    Var0(rel9Var0),
}
impl Tablerel9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                rel9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:753:1, end:753:6))"]
#[derive(Clone, Debug)]
struct rel16Var0 {
    simm16: u16,
}
impl rel16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next).unwrap().wrapping_add(
            i128::try_from(
                (if self.simm16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.simm16 as i16),
            )
            .unwrap(),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        let simm16 = token_21(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { simm16 }))
    }
}
#[derive(Clone, Debug)]
enum Tablerel16 {
    Var0(rel16Var0),
}
impl Tablerel16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                rel16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:756:1, end:756:13))"]
#[derive(Clone, Debug)]
struct op2_opr16a_8Var0 {
    opr16a_8: Tableopr16a_8,
}
impl op2_opr16a_8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.opr16a_8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let opr16a_8 = if let Some((len, table)) =
            Tableopr16a_8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_opr16a_8 {
    Var0(op2_opr16a_8Var0),
}
impl Tableop2_opr16a_8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                op2_opr16a_8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:757:1, end:757:14))"]
#[derive(Clone, Debug)]
struct op2_opr16a_16Var0 {
    opr16a_16: Tableopr16a_16,
}
impl op2_opr16a_16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.opr16a_16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let opr16a_16 = if let Some((len, table)) =
            Tableopr16a_16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { opr16a_16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_opr16a_16 {
    Var0(op2_opr16a_16Var0),
}
impl Tableop2_opr16a_16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                op2_opr16a_16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:762:1, end:762:15))"]
#[derive(Clone, Debug)]
struct op2_indexed1_1Var0 {
    indexed1_1: Tableindexed1_1,
}
impl op2_indexed1_1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed1_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed1_1 = if let Some((len, table)) =
            Tableindexed1_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed1_1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_indexed1_1 {
    Var0(op2_indexed1_1Var0),
}
impl Tableop2_indexed1_1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                op2_indexed1_1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:768:1, end:768:15))"]
#[derive(Clone, Debug)]
struct op2_indexed2_1Var0 {
    indexed2_1: Tableindexed2_1,
}
impl op2_indexed2_1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.indexed2_1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 1;
        let indexed2_1 = if let Some((len, table)) =
            Tableindexed2_1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { indexed2_1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableop2_indexed2_1 {
    Var0(op2_indexed2_1Var0),
}
impl Tableop2_indexed2_1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 1 {
            if let Some((inst_len, parsed)) =
                op2_indexed2_1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:1964:1, end:1964:14))"]
#[derive(Clone, Debug)]
struct SkipNextInstrVar0 {}
impl SkipNextInstrVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_dest: i128 = 0;
        calc_dest = i128::try_from(inst_next).unwrap().wrapping_add(1i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_dest.is_negative(),
            calc_dest.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_dest: i128 = 0;
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSkipNextInstr {
    Var0(SkipNextInstrVar0),
}
impl TableSkipNextInstr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 4 == 0 {
            if let Some((inst_len, parsed)) =
                SkipNextInstrVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2072:1, end:2072:9))"]
#[derive(Clone, Debug)]
struct CallDestVar0 {
    imm8: u8,
    PageDest: TablePageDest,
}
impl CallDestVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.PageDest
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.imm8 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 3;
        let mut sub_pattern_c30 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            let imm16 = token_21(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            let mut block_1_len = 1;
            let imm8 = token_1(tokens);
            pattern_len += block_1_len;
            tokens = &tokens[usize::try_from(block_1_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (imm16, imm8), pattern_len))
        };
        let ((), (imm16, imm8), sub_len) = sub_pattern_c30(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let PageDest = if let Some((len, table)) =
            TablePageDest::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { PageDest, imm8 }))
    }
}
#[derive(Clone, Debug)]
enum TableCallDest {
    Var0(CallDestVar0),
}
impl TableCallDest {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 3 && context_param.0 & 4 == 0 {
            if let Some((inst_len, parsed)) =
                CallDestVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:2633:1, end:2633:15))"]
#[derive(Clone, Debug)]
struct SkipNext2BytesVar0 {}
impl SkipNext2BytesVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_dest: i128 = 0;
        calc_dest = i128::try_from(inst_next).unwrap().wrapping_add(2i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_dest.is_negative(),
            calc_dest.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_dest: i128 = 0;
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSkipNext2Bytes {
    Var0(SkipNext2BytesVar0),
}
impl TableSkipNext2Bytes {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 4 == 0 {
            if let Some((inst_len, parsed)) =
                SkipNext2BytesVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3827:1, end:3827:7))"]
#[derive(Clone, Debug)]
struct GPagedVar0 {}
impl GPagedVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("G")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_UseGPAGE(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/HCS12/data/languages/HCS_HC12.sinc, start:3828:1, end:3828:7))"]
#[derive(Clone, Debug)]
struct GPagedVar1 {}
impl GPagedVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_UseGPAGE(u8::try_from(0i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableGPaged {
    Var0(GPagedVar0),
    Var1(GPagedVar1),
}
impl TableGPaged {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 5 == 1 {
            if let Some((inst_len, parsed)) =
                GPagedVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 5 == 0 {
            if let Some((inst_len, parsed)) =
                GPagedVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
